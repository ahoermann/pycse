#+title: PYCSE YouTube channel

#+BEGIN_SRC emacs-lisp
(get-qr-code "https://github.com/jkitchin/pycse" "./pycse-qr-code.png")
#+END_SRC

#+RESULTS:

 [[./pycse-qr-code.png]]


- loops :: [[./iteration.org]] (https://youtu.be/7rVsD9kT9RM)
- Polynomials :: [[./polynomials.org]]  (https://youtu.be/8e1yOKMTP8o)
- Simple integral :: [[https://colab.research.google.com/drive/1mPWD-X4GUWLpDe-ANdd45rC-U1hCdhiz?usp=sharing][Colab notes]] (https://www.youtube.com/watch?v=6xAO7te0kdA)
- IVP :: [[./solve_ivp-1.org]] (https://youtu.be/4H0Qr-gxMN4)
- fsolve :: [[./simple-fsolve.org]] (https://youtu.be/KeRNoXWs_y0)
- minimization ::  [[./minimize.org]] (https://youtu.be/2HMKU2nHAbE)
- constrained minimization :: [[./constrained-minimize.org]]  (https://youtu.be/QKiOm1iqciE)


* Video log

- Basic Python
  - Conditional statements https://www.youtube.com/watch?v=XymPeBMILUY&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=2
  - Membership operators https://www.youtube.com/watch?v=CZstHHjfCHo&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=3
  - Logical operators https://www.youtube.com/watch?v=q-uDWDSF0l8&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=4
  - Comparison operators https://www.youtube.com/watch?v=BayqeeF_iKM&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=5
  - Operator precedence https://www.youtube.com/watch?v=Vy4USf-UVAI&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=19
  - Iteration https://www.youtube.com/watch?v=7rVsD9kT9RM&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=16
  - functions https://www.youtube.com/watch?v=kidVLLHtzbc&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=17

- Math
  - Integration https://www.youtube.com/watch?v=6xAO7te0kdA&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=10
  - polynomials https://www.youtube.com/watch?v=8e1yOKMTP8o&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=11
  - Numpy array broadcasting https://www.youtube.com/watch?v=slWgreHaQNE&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=23
  - Array broadcasting example https://www.youtube.com/watch?v=FXhEKNtvoVs&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=24

- Root finding
  - solving nonlinear functions https://www.youtube.com/watch?v=KeRNoXWs_y0&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=15
  - Newton's method https://www.youtube.com/watch?v=spLsyP-5PF8&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=1
  - Replacing fsolve https://www.youtube.com/watch?v=_1bOzIYcDaA&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=6
  - root failures https://www.youtube.com/watch?v=FaOJxeVfeH4&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=26

- Differential equations
  - first order ODEs https://www.youtube.com/watch?v=4H0Qr-gxMN4&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=14
  - events in ODEs https://www.youtube.com/watch?v=fv_-3ZtYBEo&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=25 
  - BVPs https://www.youtube.com/watch?v=vWcRuay1tt4&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=7

- Optimization
  - minimizing a function https://www.youtube.com/watch?v=2HMKU2nHAbE&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=13
  - constrained optimization https://www.youtube.com/watch?v=QKiOm1iqciE&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=12

- Data
  - Using Excel in colab https://www.youtube.com/watch?v=rfcstL5eTbs&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=8
  - Reading data files in colab https://www.youtube.com/watch?v=xf6qprxmBaM&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=21
  - More ways to read data in colab https://www.youtube.com/watch?v=NjRd41QtU14&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=22
  - linear regression https://www.youtube.com/watch?v=ZXSaLcFSOsU&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=20
  - nonlinear regression https://www.youtube.com/watch?v=hbchKAgeDcU&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=18

- Miscellaneous
  - hand written work in Jupyter lab https://www.youtube.com/watch?v=5qCY9Eoeoyo&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=9
  - uncertainty quantification https://www.youtube.com/watch?v=KP-km6XedVg&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=27
  - units in python https://www.youtube.com/watch?v=au5Jwz_STXI&list=PL0sMmOaE_gs2yzwy54kLZk5c1ZH-Nh-62&index=28

* DONE Getting to the root of it
CLOSED: [2021-10-13 Wed 15:12]

#+attr_org: :width 400
[[/Users/jkitchin/Dropbox/python/pycse/pycse-channel/root.png]]

TIL fsolve is a "[[https://docs.scipy.org/doc/scipy/reference/optimize.html#legacy-functions][legacy]]" function in scipy.optimize. The newer, preferred function is =scipy.optimize.root=. I will explore how to use this newer function in this video. 

I will use this equation, and try to solve it for the value of $Fa$ that makes it true.


$100 = \int_{Fa(V=0)}^{Fa} \frac{1}{-k Fa / \nu}dFa$

#+BEGIN_SRC jupyter-python
from scipy.integrate import quad

k = 0.23
nu = 10.0
Fao = 1.0

def integrand(Fa):
    return -1 / (k * Fa / nu)

def objective(Fa):
    I, _ = quad(integrand, Fao, Fa)
    return 100 - I

objective(0.1*Fao)
#+END_SRC

#+RESULTS:
: -0.11239534756749947

#+BEGIN_SRC jupyter-python
from scipy.optimize import fsolve

fsolve(objective, 0.1 * Fao)
#+END_SRC

#+RESULTS:
: array([0.10025884])

#+BEGIN_SRC jupyter-python
objective(0.10025884)
#+END_SRC

#+RESULTS:
: -1.614431766938651e-06

#+BEGIN_SRC jupyter-python
?fsolve
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
from scipy.optimize import root
?root
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
root(objective, 0.1)
#+END_SRC

#+RESULTS:
:     fjac: array([[-1.]])
:      fun: -3.126388037344441e-13
:  message: 'The solution converged.'
:     nfev: 5
:      qtf: array([1.87292045e-07])
:        r: array([-433.66083096])
:   status: 1
:  success: True
:        x: array([0.10025884])



* pycse - Comparison operators in #Python

#+attr_org: :width 400
[[/Users/jkitchin/Dropbox/python/pycse/pycse-channel/screenshots/comparison-operators.png]]

Comparison operators are used to compare to objects, e.g. to say if one is less than or greater than, less than or equal, greater than or equal, equal, or not equal. These expressions evaluate to a Boolean (True/False). In this video, we explore the operators, and how we use them.

| operator | description           |
|----------+-----------------------|
| ==       | equal                 |
| !=       | not equal             |
| >        | greater               |
| <        | less                  |
| >=       | greater than or equal |
| <=       | less than or equal    |


#+BEGIN_SRC jupyter-python
ans = 4 == 4
ans
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC jupyter-python
4 != 4
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC jupyter-python
4 == 16 / 4.0
#+END_SRC

#+RESULTS:
: True

 
#+BEGIN_SRC jupyter-python
4 <= 3
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC jupyter-python
a = 4
b = 3

if a > b:
    # do something
#+END_SRC

* DONE Logical operators
CLOSED: [2021-10-14 Thu 16:22]

#+attr_org: :width 400
[[/Users/jkitchin/Dropbox/python/pycse/pycse-channel/screenshots/logical-operators.png]]
Logical operators are used to combine Boolean values (True/False) to compute things like:

1. if two or more things are all True
2. if one of two or more things are True
3. to negate something, i.e. if something is not True or not False

There are three logical operators:

- and
- or
- not

** The basics with Boolean variables

#+caption: The and truth table.
|       | True  | False |
|-------+-------+-------|
| True  | True  | False |
| False | False | False |

#+BEGIN_SRC jupyter-python
[True and True,
True and False,
False and True,
False and False]
#+END_SRC

#+RESULTS:
| True | False | False | False |

#+BEGIN_SRC jupyter-python
((True and True) and True) and True
#+END_SRC

#+RESULTS:
: True


#+caption: The or truth table.
|       | True | False |
|-------+------+-------|
| True  | True | True  |
| False | True | False |

#+BEGIN_SRC jupyter-python
[True or True,
True or False,
False or True,
False or False]
#+END_SRC

#+RESULTS:
| True | True | True | False |

#+BEGIN_SRC jupyter-python
False or False or True or False
#+END_SRC

#+RESULTS:
: True


#+caption: The not truth table
|       | not   |
|-------+-------|
| True  | False |
| False | True  |

#+BEGIN_SRC jupyter-python
[not True,
 not False]
#+END_SRC

#+RESULTS:
| False | True |

#+BEGIN_SRC jupyter-python
(not (True or False)) or True
#+END_SRC

#+RESULTS:
: True


** Truthiness

Things that are Falsish:
- False, 0, [], (), '', "", '''''', """""", None

Everything else is Truthy!

#+BEGIN_SRC jupyter-python
[not False,
not 0,
not [],
not (),
not '',
not "",
not '''''',
not """""",
not None]
#+END_SRC

#+RESULTS:
| True | True | True | True | True | True | True | True | True |

#+BEGIN_SRC jupyter-python
[not True,
not -1,
not [1],
not (2),
not 'r',
not "r",
not '''r''',
not """r"""]
#+END_SRC

#+RESULTS:
| False | False | False | False | False | False | False | False |


Note: The logical operators do not always evaluate to True/False : 

The operator =not= yields True if its argument is false, False otherwise.

The expression x and y first evaluates x; if x is false, its value is returned; otherwise, y is evaluated and the resulting value is returned.

#+BEGIN_SRC jupyter-python
0 and False
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC jupyter-python
True and 'a' and 55
#+END_SRC

#+RESULTS:
: 55


The expression x or y first evaluates x; if x is true, its value is returned; otherwise, y is evaluated and the resulting value is returned.

#+BEGIN_SRC jupyter-python
False or 55 or False
#+END_SRC

#+RESULTS:
: 55

#+BEGIN_SRC jupyter-python
balance = 100

balance -= 50

(balance > 0) and (balance > 20)
#+END_SRC

#+RESULTS:
: True

* Membership operators

#+attr_org: :width 800
[[/Users/jkitchin/Dropbox/python/pycse/pycse-channel/screenshots/membership-operators.png]]

The membership operators test if something is a member of a "collection".
The membership operators are =in= and =not in=.

#+BEGIN_SRC jupyter-python
'brown fox' in  'the quick brown fox'
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC jupyter-python
'tree' not in  [0, 4, 2, 'oak tree']
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC jupyter-python
4 in (0, 4, 2, 'tree')
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC jupyter-python
'tree' in {0, 4, 2, 'tree'}
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC jupyter-python
'tree' in {0: 'n', 4: 't', 2: 'w', 'tree': 'i'}
#+END_SRC

#+RESULTS:
: True

* Conditional / control statements in Python

#+attr_org: :width 300
[[././screenshots/2021-10-13-15-18-45.png]]
Conditional statements (if/elif/else) are used to control the flow of your program.

#+BEGIN_SRC jupyter-python
if False:
    print('its ok')
else:
    print('Nope')
#+END_SRC

#+RESULTS:
: Nope

#+BEGIN_SRC jupyter-python
a = 50

if a > 10:
    print('a is large')
else:
    print('a is less than 10')
#+END_SRC

#+RESULTS:
: a is large

#+BEGIN_SRC jupyter-python
a = 5
if a > 10:
    print('a is large')
elif a > 7:
    print('a is medium++')
elif a > 5:
    print('a is medium')
else:
    print('a is small')
#+END_SRC

#+RESULTS:
: a is small

#+BEGIN_SRC jupyter-python
a = 1
if a > 10:
    if a > 20:
        print('a > 20')
    else:
        print('a is between 10 and 20')
elif a > 7:
    print('medium')
else:
    print('fell through')
#+END_SRC

#+RESULTS:
: fell through

Given a number, divide it by 2 until the division result is less than 1

#+BEGIN_SRC jupyter-python
n = 10

while n > 1:
    n /= 2
    print(n)

n
#+END_SRC

#+RESULTS:
:RESULTS:
: 5.0
: 2.5
: 1.25
: 0.625
: 0.625
:END:

#+BEGIN_SRC jupyter-python
n = 10
for i in range(20):
    n /= 2
    print(i, n)
    if n < 1:
        break
#+END_SRC

#+RESULTS:
: 0 5.0
: 1 2.5
: 2 1.25
: 3 0.625

* Future topics

** DONE BVP
CLOSED: [2021-10-13 Wed 15:12]
[[./bvp.org]]

** DONE integrals
   CLOSED: [2021-10-01 Fri 17:17]

[[././screenshots/2021-10-01:16:57:40.png]]




** DONE linear regression
CLOSED: [2021-11-23 Tue 07:59]

** DONE nonlinear regression
CLOSED: [2021-11-23 Tue 07:59]

** DONE confidence intervals
CLOSED: [2021-11-23 Tue 07:59]

** DONE jupyter lab
CLOSED: [2021-10-13 Wed 15:12]

#+attr_org: :width 300
[[././screenshots/2021-10-04:14:00:02.png]]

#+BEGIN_SRC jupyter-python
import numpy as np

A = [[1, 1],
     [2, -1]]

b = [5, 0]

m1, m2 = np.linalg.solve(A, b)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python  
1 * m1 + 1 * m2
#+END_SRC

#+RESULTS:
: 5.0


#+BEGIN_SRC jupyter-python  
2 * m1 - m2
#+END_SRC

#+RESULTS:
: 0.0


#+BEGIN_SRC jupyter-python  

#+END_SRC




* DONE Newton's Method
CLOSED: [2021-10-21 Thu 16:30]

#+attr_org: :width 800
[[/Users/jkitchin/Dropbox/python/pycse/pycse-channel/screenshots/newtons-method.png]]
#+attr_org: :width 800
[[././screenshots/2021-10-17-17-41-01.png]]

#+BEGIN_SRC jupyter-python
import numpy as np

def f(x):
    return np.exp(-x) - 0.5

def fprime(x):
    return -np.exp(-x)

import matplotlib.pyplot as plt
X = np.linspace(0, 1)
plt.plot(X, f(X))
plt.axhline(0)
plt.xlabel('x')
plt.ylabel('y');
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/42d8c0be4d6257905ab47318a9efd90b8b15be53.png]]

#+BEGIN_SRC jupyter-python
x0 = 0.69048842440

x1 = x0 - f(x0) / fprime(0)
x1, f(x1)
#+END_SRC

#+RESULTS:
| 0.6918195712933193 | 0.000664245464966684 |

#+BEGIN_SRC jupyter-python
x0 = 0.6
for i in range(10):
    x1 = x0 - f(x0) / fprime(x0)
    print(x1, f(x1))
    x0 = x1
#+END_SRC

#+RESULTS:
: 0.6889405998047456 0.0021077204176078723
: 0.6931383452922176 4.417653379440445e-06
: 0.6931471805209145 1.951538930455854e-11
: 0.6931471805599453 0.0
: 0.6931471805599453 0.0
: 0.6931471805599453 0.0
: 0.6931471805599453 0.0
: 0.6931471805599453 0.0
: 0.6931471805599453 0.0
: 0.6931471805599453 0.0

Analytical answer
#+BEGIN_SRC jupyter-python
-np.log(0.5)
#+END_SRC

#+RESULTS:
: 0.6931471805599453

#+BEGIN_SRC jupyter-python
x0 = 0.6
tolerance = 1e-6

for i in range(10):
    x1 = x0 - f(x0) / fprime(x0)
    print(x1, f(x1))
    x0 = x1
    if np.abs(f(x1)) < tolerance:
        break
#+END_SRC

#+RESULTS:
: 0.6889405998047456 0.0021077204176078723
: 0.6931383452922176 4.417653379440445e-06
: 0.6931471805209145 1.951538930455854e-11

#+BEGIN_SRC jupyter-python
from scipy.optimize import newton
?newton
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
newton(f, 0.6)
#+END_SRC

#+RESULTS:
: 0.6931471805599454

#+BEGIN_SRC jupyter-python
from scipy.optimize import fsolve, root

fsolve(f, 0.6)
#+END_SRC

#+RESULTS:
: array([0.69314718])

#+BEGIN_SRC jupyter-python
root(f, 0.6)
#+END_SRC

#+RESULTS:
:     fjac: array([[-1.]])
:      fun: array([-5.55111512e-17])
:  message: 'The solution converged.'
:     nfev: 7
:      qtf: array([-1.95193861e-11])
:        r: array([0.5000001])
:   status: 1
:  success: True
:        x: array([0.69314718])



* TODO Creating arrays in numpy

- np.linspace

- np.zeros
- np.ones
- np.stack


#+BEGIN_SRC jupyter-python
import numpy as np

x = np.linspace(0, 1, 5)
x
#+END_SRC

#+RESULTS:
: array([0.  , 0.25, 0.5 , 0.75, 1.  ])

#+BEGIN_SRC jupyter-python
np.stack([x, x**2, x**3])
#+END_SRC

#+RESULTS:
: array([[0.      , 0.25    , 0.5     , 0.75    , 1.      ],
:        [0.      , 0.0625  , 0.25    , 0.5625  , 1.      ],
:        [0.      , 0.015625, 0.125   , 0.421875, 1.      ]])


* Reading data files
ppppngpaste
#+attr_org: :width 800
[[/Users/jkitchin/Dropbox/python/pycse/pycse-channel/screenshots/reading-files-colab.png]]

https://itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat

#+BEGIN_SRC jupyter-python
import pandas as pd

pd.read_csv('https://itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat')
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
---------------------------------------------------------------------------
ParserError                               Traceback (most recent call last)
/var/folders/3q/ht_2mtk52hl7ydxrcr87z2gr0000gn/T/ipykernel_89354/2794543045.py in <module>
      1 import pandas as pd
      2 
----> 3 pd.read_csv('https://itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat')

~/opt/anaconda3/lib/python3.8/site-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)
    309                     stacklevel=stacklevel,
    310                 )
--> 311             return func(*args, **kwargs)
    312 
    313         return wrapper

~/opt/anaconda3/lib/python3.8/site-packages/pandas/io/parsers/readers.py in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, error_bad_lines, warn_bad_lines, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options)
    584     kwds.update(kwds_defaults)
    585 
--> 586     return _read(filepath_or_buffer, kwds)
    587 
    588 

~/opt/anaconda3/lib/python3.8/site-packages/pandas/io/parsers/readers.py in _read(filepath_or_buffer, kwds)
    486 
    487     with parser:
--> 488         return parser.read(nrows)
    489 
    490 

~/opt/anaconda3/lib/python3.8/site-packages/pandas/io/parsers/readers.py in read(self, nrows)
   1045     def read(self, nrows=None):
   1046         nrows = validate_integer("nrows", nrows)
-> 1047         index, columns, col_dict = self._engine.read(nrows)
   1048 
   1049         if index is None:

~/opt/anaconda3/lib/python3.8/site-packages/pandas/io/parsers/c_parser_wrapper.py in read(self, nrows)
    221         try:
    222             if self.low_memory:
--> 223                 chunks = self._reader.read_low_memory(nrows)
    224                 # destructive to chunks
    225                 data = _concatenate_chunks(chunks)

~/opt/anaconda3/lib/python3.8/site-packages/pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader.read_low_memory()

~/opt/anaconda3/lib/python3.8/site-packages/pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._read_rows()

~/opt/anaconda3/lib/python3.8/site-packages/pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._tokenize_rows()

~/opt/anaconda3/lib/python3.8/site-packages/pandas/_libs/parsers.pyx in pandas._libs.parsers.raise_parser_error()

ParserError: Error tokenizing data. C error: Expected 1 fields in line 10, saw 3
:END:

#+BEGIN_SRC jupyter-python
import urllib.request
urllib.request.urlretrieve('https://itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat', 'Norris.dat')
#+END_SRC

#+RESULTS:
:RESULTS:
| Norris.dat | <http.client.HTTPMessage | at | 0x7fe41073efd0> |
:END:

#+BEGIN_SRC jupyter-python
for i, line in enumerate(open('Norris.dat')):
    print(i, line)
#+END_SRC

#+RESULTS:
:RESULTS:
0 NIST/ITL StRD

1 Dataset Name:  Norris (Norris.dat)

2 

3 File Format:   ASCII

4                Certified Values  (lines 31 to 46)

5                Data              (lines 61 to 96)

6 

7 Procedure:     Linear Least Squares Regression

8 

9 Reference:     Norris, J., NIST.  

10                Calibration of Ozone Monitors.

11 

12 Data:          1 Response Variable (y)

13                1 Predictor Variable (x)

14                36 Observations

15                Lower Level of Difficulty

16                Observed Data

17 

18 Model:         Linear Class

19                2 Parameters (B0,B1)

20 

21                y = B0 + B1*x + e

22 

23 

24 

25                Certified Regression Statistics

26 

27                                           Standard Deviation

28      Parameter          Estimate             of Estimate

29 

30         B0        -0.262323073774029     0.232818234301152

31         B1         1.00211681802045      0.429796848199937E-03

32 

33      Residual

34      Standard Deviation   0.884796396144373

35 

36      R-Squared            0.999993745883712

37 

38 

39                Certified Analysis of Variance Table

40 

41 Source of Degrees of    Sums of             Mean  

42 Variation  Freedom      Squares            Squares           F Statistic

43               

44 Regression    1     4255954.13232369   4255954.13232369   5436385.54079785

45 Residual     34     26.6173985294224   0.782864662630069

46 

47                  

48                                           

49                                           

50                                                            

51 

52                             

53                                    

54                                                        

55 

56 

57 

58 

59 Data:       y          x

60            0.1        0.2

61          338.8      337.4

62          118.1      118.2

63          888.0      884.6

64            9.2       10.1

65          228.1      226.5

66          668.5      666.3

67          998.5      996.3

68          449.1      448.6

69          778.9      777.0

70          559.2      558.2

71            0.3        0.4

72            0.1        0.6

73          778.1      775.5

74          668.8      666.9

75          339.3      338.0

76          448.9      447.5

77           10.8       11.6

78          557.7      556.0

79          228.3      228.1

80          998.0      995.8

81          888.8      887.6

82          119.6      120.2

83            0.3        0.3

84            0.6        0.3

85          557.6      556.8

86          339.3      339.1

87          888.0      887.2

88          998.5      999.0

89          778.9      779.0

90           10.2       11.1

91          117.6      118.3

92          228.9      229.2

93          668.4      669.1

94          449.2      448.9

95            0.2        0.5

96                                    
:END:




#+attr_org: :width 800
[[/Users/jkitchin/Dropbox/python/pycse/pycse-channel/screenshots/files-colab-2.png]]
