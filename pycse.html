<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-09-22 Wed 16:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>pycse - Python3 Computations in Science and Engineering</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">pycse - Python3 Computations in Science and Engineering</h1>
<center>
John Kitchin <br>
<a href="mailto:jkitchin@andrew.cmu.edu">jkitchin@andrew.cmu.edu</a> <br>
<a href="http://kitchingroup.cheme.cmu.edu">https://kitchingroup.cheme.cmu.edu</a><br>
Twitter: <a href="https://twitter.com/johnkitchin">@johnkitchin</a>
<a href="https://github.com/jkitchin/pycse">pycse</a>
</center>


<div id="org725bef4" class="figure">
<p><img src="./pycse.png" alt="pycse.png" />
</p>
</div>

<div id="outline-container-org9e171de" class="outline-2">
<h2 id="org9e171de"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
This is a collection of examples of using python in the kinds of scientific and engineering computations I have used in classes and research. They are organized by topics.
</p>


<p>
I recommend the Continuum IO Anaconda python distribution (<a href="https://www.continuum.io">https://www.continuum.io</a>). This distribution is free for academic use, and cheap otherwise. It is pretty complete in terms of mathematical, scientific and plotting modules. All of the examples in this book were created run with the Anaconda python distribution.
</p>
</div>
</div>

<div id="outline-container-org4f882b7" class="outline-2">
<h2 id="org4f882b7"><span class="section-number-2">2.</span> Basic python usage</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orga4080bc" class="outline-3">
<h3 id="orga4080bc"><span class="section-number-3">2.1.</span> Basic math</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Python is a basic calculator out of the box. Here we consider the most basic mathematical operations: addition, subtraction, multiplication, division and exponenetiation. we use the func:print to get the output. For now we consider integers and float numbers. An integer is a plain number like 0, 10 or -2345. A float number has a decimal in it. The following are all floats: 1.0, -9., and 3.56. Note the trailing zero is not required, although it is good style.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(2 + 4)
<span style="color: #0000FF;">print</span>(8.1 - 5)
</pre>
</div>


<p>
Multiplication is equally straightforward.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(5 * 4)
<span style="color: #0000FF;">print</span>(3.1 * 2)
</pre>
</div>

<p>
Division is almost as straightforward, but we have to remember that integer division is not the same as float division. Let us consider float division first.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(4.0 / 2.0)
<span style="color: #0000FF;">print</span>(1.0 / 3.1)
</pre>
</div>

<p>
Now, consider the integer versions:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(4 / 2)
<span style="color: #0000FF;">print</span>(1 / 3)
</pre>
</div>

<p>
In Python3 division now is automatically float division. You can do integer division with the // operator like this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(4 // 2)
<span style="color: #0000FF;">print</span>(1 // 3)
</pre>
</div>

<p>
Exponentiation is also a basic math operation that python supports directly.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(3.**2)
<span style="color: #0000FF;">print</span>(3**2)
<span style="color: #0000FF;">print</span>(2**0.5)
</pre>
</div>

<p>
Other types of mathematical operations require us to import functionality from python libraries. We consider those in the next section.
</p>
</div>
</div>

<div id="outline-container-orga6b8075" class="outline-3">
<h3 id="orga6b8075"><span class="section-number-3">2.2.</span> Advanced mathematical operators</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The primary library we will consider is mod:numpy, which provides many mathematical functions, statistics as well as support for linear algebra. For a complete listing of the functions available, see <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">http://docs.scipy.org/doc/numpy/reference/routines.math.html</a>. We begin with the simplest functions.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.sqrt(2))
</pre>
</div>
</div>

<div id="outline-container-orgf82843e" class="outline-4">
<h4 id="orgf82843e"><span class="section-number-4">2.2.1.</span> Exponential and logarithmic functions</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Here is the exponential function.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.exp(1))
</pre>
</div>

<p>
There are two logarithmic functions commonly used, the natural log function func:numpy.log and the base10 logarithm func:numpy.log10.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.log(10))
<span style="color: #0000FF;">print</span>(np.log10(10))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">base10</span>
</pre>
</div>

<p>
There are many other intrinsic functions available in mod:numpy which we will eventually cover. First, we need to consider how to create our own functions.
</p>
</div>
</div>
</div>
<div id="outline-container-org1d34780" class="outline-3">
<h3 id="org1d34780"><span class="section-number-3">2.3.</span> Creating your own functions</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We can combine operations to evaluate complex equations. Consider the value of the equation \(x^3 - \log(x)\) for the value \(x=4.1\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">x</span> = 3
<span style="color: #0000FF;">print</span>(x**3 - np.log(x))
</pre>
</div>

<p>
It would be tedious to type this out each time. Next, we learn how to express this equation as a new function, which we can call with different values.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x**3 - np.log(x)

<span style="color: #0000FF;">print</span>(f(3))
<span style="color: #0000FF;">print</span>(f(5.1))
</pre>
</div>

<p>
It may not seem like we did much there, but this is the foundation for solving equations in the future. Before we get to solving equations, we have a few more details to consider. Next, we consider evaluating functions on arrays of values.
</p>
</div>
</div>
<div id="outline-container-org2c7f0a1" class="outline-3">
<h3 id="org2c7f0a1"><span class="section-number-3">2.4.</span> Defining functions in python</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Compare what's here to the <a href="http://matlab.cheme.cmu.edu/2011/08/09/where-its-i-got-two-turntables-and-a-microphone/">Matlab implementation. </a>
</p>

<p>
We often need to make functions in our codes to do things.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"return the inverse square of x"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1.0 / x**2

<span style="color: #0000FF;">print</span>(f(3))
<span style="color: #0000FF;">print</span>(f([4,5]))
</pre>
</div>

<p>
Note that functions are not automatically vectorized. That is why we see the error above. There are a few ways to achieve that. One is to "cast" the input variables to objects that support vectorized operations, such as numpy.array objects.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"return the inverse square of x"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = np.array(x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1.0 / x**2

<span style="color: #0000FF;">print</span>(f(3))
<span style="color: #0000FF;">print</span>(f([4,5]))
</pre>
</div>

<p>
It is possible to have more than one variable.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(x, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"return product of x and y"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x * y

<span style="color: #0000FF;">print</span>(func(2, 3))
<span style="color: #0000FF;">print</span>(func(np.array([2, 3]), np.array([3, 4])))
</pre>
</div>

<p>
You can define "lambda" functions, which are also known as inline or anonymous functions. The syntax is <code>lambda var:f(var)</code>. I think these are hard to read and discourage their use. Here is a typical usage where you have to define a simple function that is passed to another function, e.g. scipy.integrate.quad to perform an integral.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad
<span style="color: #0000FF;">print</span>(quad(<span style="color: #0000FF;">lambda</span> x:x**3, 0 ,2))
</pre>
</div>

<p>
It is possible to nest functions inside of functions like this.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">wrapper</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a</span> = 4
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(x, a):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> a * x

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> func(x, a)

<span style="color: #0000FF;">print</span>(wrapper(4))
</pre>
</div>

<p>
An alternative approach is to "wrap" a function, say to fix a parameter. You might do this so you can integrate the wrapped function, which depends on only a single variable, whereas the original function depends on two variables.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(x, a):
        <span style="color: #0000FF;">return</span> a * x

<span style="color: #0000FF;">def</span> <span style="color: #006699;">wrapper</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a</span> = 4
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> func(x, a)

<span style="color: #0000FF;">print</span>(wrapper(4))
</pre>
</div>

<p>
Last example, defining a function for an ode
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">k</span> = 2.2
<span style="color: #0000FF;">def</span> <span style="color: #006699;">myode</span>(y, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"ode defining exponential growth"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> k * y

<span style="color: #BA36A5;">y0</span> = 3
<span style="color: #BA36A5;">tspan</span> = np.linspace(0,1)
<span style="color: #BA36A5;">y</span> =  odeint(myode, y0, tspan)

plt.plot(tspan, y)
plt.xlabel(<span style="color: #008000;">'Time'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.savefig(<span style="color: #008000;">'images/funcs-ode.png'</span>)
</pre>
</div>


<div id="org53f133a" class="figure">
<p><img src="pycse-chapters/images/funcs-ode.png" alt="funcs-ode.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org859d6bd" class="outline-3">
<h3 id="org859d6bd"><span class="section-number-3">2.5.</span> Advanced function creation</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Python has some nice features in creating functions. You can create default values for variables, have optional variables and optional keyword variables.
In this function f(a,b), <code>a</code> and <code>b</code> are called positional arguments, and they are required, and must be provided in the same order as the function defines.
</p>

<p>
If we provide a default value for an argument, then the argument is called a keyword argument, and it becomes optional. You can combine positional arguments and keyword arguments, but positional arguments must come first. Here is an example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(a, n=2):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"compute the nth power of a"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> a**n

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">three different ways to call the function</span>
<span style="color: #0000FF;">print</span>(func(2))
<span style="color: #0000FF;">print</span>(func(2, 3))
<span style="color: #0000FF;">print</span>(func(2, n=4))
</pre>
</div>

<p>
In the first call to the function, we only define the argument <code>a</code>, which is a mandatory, positional argument. In the second call, we define <code>a</code> and <code>n</code>, in the order they are defined in the function. Finally, in the third call, we define <code>a</code> as a positional argument, and <code>n</code> as a keyword argument.
</p>

<p>
If all of the arguments are optional, we can even call the function with no arguments. If you give arguments as positional arguments, they are used in the order defined in the function. If you use keyword arguments, the order is arbitrary.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(a=1, n=2):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"compute the nth power of a"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> a**n

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">three different ways to call the function</span>
<span style="color: #0000FF;">print</span>(func())
<span style="color: #0000FF;">print</span>(func(2, 4))
<span style="color: #0000FF;">print</span>(func(n=4, a=2))
</pre>
</div>

<p>
It is occasionally useful to allow an arbitrary number of arguments in a function. Suppose we want a function that can take an arbitrary number of positional arguments and return the sum of all the arguments. We use the syntax <code>*args</code> to indicate arbitrary positional arguments. Inside the function the variable <code>args</code> is a tuple containing all of the arguments passed to the function.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(*args):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #006FE0;">sum</span> = 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> arg <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">args</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #006FE0;">sum</span> += arg
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #006FE0;">sum</span>

<span style="color: #0000FF;">print</span>(func(1, 2, 3, 4))
</pre>
</div>

<p>
A more "functional programming" version of the last function is given here. This is an advanced approach that is less readable to new users, but more compact and likely more efficient for large numbers of arguments.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> functools, operator
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(*args):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> functools.<span style="color: #006FE0;">reduce</span>(operator.add, args)
<span style="color: #0000FF;">print</span>(func(1, 2, 3, 4))
</pre>
</div>

<p>
It is possible to have arbitrary keyword arguments. This is a common pattern when you call another function within your function that takes keyword arguments. We use <code>**kwargs</code> to indicate that arbitrary keyword arguments can be given to the function. Inside the function, kwargs is variable containing a dictionary of the keywords and values passed in.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(**kwargs):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> kw <span style="color: #0000FF;">in</span> kwargs:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0} = {1}'</span>.<span style="color: #006FE0;">format</span>(kw, kwargs[kw]))

func(t1=6, color=<span style="color: #008000;">'blue'</span>)
</pre>
</div>

<p>
A typical example might be:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">myplot</span>(x, y, fname=<span style="color: #D0372D;">None</span>, **kwargs):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"make plot of x,y. save to fname if not None. Provide kwargs to plot."</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(x, y, **kwargs)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.xlabel(<span style="color: #008000;">'X'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.ylabel(<span style="color: #008000;">'Y'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.title(<span style="color: #008000;">'My plot'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> fname:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.savefig(fname)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.show()

x = [1, 3, 4, 5]
y = [3, 6, 9, 12]

myplot(x, y, <span style="color: #008000;">'images/myfig.png'</span>, color=<span style="color: #008000;">'orange'</span>, marker=<span style="color: #008000;">'s'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">you can use a dictionary as kwargs</span>
d = {<span style="color: #008000;">'color'</span>:<span style="color: #008000;">'magenta'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">'marker'</span>:<span style="color: #008000;">'d'</span>}

myplot(x, y, <span style="color: #008000;">'images/myfig2.png'</span>, **d)
</pre>
</div>

<p>
<img src="pycse-chapters/images/myfig.png" alt="myfig.png" />
<img src="pycse-chapters/images/myfig2.png" alt="myfig2.png" />
</p>

<p>
In that example we wrap the matplotlib plotting commands in a function, which we can call the way we want to, with arbitrary optional arguments. In this example, you cannot pass keyword arguments that are illegal to the plot command or you will get an error.
</p>

<p>
It is possible to combine all the options at once. I admit it is hard to imagine where this would be really useful, but it can be done!
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(a, b=2, *args, **kwargs):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"return a**b + sum(args) and print kwargs"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> kw <span style="color: #0000FF;">in</span> kwargs:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'kw: {0} = {1}'</span>.<span style="color: #006FE0;">format</span>(kw, kwargs[kw]))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> a**b + np.<span style="color: #006FE0;">sum</span>(args)

<span style="color: #0000FF;">print</span>(func(2, 3, 4, 5, mysillykw=<span style="color: #008000;">'hahah'</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3343f1" class="outline-3">
<h3 id="orge3343f1"><span class="section-number-3">2.6.</span> Lambda Lambda Lambda</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Is that some kind of fraternity? of anonymous functions? What is that!? There are many times where you need a callable, small function in python, and it is inconvenient to have to use <code>def</code> to create a named function. Lambda functions solve this problem. Let us look at some examples. First, we create a lambda function, and assign it to a variable. Then we show that variable is a function, and that we can call it with an argument.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">f</span> = <span style="color: #0000FF;">lambda</span> x: 2*x
<span style="color: #0000FF;">print</span>(f)
<span style="color: #0000FF;">print</span>(f(2))
</pre>
</div>

<p>
We can have more than one argument:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">f</span> = <span style="color: #0000FF;">lambda</span> x,y: x + y
<span style="color: #0000FF;">print</span>(f)
<span style="color: #0000FF;">print</span>(f(2, 3))
</pre>
</div>

<p>
And default arguments:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">f</span> = <span style="color: #0000FF;">lambda</span> <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span>=3: x + y
<span style="color: #0000FF;">print</span>(f)
<span style="color: #0000FF;">print</span>(f(2))
<span style="color: #0000FF;">print</span>(f(4, 1))
</pre>
</div>

<p>
It is also possible to have arbitrary numbers of positional arguments. Here is an example that provides the sum of an arbitrary number of arguments.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> functools, operator
<span style="color: #BA36A5;">f</span> = <span style="color: #0000FF;">lambda</span> *x: functools.<span style="color: #006FE0;">reduce</span>(operator.add, x)
<span style="color: #0000FF;">print</span>(f)

<span style="color: #0000FF;">print</span>(f(1))
<span style="color: #0000FF;">print</span>(f(1, 2))
<span style="color: #0000FF;">print</span>(f(1, 2, 3))
</pre>
</div>

<p>
You can also make arbitrary keyword arguments. Here we make a function that simply returns the kwargs as a dictionary. This feature may be helpful in passing kwargs to other functions.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">f</span> = <span style="color: #0000FF;">lambda</span> **kwargs: kwargs

<span style="color: #0000FF;">print</span>(f(a=1, b=3))
</pre>
</div>

<p>
Of course, you can combine these options. Here is a function with all the options.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">f</span> = <span style="color: #0000FF;">lambda</span> <span style="color: #BA36A5;">a</span>, <span style="color: #BA36A5;">b</span>=4, *args, **kwargs: (a, b, args, kwargs)

<span style="color: #0000FF;">print</span>(f(<span style="color: #008000;">'required'</span>, 3, <span style="color: #008000;">'optional-positional'</span>, g=4))
</pre>
</div>

<p>
One of the primary limitations of lambda functions is they are limited to single expressions. They also do not have documentation strings, so it can be difficult to understand what they were written for later.
</p>
</div>

<div id="outline-container-org20604da" class="outline-4">
<h4 id="org20604da"><span class="section-number-4">2.6.1.</span> Applications of lambda functions</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Lambda functions are used in places where you need a function, but may not want to define one using <code>def</code>. For example, say you want to solve the nonlinear equation \(\sqrt{x} = 2.5\).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">sol</span>, = fsolve(<span style="color: #0000FF;">lambda</span> x: 2.5 - np.sqrt(x), 8)
<span style="color: #0000FF;">print</span>(sol)
</pre>
</div>

<p>
Another time to use lambda functions is if you want to set a particular value of a parameter in a function. Say we have a function with an independent variable, \(x\) and a parameter \(a\), i.e. \(f(x; a)\). If we want to find a solution \(f(x; a) = 0\) for some value of \(a\), we can use a lambda function to make a function of the single variable \(x\). Here is a example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(x, a):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> a * np.sqrt(x) - 4.0

<span style="color: #BA36A5;">sol</span>, = fsolve(<span style="color: #0000FF;">lambda</span> x: func(x, 3.2), 3)
<span style="color: #0000FF;">print</span>(sol)
</pre>
</div>


<p>
Any function that takes a function as an argument can use lambda functions. Here we use a lambda function that adds two numbers in the <code>reduce</code> function to sum a list of numbers.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> functools <span style="color: #0000FF;">as</span> ft
<span style="color: #0000FF;">print</span>(ft.<span style="color: #006FE0;">reduce</span>(<span style="color: #0000FF;">lambda</span> x, y: x + y, [0, 1, 2, 3, 4]))
</pre>
</div>

<p>
We can evaluate the integral \(\int_0^2 x^2 dx\) with a lambda function.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #0000FF;">print</span>(quad(<span style="color: #0000FF;">lambda</span> x: x**2, 0, 2))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6f08cd6" class="outline-4">
<h4 id="org6f08cd6"><span class="section-number-4">2.6.2.</span> Summary</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
Lambda functions can be helpful. They are never necessary. You can always define a function using <code>def</code>, but for some small, single-use functions, a lambda function could make sense. Lambda functions have some limitations, including that they are limited to a single expression, and they lack documentation strings.
</p>
</div>
</div>
</div>

<div id="outline-container-org8a57cd3" class="outline-3">
<h3 id="org8a57cd3"><span class="section-number-3">2.7.</span> Creating arrays in python</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Often, we will have a set of 1-D arrays, and we would like to construct a 2D array with those vectors as either the rows or columns of the array. This may happen because we have data from different sources we want to combine, or because we organize the code with variables that are easy to read, and then want to combine the variables. Here are examples of doing that to get the vectors as the columns.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">a</span> = np.array([1, 2, 3])
<span style="color: #BA36A5;">b</span> = np.array([4, 5, 6])

<span style="color: #0000FF;">print</span>(np.column_stack([a, b]))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this means stack the arrays vertically, e.g. on top of each other</span>
<span style="color: #0000FF;">print</span>(np.vstack([a, b]).T)
</pre>
</div>

<p>
Or rows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">a</span> = np.array([1, 2, 3])
<span style="color: #BA36A5;">b</span> = np.array([4, 5, 6])

<span style="color: #0000FF;">print</span>(np.row_stack([a, b]))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this means stack the arrays vertically, e.g. on top of each other</span>
<span style="color: #0000FF;">print</span>(np.vstack([a, b]))
</pre>
</div>

<p>
The opposite operation is to extract the rows or columns of a 2D array into smaller arrays. We might want to do that to extract a row or column from a calculation for further analysis, or plotting for example. There are splitting functions in numpy. They are somewhat confusing, so we examine some examples. The numpy.hsplit command splits an array "horizontally". The best way to think about it is that the "splits" move horizontally across the array. In other words, you draw a vertical split, move over horizontally, draw another vertical split, etc&#x2026; You must specify the number of splits that you want, and the array must be evenly divisible by the number of splits.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[1, 2, 3, 5],
              [4, 5, 6, 9]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">split into two parts</span>
<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span> = np.hsplit(A, 2)
<span style="color: #0000FF;">print</span>(p1)
<span style="color: #0000FF;">print</span>(p2)

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">split into 4 parts</span>
<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>, <span style="color: #BA36A5;">p3</span>, <span style="color: #BA36A5;">p4</span> = np.hsplit(A, 4)
<span style="color: #0000FF;">print</span>(p1)
<span style="color: #0000FF;">print</span>(p2)
<span style="color: #0000FF;">print</span>(p3)
<span style="color: #0000FF;">print</span>(p4)
</pre>
</div>

<p>
In the numpy.vsplit command the "splits" go "vertically" down the array. Note that the split commands return 2D arrays.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[1, 2, 3, 5],
              [4, 5, 6, 9]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">split into two parts</span>
<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span> = np.vsplit(A, 2)
<span style="color: #0000FF;">print</span>(p1)
<span style="color: #0000FF;">print</span>(p2)
<span style="color: #0000FF;">print</span>(p2.shape)
</pre>
</div>

<p>
An alternative approach is array unpacking. In this example, we unpack the array into two variables. The array unpacks by row.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[1, 2, 3, 5],
              [4, 5, 6, 9]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">split into two parts</span>
<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span> = A
<span style="color: #0000FF;">print</span>(p1)
<span style="color: #0000FF;">print</span>(p2)
</pre>
</div>

<p>
To get the columns, just transpose the array.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[1, 2, 3, 5],
              [4, 5, 6, 9]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">split into two parts</span>
<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>, <span style="color: #BA36A5;">p3</span>, <span style="color: #BA36A5;">p4</span> = A.T
<span style="color: #0000FF;">print</span>(p1)
<span style="color: #0000FF;">print</span>(p2)
<span style="color: #0000FF;">print</span>(p3)
<span style="color: #0000FF;">print</span>(p4)
<span style="color: #0000FF;">print</span>(p4.shape)
</pre>
</div>

<p>
Note that now, we have 1D arrays.
</p>

<p>
You can also access rows and columns by indexing. We index an array by [row, column]. To get a row, we specify the row number, and all the columns in that row like this [row, :]. Similarly, to get a column, we specify that we want all rows in that column like this: [:, column]. This approach is useful when you only want a few columns or rows.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[1, 2, 3, 5],
              [4, 5, 6, 9]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">get row 1</span>
<span style="color: #0000FF;">print</span>(A[1])
<span style="color: #0000FF;">print</span>(A[1, :])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">row 1, all columns</span>

<span style="color: #0000FF;">print</span>(A[:, 2])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">get third column</span>
<span style="color: #0000FF;">print</span>(A[:, 2].shape)
</pre>
</div>

<p>
Note that even when we specify a column, it is returned as a 1D array.
</p>
</div>
</div>
<div id="outline-container-org4b9b03e" class="outline-3">
<h3 id="org4b9b03e"><span class="section-number-3">2.8.</span> Functions on arrays of values</h3>
<div class="outline-text-3" id="text-2-8">
<p>
It is common to evaluate a function for a range of values. Let us consider the value of the function \(f(x) = \cos(x)\) over the range of \(0 < x < \pi\). We cannot consider every value in that range, but we can consider say 10 points in the range. The func:numpy.linspace conveniently creates an array of values.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.linspace(0, np.pi, 10))
</pre>
</div>

<p>
The main point of using the mod:numpy functions is that they work element-wise on elements of an array. In this example, we compute the \(\cos(x)\) for each element of \(x\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">x</span> = np.linspace(0, np.pi, 10)
<span style="color: #0000FF;">print</span>(np.cos(x))
</pre>
</div>

<p>
You can already see from this output that there is a root to the equation \(\cos(x) = 0\), because there is a change in sign in the output. This is not a very convenient way to view the results; a graph would be better.  We use mod:matplotlib to make figures. Here is an example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x</span> = np.linspace(0, np.pi, 10)
plt.plot(x, np.cos(x))
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'cos(x)'</span>)
plt.savefig(<span style="color: #008000;">'images/plot-cos.png'</span>)
</pre>
</div>


<div id="org58120d3" class="figure">
<p><img src="pycse-chapters/images/plot-cos.png" alt="plot-cos.png" />
</p>
</div>

<p>
This figure illustrates graphically what the numbers above show. The function crosses zero at approximately \(x = 1.5\). To get a more precise value, we must actually solve the function numerically. We use the function func:scipy.optimize.fsolve to do that. More precisely, we want to solve the equation \(f(x) = \cos(x) = 0\). We create a function that defines that equation, and then use func:scipy.optimize.fsolve to solve it.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.cos(x)

<span style="color: #BA36A5;">sol</span>, = fsolve(f, x0=1.5) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the comma after sol makes it return a float</span>
<span style="color: #0000FF;">print</span>(sol)
<span style="color: #0000FF;">print</span>(np.pi / 2)
</pre>
</div>

<p>
We know the solution is &pi;/2.
</p>
</div>
</div>
<div id="outline-container-orge6344d5" class="outline-3">
<h3 id="orge6344d5"><span class="section-number-3">2.9.</span> Some basic data structures in python</h3>
<div class="outline-text-3" id="text-2-9">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/26/some-basic-data-structures-in-matlab/">Matlab post</a>
</p>

<p>
We often have a need to organize data into structures when solving problems.
</p>
</div>
<div id="outline-container-org476ae2b" class="outline-4">
<h4 id="org476ae2b"><span class="section-number-4">2.9.1.</span> the list</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
A list in python is data separated by commas in square brackets. Here, we might store the following data in a variable to describe the Antoine coefficients for benzene and the range they are relevant for [Tmin Tmax]. Lists are flexible, you can put anything in them, including other lists. We access the elements of the list by indexing:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">c</span> = [<span style="color: #008000;">'benzene'</span>, 6.9056, 1211.0, 220.79, [-16, 104]]
<span style="color: #0000FF;">print</span>(c[0])
<span style="color: #0000FF;">print</span>(c[-1])

<span style="color: #BA36A5;">a</span>,<span style="color: #BA36A5;">b</span> = c[0:2]
<span style="color: #0000FF;">print</span>(a,b)

<span style="color: #BA36A5;">name</span>, <span style="color: #BA36A5;">A</span>, <span style="color: #BA36A5;">B</span>, <span style="color: #BA36A5;">C</span>, <span style="color: #BA36A5;">Trange</span> = c
<span style="color: #0000FF;">print</span>(Trange)
</pre>
</div>

<p>
Lists are "mutable", which means you can change their values.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [3, 4, 5, [7, 8], <span style="color: #008000;">'cat'</span>]
<span style="color: #0000FF;">print</span>(a[0], a[-1])
<span style="color: #BA36A5;">a</span>[-1] = <span style="color: #008000;">'dog'</span>
<span style="color: #0000FF;">print</span>(a)
</pre>
</div>
</div>
</div>

<div id="outline-container-org81eb598" class="outline-4">
<h4 id="org81eb598"><span class="section-number-4">2.9.2.</span> tuples</h4>
<div class="outline-text-4" id="text-2-9-2">
<p>
Tuples are <i>immutable</i>; you cannot change their values. This is handy in cases where it is an error to change the value. A tuple is like a list but it is enclosed in parentheses.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = (3, 4, 5, [7, 8], <span style="color: #008000;">'cat'</span>)
<span style="color: #0000FF;">print</span>(a[0], a[-1])
<span style="color: #BA36A5;">a</span>[-1] = <span style="color: #008000;">'dog'</span>  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is an error</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org116bec7" class="outline-4">
<h4 id="org116bec7"><span class="section-number-4">2.9.3.</span> struct</h4>
<div class="outline-text-4" id="text-2-9-3">
<p>
Python does not exactly have the same thing as a struct in Matlab. You can achieve something like it by defining an empty class and then defining attributes of the class. You can check if an object has a particular attribute using hasattr.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Antoine</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">pass</span>

a = Antoine()
a.<span style="color: #BA36A5;">name</span> = <span style="color: #008000;">'benzene'</span>
a.<span style="color: #BA36A5;">Trange</span> = [-16, 104]

<span style="color: #0000FF;">print</span>(a.name)
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">hasattr</span>(a, <span style="color: #008000;">'Trange'</span>))
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">hasattr</span>(a, <span style="color: #008000;">'A'</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org94f342f" class="outline-4">
<h4 id="org94f342f"><span class="section-number-4">2.9.4.</span> dictionaries</h4>
<div class="outline-text-4" id="text-2-9-4">
<p>
The analog of the containers.Map in Matlab is the dictionary in python. Dictionaries are enclosed in curly brackets, and are composed of key:value pairs.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">s</span> = {<span style="color: #008000;">'name'</span>:<span style="color: #008000;">'benzene'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">'A'</span>:6.9056,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">'B'</span>:1211.0}

<span style="color: #BA36A5;">s</span>[<span style="color: #008000;">'C'</span>] = 220.79
<span style="color: #BA36A5;">s</span>[<span style="color: #008000;">'Trange'</span>] = [-16, 104]

<span style="color: #0000FF;">print</span>(s)
<span style="color: #0000FF;">print</span>(s[<span style="color: #008000;">'Trange'</span>])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">s</span> = {<span style="color: #008000;">'name'</span>:<span style="color: #008000;">'benzene'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">'A'</span>:6.9056,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">'B'</span>:1211.0}

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'C'</span> <span style="color: #0000FF;">in</span> s)
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">default value for keys not in the dictionary</span>
<span style="color: #0000FF;">print</span>(s.get(<span style="color: #008000;">'C'</span>, <span style="color: #D0372D;">None</span>))

<span style="color: #0000FF;">print</span>(s.keys())
<span style="color: #0000FF;">print</span>(s.values())
</pre>
</div>
</div>
</div>


<div id="outline-container-orge43b407" class="outline-4">
<h4 id="orge43b407"><span class="section-number-4">2.9.5.</span> Summary</h4>
<div class="outline-text-4" id="text-2-9-5">
<p>
We have examined four data structures in python. Note that none of these types are arrays/vectors with defined mathematical operations. For those, you need to consider numpy.array.
</p>
</div>
</div>
</div>
<div id="outline-container-org8d72c89" class="outline-3">
<h3 id="org8d72c89"><span class="section-number-3">2.10.</span> Indexing vectors and arrays in Python</h3>
<div class="outline-text-3" id="text-2-10">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/24/indexing-vectors-and-arrays-in-matlab/">Matlab post</a>
There are times where you have a lot of data in a vector or array and you want to extract a portion of the data for some analysis. For example, maybe you want to plot column 1 vs column 2, or you want the integral of data between x = 4 and x = 6, but your vector covers 0 &lt; x &lt; 10. Indexing is the way to do these things.
</p>

<p>
A key point to remember is that in python array/vector indices start at 0. Unlike Matlab, which uses parentheses to index a array, we use brackets in python.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x</span> = np.linspace(-np.pi, np.pi, 10)
<span style="color: #0000FF;">print</span>(x)

<span style="color: #0000FF;">print</span>(x[0])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">first element</span>
<span style="color: #0000FF;">print</span>(x[2])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">third element</span>
<span style="color: #0000FF;">print</span>(x[-1]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">last element</span>
<span style="color: #0000FF;">print</span>(x[-2]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">second to last element</span>
</pre>
</div>

<p>
We can select a range of elements too. The syntax a:b extracts the a^{th} to (b-1)^{th} elements. The syntax a:b:n starts at a, skips nelements up to the index b.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(x[1: 4])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">second to fourth element. Element 5 is not included</span>
<span style="color: #0000FF;">print</span>(x[0: -1:2])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">every other element</span>
<span style="color: #0000FF;">print</span>(x[:])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print the whole vector</span>
<span style="color: #0000FF;">print</span>(x[-1:0:-1])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reverse the vector!</span>
</pre>
</div>

<p>
Suppose we want the part of the vector where x &gt; 2. We could do that by inspection, but there is a better way. We can create a mask of boolean (0 or 1) values that specify whether x &gt; 2 or not, and then use the mask as an index.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(x[x &gt; 2])
</pre>
</div>

<p>
You can use this to analyze subsections of data, for example to integrate the function y = sin(x) where x &gt; 2.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">y</span> = np.sin(x)

<span style="color: #0000FF;">print</span>(np.trapz( x[x &gt; 2], y[x &gt; 2]))
</pre>
</div>
</div>

<div id="outline-container-orgf742d51" class="outline-4">
<h4 id="orgf742d51"><span class="section-number-4">2.10.1.</span> 2d arrays</h4>
<div class="outline-text-4" id="text-2-10-1">
<p>
In 2d arrays, we use  row, column notation. We use a : to indicate all rows or all columns.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

<span style="color: #0000FF;">print</span>(a[0, 0])
<span style="color: #0000FF;">print</span>(a[-1, -1])

<span style="color: #0000FF;">print</span>(a[0, :] )<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">row one</span>
<span style="color: #0000FF;">print</span>(a[:, 0] )<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">column one</span>
<span style="color: #0000FF;">print</span>(a[:])
</pre>
</div>
</div>
</div>

<div id="outline-container-org1e1cb91" class="outline-4">
<h4 id="org1e1cb91"><span class="section-number-4">2.10.2.</span> Using indexing to assign values to rows and columns</h4>
<div class="outline-text-4" id="text-2-10-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">b</span> = np.zeros((3, 3))
<span style="color: #0000FF;">print</span>(b)

<span style="color: #BA36A5;">b</span>[:, 0] = [1, 2, 3] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">set column 0</span>
<span style="color: #BA36A5;">b</span>[2, 2] = 12        <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">set a single element</span>
<span style="color: #0000FF;">print</span>(b)

<span style="color: #BA36A5;">b</span>[2] = 6  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">sets everything in row 2 to 6!</span>
<span style="color: #0000FF;">print</span>(b)
</pre>
</div>

<p>
Python does not have the linear assignment method like Matlab does. You can achieve something like that as follows. We flatten the array to 1D, do the linear assignment, and reshape the result back to the 2D array.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">c</span> = b.flatten()
<span style="color: #BA36A5;">c</span>[2] = 34
<span style="color: #BA36A5;">b</span>[:] = c.reshape(b.shape)
<span style="color: #0000FF;">print</span>(b)
</pre>
</div>
</div>
</div>

<div id="outline-container-org955c9a6" class="outline-4">
<h4 id="org955c9a6"><span class="section-number-4">2.10.3.</span> 3D arrays</h4>
<div class="outline-text-4" id="text-2-10-3">
<p>
The 3d array is like book of 2D matrices. Each page has a 2D matrix on it. think about the indexing like this: (row, column, page)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">M</span> = np.random.uniform(size=(3,3,3))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">a 3x3x3 array</span>
<span style="color: #0000FF;">print</span>(M)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(M[:, :, 0])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">2d array on page 0</span>
<span style="color: #0000FF;">print</span>(M[:, 0, 0])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">column 0 on page 0</span>
<span style="color: #0000FF;">print</span>(M[1, :, 2])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">row 1 on page 2</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org854b5ca" class="outline-4">
<h4 id="org854b5ca"><span class="section-number-4">2.10.4.</span> Summary</h4>
<div class="outline-text-4" id="text-2-10-4">
<p>
The most common place to use indexing is probably when a function returns an array with the independent variable in column 1 and solution in column 2, and you want to plot the solution. Second is when you want to analyze one part of the solution. There are also applications in numerical methods, for example in assigning values to the elements of a matrix or vector.
</p>
</div>
</div>
</div>
<div id="outline-container-org2b09273" class="outline-3">
<h3 id="org2b09273"><span class="section-number-3">2.11.</span> Controlling the format of printed variables</h3>
<div class="outline-text-3" id="text-2-11">
<p>
This was first worked out in this <a href="http://matlab.cheme.cmu.edu/2011/10/06/sprintfing-to-the-finish/">original Matlab post</a>.
</p>

<p>
Often you will want to control the way a variable is printed. You may want to only show a few decimal places, or print in scientific notation, or embed the result in a string. Here are some examples of printing with no control over the format.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = 2./3
<span style="color: #0000FF;">print</span>(a)
<span style="color: #0000FF;">print</span>(1/3)
<span style="color: #0000FF;">print</span>(1./3.)
<span style="color: #0000FF;">print</span>(10.1)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">"Avogadro's number is "</span>, 6.022e23,<span style="color: #008000;">'.'</span>)
</pre>
</div>

<p>
There is no control over the number of decimals, or spaces around a printed number.
</p>

<p>
In python, we use the format function to control how variables are printed. With the format function you use codes like {<i>n</i>:format specifier} to indicate that a formatted string should be used. <i>n</i> is the <i>n^{th}</i> argument passed to format, and there are a variety of format specifiers. Here we examine how to format float numbers. The specifier has the general form "w.df" where w is the width of the field, and d is the number of decimals, and f indicates a float number. "1.3f" means to print a float number with 3 decimal places. Here is an example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The value of 1/3 to 3 decimal places is {0:1.3f}'</span>.<span style="color: #006FE0;">format</span>(1./3.))
</pre>
</div>

<p>
In that example, the 0 in {0:1.3f} refers to the first (and only) argument to the format function. If there is more than one argument, we can refer to them like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Value 0 = {0:1.3f}, value 1 = {1:1.3f}, value 0 = {0:1.3f}'</span>.<span style="color: #006FE0;">format</span>(1./3., 1./6.))
</pre>
</div>

<p>
Note you can refer to the same argument more than once, and in arbitrary order within the string.
</p>

<p>
Suppose you have a list of numbers you want to print out, like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> [1./3., 1./6., 1./9.]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The answer is {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(x))
</pre>
</div>

<p>
The "g" format specifier is a general format that can be used to indicate a precision, or to indicate significant digits. To print a number with a specific number of significant digits we do this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.3g}'</span>.<span style="color: #006FE0;">format</span>(1./3.))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.3g}'</span>.<span style="color: #006FE0;">format</span>(4./3.))
</pre>
</div>

<p>
We can also specify plus or minus signs. Compare the next two outputs.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> [-1., 1.]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(x))
</pre>
</div>

<p>
You can see the decimals do not align. That is because there is a minus sign in front of one number. We can specify to show the sign for positive and negative numbers, or to pad positive numbers to leave space for positive numbers.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> [-1., 1.]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:+1.2f}'</span>.<span style="color: #006FE0;">format</span>(x)) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">explicit sign</span>

<span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> [-1., 1.]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0: 1.2f}'</span>.<span style="color: #006FE0;">format</span>(x)) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">pad positive numbers</span>
</pre>
</div>

<p>
We use the "e" or "E" format modifier to specify scientific notation.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">eps</span> = np.finfo(np.double).eps
<span style="color: #0000FF;">print</span>(eps)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0}'</span>.<span style="color: #006FE0;">format</span>(eps))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(eps))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.2e}'</span>.<span style="color: #006FE0;">format</span>(eps))  <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">exponential notation</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.2E}'</span>.<span style="color: #006FE0;">format</span>(eps))  <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">exponential notation with capital E</span>
</pre>
</div>

<p>
As a float with 2 decimal places, that very small number is practically equal to 0.
</p>

<p>
We can even format percentages. Note you do not need to put the % in your string.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(<span style="color: #008000;">'the fraction {0} corresponds to {0:1.0%}'</span>.<span style="color: #006FE0;">format</span>(0.78))
</pre>
</div>

<p>
There are many other options for formatting strings. See <a href="http://docs.python.org/2/library/string.html#formatstrings">http://docs.python.org/2/library/string.html#formatstrings</a> for a full specification of the options.
</p>
</div>
</div>

<div id="outline-container-org5876a0b" class="outline-3">
<h3 id="org5876a0b"><span class="section-number-3">2.12.</span> Advanced string formatting</h3>
<div class="outline-text-3" id="text-2-12">
<p>
There are several more advanced ways to include formatted values in a string. In the previous case we examined replacing format specifiers by <i>positional</i> arguments in the format command. We can instead use <i>keyword</i> arguments.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">s</span> = <span style="color: #008000;">'The {speed} {color} fox'</span>.<span style="color: #006FE0;">format</span>(color=<span style="color: #008000;">'brown'</span>, speed=<span style="color: #008000;">'quick'</span>)
<span style="color: #0000FF;">print</span>(s)
</pre>
</div>

<p>
If you have a lot of variables already defined in a script, it is convenient to use them in string formatting with the locals command:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">speed</span> = <span style="color: #008000;">'slow'</span>
<span style="color: #BA36A5;">color</span>= <span style="color: #008000;">'blue'</span>

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The {speed} {color} fox'</span>.<span style="color: #006FE0;">format</span>(**<span style="color: #006FE0;">locals</span>()))
</pre>
</div>

<p>
If you want to access attributes on an object, you can specify them directly in the format identifier.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">A</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, a, b, c):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.a = a
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.<span style="color: #BA36A5;">b</span> = b
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.<span style="color: #BA36A5;">c</span> = c

<span style="color: #BA36A5;">mya</span> = A(3,4,5)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'a = {obj.a}, b = {obj.b}, c = {obj.c:1.2f}'</span>.<span style="color: #006FE0;">format</span>(obj=mya))
</pre>
</div>

<p>
You can access values of a dictionary:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">d</span> = {<span style="color: #008000;">'a'</span>: 56, <span style="color: #008000;">"test"</span>:<span style="color: #008000;">'woohoo!'</span>}

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">"the value of a in the dictionary is {obj[a]}. It works {obj[test]}"</span>.<span style="color: #006FE0;">format</span>(obj=d))
</pre>
</div>

<p>
And, you can access elements of a list. Note, however you cannot use -1 as an index in this case.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">L</span> = [4, 5, <span style="color: #008000;">'cat'</span>]

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'element 0 = {obj[0]}, and the last element is {obj[2]}'</span>.<span style="color: #006FE0;">format</span>(obj=L))
</pre>
</div>

<p>
There are three different ways to "print" an object. If an object has a <span class="underline"><span class="underline">format</span></span> function, that is the default used in the format command. It may be helpful to use the <code>str</code> or <code>repr</code> of an object instead. We get this with !s for <code>str</code> and !r for <code>repr</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">A</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, a, b):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.a = a; <span style="color: #0000FF;">self</span>.<span style="color: #BA36A5;">b</span> = b

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__format__</span>(<span style="color: #0000FF;">self</span>, <span style="color: #006FE0;">format</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">s</span> = <span style="color: #008000;">'a={{0:{0}}} b={{1:{0}}}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">format</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> s.<span style="color: #006FE0;">format</span>(<span style="color: #0000FF;">self</span>.a, <span style="color: #0000FF;">self</span>.b)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__str__</span>(<span style="color: #0000FF;">self</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">'str: class A, a={0} b={1}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #0000FF;">self</span>.a, <span style="color: #0000FF;">self</span>.b)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__repr__</span>(<span style="color: #0000FF;">self</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">'representing: class A, a={0}, b={1}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #0000FF;">self</span>.a, <span style="color: #0000FF;">self</span>.b)

<span style="color: #BA36A5;">mya</span> = A(3, 4)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0}'</span>.<span style="color: #006FE0;">format</span>(mya))    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">uses __format__</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0!s}'</span>.<span style="color: #006FE0;">format</span>(mya))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">uses __str__</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0!r}'</span>.<span style="color: #006FE0;">format</span>(mya))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">uses __repr__</span>
</pre>
</div>

<p>
This covers the majority of string formatting requirements I have come across. If there are more sophisticated needs, they can be met with various string templating python modules. the one I have used most is <a href="http://www.cheetahtemplate.org/">Cheetah</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf0b10c1" class="outline-2">
<h2 id="orgf0b10c1"><span class="section-number-2">3.</span> Math</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org2f71f98" class="outline-3">
<h3 id="org2f71f98"><span class="section-number-3">3.1.</span> Numeric derivatives by differences</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<a href="derivative!numerical">derivative!numerical</a>
<a href="derivative!forward difference">derivative!forward difference</a>
<a href="derivative!backward difference">derivative!backward difference</a>
<a href="derivative!centered difference">derivative!centered difference</a>
numpy has a function called numpy.diff() that is similar to the one found in matlab. It calculates the differences between the elements in your list, and returns a list that is one element shorter, which makes it unsuitable for plotting the derivative of a function.
</p>

<p>
Loops in python are pretty slow (relatively speaking) but they are usually trivial to understand. In this script we show some simple ways to construct derivative vectors using loops. It is implied in these formulas that the data points are equally spaced. If they are not evenly spaced, you need a different approach.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> pylab <span style="color: #0000FF;">import</span> *
<span style="color: #0000FF;">import</span> time

<span style="color: #008000;">'''</span>
<span style="color: #008000;">These are the brainless way to calculate numerical derivatives. They</span>
<span style="color: #008000;">work well for very smooth data. they are surprisingly fast even up to</span>
<span style="color: #008000;">10000 points in the vector.</span>
<span style="color: #008000;">'''</span>

<span style="color: #BA36A5;">x</span> = np.linspace(0.78,0.79,100)
<span style="color: #BA36A5;">y</span> = np.sin(x)
<span style="color: #BA36A5;">dy_analytical</span> = np.cos(x)
<span style="color: #036A07;">'''</span>
<span style="color: #036A07;">lets use a forward difference method:</span>
<span style="color: #036A07;">that works up until the last point, where there is not</span>
<span style="color: #036A07;">a forward difference to use. there, we use a backward difference.</span>
<span style="color: #036A07;">'''</span>

tf1 = time.time()
<span style="color: #BA36A5;">dyf</span> = [0.0]*<span style="color: #006FE0;">len</span>(x)
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(y)-1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dyf</span>[<span style="color: #BA36A5;">i</span>] = (y[i+1] - y[i])/(x[i+1]-x[i])
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">set last element by backwards difference</span>
<span style="color: #BA36A5;">dyf</span>[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">' Forward difference took %f seconds'</span> % (time.time() - tf1))

<span style="color: #008000;">'''and now a backwards difference'''</span>
<span style="color: #BA36A5;">tb1</span> = time.time()
<span style="color: #BA36A5;">dyb</span> = [0.0]*<span style="color: #006FE0;">len</span>(x)
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">set first element by forward difference</span>
<span style="color: #BA36A5;">dyb</span>[0] = (y[0] - y[1])/(x[0] - x[1])
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1,<span style="color: #006FE0;">len</span>(y)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dyb</span>[<span style="color: #BA36A5;">i</span>] = (y[i] - y[i-1])/(x[i]-x[i-1])

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">' Backward difference took %f seconds'</span> % (time.time() - tb1))

<span style="color: #008000;">'''and now, a centered formula'''</span>
<span style="color: #BA36A5;">tc1</span> = time.time()
<span style="color: #BA36A5;">dyc</span> = [0.0]*<span style="color: #006FE0;">len</span>(x)
<span style="color: #BA36A5;">dyc</span>[0] = (y[0] - y[1])/(x[0] - x[1])
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1,<span style="color: #006FE0;">len</span>(y)-1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dyc</span>[<span style="color: #BA36A5;">i</span>] = (y[i+1] - y[i-1])/(x[i+1]-x[i-1])
<span style="color: #BA36A5;">dyc</span>[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">' Centered difference took %f seconds'</span> % (time.time() - tc1))

<span style="color: #008000;">'''</span>
<span style="color: #008000;">the centered formula is the most accurate formula here</span>
<span style="color: #008000;">'''</span>

plt.plot(x,dy_analytical,label=<span style="color: #008000;">'analytical derivative'</span>)
plt.plot(x,dyf,<span style="color: #008000;">'--'</span>,label=<span style="color: #008000;">'forward'</span>)
plt.plot(x,dyb,<span style="color: #008000;">'--'</span>,label=<span style="color: #008000;">'backward'</span>)
plt.plot(x,dyc,<span style="color: #008000;">'--'</span>,label=<span style="color: #008000;">'centered'</span>)

plt.legend(loc=<span style="color: #008000;">'lower left'</span>)
plt.savefig(<span style="color: #008000;">'images/simple-diffs.png'</span>)
</pre>
</div>


<div id="orgf3691a8" class="figure">
<p><img src="pycse-chapters/images/simple-diffs.png" alt="simple-diffs.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org6670dd6" class="outline-3">
<h3 id="org6670dd6"><span class="section-number-3">3.2.</span> Vectorized numeric derivatives</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<a href="derivative!vectorized">derivative!vectorized</a>
Loops are usually not great for performance. Numpy offers some vectorized methods that allow us to compute derivatives without loops, although this comes at the mental cost of harder to understand syntax
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2 * np.pi, 100)
<span style="color: #BA36A5;">y</span> = np.sin(x)
<span style="color: #BA36A5;">dy_analytical</span> = np.cos(x)


<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we need to specify the size of dy ahead because diff returns</span>
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">an array of n-1 elements</span>
<span style="color: #BA36A5;">dy</span> = np.zeros(y.shape, np.<span style="color: #006FE0;">float</span>) <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we know it will be this size</span>
<span style="color: #BA36A5;">dy</span>[0:-1] = np.diff(y) / np.diff(x)
<span style="color: #BA36A5;">dy</span>[-1] = (y[-1] - y[-2]) / (x[-1] - x[-2])


<span style="color: #036A07;">'''</span>
<span style="color: #036A07;">calculate dy by center differencing using array slices</span>
<span style="color: #036A07;">'''</span>

<span style="color: #BA36A5;">dy2</span> = np.zeros(y.shape,np.<span style="color: #006FE0;">float</span>) <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we know it will be this size</span>
<span style="color: #BA36A5;">dy2</span>[1:-1] = (y[2:] - y[0:-2]) / (x[2:] - x[0:-2])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now the end points</span>
<span style="color: #BA36A5;">dy2</span>[0] = (y[1] - y[0]) / (x[1] - x[0])
<span style="color: #BA36A5;">dy2</span>[-1] = (y[-1] - y[-2]) / (x[-1] - x[-2])

plt.plot(x,y)
plt.plot(x,dy_analytical,label=<span style="color: #008000;">'analytical derivative'</span>)
plt.plot(x,dy,label=<span style="color: #008000;">'forward diff'</span>)
plt.plot(x,dy2,<span style="color: #008000;">'k--'</span>,lw=2,label=<span style="color: #008000;">'centered diff'</span>)
plt.legend(loc=<span style="color: #008000;">'lower left'</span>)
plt.savefig(<span style="color: #008000;">'images/vectorized-diffs.png'</span>)
</pre>
</div>


<div id="orgfca58bf" class="figure">
<p><img src="pycse-chapters/images/vectorized-diffs.png" alt="vectorized-diffs.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org1f9d9ac" class="outline-3">
<h3 id="org1f9d9ac"><span class="section-number-3">3.3.</span> 2-point vs. 4-point numerical derivatives</h3>
<div class="outline-text-3" id="text-3-3">
<p>
<a href="derivative!4 point formula">derivative!4 point formula</a>
If your data is very noisy, you will have a hard time getting good derivatives; derivatives tend to magnify noise. In these cases, you have to employ smoothing techniques, either implicitly by using a multipoint derivative formula, or explicitly by smoothing the data yourself, or taking the derivative of a function that has been fit to the data in the neighborhood you are interested in.
</p>

<p>
Here is an example of a 4-point centered difference of some noisy data:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2*np.pi, 100)
<span style="color: #BA36A5;">y</span> = np.sin(x) + 0.1 * np.random.random(size=x.shape)
dy_analytical = np.cos(x)

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">2-point formula</span>
dyf = [0.0] * <span style="color: #006FE0;">len</span>(x)
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(y)-1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   dyf[<span style="color: #BA36A5;">i</span>] = (y[i+1] - y[i])/(x[i+1]-x[i])
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">set last element by backwards difference</span>
dyf[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

<span style="color: #036A07;">'''</span>
<span style="color: #036A07;">calculate dy by 4-point center differencing using array slices</span>

<span style="color: #036A07;">\frac{y[i-2] - 8y[i-1] + 8[i+1] - y[i+2]}{12h}</span>

<span style="color: #036A07;">y[0] and y[1] must be defined by lower order methods</span>
<span style="color: #036A07;">and y[-1] and y[-2] must be defined by lower order methods</span>
<span style="color: #036A07;">'''</span>

dy = np.zeros(y.shape, np.<span style="color: #006FE0;">float</span>) <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we know it will be this size</span>
h = x[1] - x[0] <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">this assumes the points are evenely spaced!</span>
dy[2:-2] = (y[0:-4] - 8 * y[1:-3] + 8 * y[3:-1] - y[4:]) / (12.0 * h)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">simple differences at the end-points</span>
dy[0] = (y[1] - y[0])/(x[1] - x[0])
dy[1] = (y[2] - y[1])/(x[2] - x[1])
dy[-2] = (y[-2] - y[-3]) / (x[-2] - x[-3])
dy[-1] = (y[-1] - y[-2]) / (x[-1] - x[-2])


plt.plot(x, y)
plt.plot(x, dy_analytical, label=<span style="color: #008000;">'analytical derivative'</span>)
plt.plot(x, dyf, <span style="color: #008000;">'r-'</span>, label=<span style="color: #008000;">'2pt-forward diff'</span>)
plt.plot(x, dy, <span style="color: #008000;">'k--'</span>, lw=2, label=<span style="color: #008000;">'4pt-centered diff'</span>)
plt.legend(loc=<span style="color: #008000;">'lower left'</span>)
plt.savefig(<span style="color: #008000;">'images/multipt-diff.png'</span>)
</pre>
</div>


<div id="org6926e41" class="figure">
<p><img src="pycse-chapters/images/multipt-diff.png" alt="multipt-diff.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc734598" class="outline-3">
<h3 id="orgc734598"><span class="section-number-3">3.4.</span> Derivatives by polynomial fitting</h3>
<div class="outline-text-3" id="text-3-4">
<p>
<a href="derivative!polynomial">derivative!polynomial</a>
One way to reduce the noise inherent in derivatives of noisy data is to fit a smooth function through the data, and analytically take the derivative of the curve. Polynomials are especially convenient for this. The challenge is to figure out what an appropriate polynomial order is. This requires judgment and experience.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> deriv

<span style="color: #BA36A5;">tspan</span> = [0, 0.1, 0.2, 0.4, 0.8, 1]
<span style="color: #BA36A5;">Ca_data</span> = [2.0081,  1.5512,  1.1903,  0.7160,  0.2562,  0.1495]

<span style="color: #BA36A5;">p</span> = np.polyfit(tspan, Ca_data, 3)
plt.figure()
plt.plot(tspan, Ca_data)
plt.plot(tspan, np.polyval(p, tspan), <span style="color: #008000;">'g-'</span>)
plt.savefig(<span style="color: #008000;">'images/deriv-fit-1.png'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">compute derivatives</span>
<span style="color: #BA36A5;">dp</span> = np.polyder(p)

<span style="color: #BA36A5;">dCdt_fit</span> = np.polyval(dp, tspan)

<span style="color: #BA36A5;">dCdt_numeric</span> = deriv(tspan, Ca_data) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">2-point deriv</span>

plt.figure()
plt.plot(tspan, dCdt_numeric, label=<span style="color: #008000;">'numeric derivative'</span>)
plt.plot(tspan, dCdt_fit, label=<span style="color: #008000;">'fitted derivative'</span>)

t = np.linspace(<span style="color: #006FE0;">min</span>(tspan), <span style="color: #006FE0;">max</span>(tspan))
plt.plot(t, np.polyval(dp, t), label=<span style="color: #008000;">'resampled derivative'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/deriv-fit-2.png'</span>)
</pre>
</div>


<div id="orgaec6610" class="figure">
<p><img src="pycse-chapters/images/deriv-fit-1.png" alt="deriv-fit-1.png" />
</p>
</div>

<p>
You can see a third order polynomial is a reasonable fit here. There are only 6 data points here, so any higher order risks overfitting. Here is the comparison of the numerical derivative and the fitted derivative. We have "resampled" the fitted derivative to show the actual shape. Note the derivative appears to go through a maximum near t = 0.9. In this case, that is probably unphysical as the data is related to the consumption of species A in a reaction. The derivative should increase monotonically to zero. The increase is an artefact of the fitting process. End points are especially sensitive to this kind of error.
</p>


<div id="orge4214bc" class="figure">
<p><img src="pycse-chapters/images/deriv-fit-2.png" alt="deriv-fit-2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5e42cae" class="outline-3">
<h3 id="org5e42cae"><span class="section-number-3">3.5.</span> Derivatives by fitting a function and taking the analytical derivative</h3>
<div class="outline-text-3" id="text-3-5">
<p>
<a href="derivative!fitting">derivative!fitting</a>
A variation of a polynomial fit is to fit a model with reasonable physics. Here we fit a nonlinear function to the noisy data. The model is for the concentration vs. time in a batch reactor for a first order irreversible reaction. Once we fit the data, we take the analytical derivative of the fitted function.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> curve_fit
<span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> deriv

<span style="color: #BA36A5;">tspan</span> = np.array([0, 0.1, 0.2, 0.4, 0.8, 1])
<span style="color: #BA36A5;">Ca_data</span> = np.array([2.0081,  1.5512,  1.1903,  0.7160,  0.2562,  0.1495])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t, Ca0, k):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Ca0 * np.exp(-k * t)


<span style="color: #BA36A5;">pars</span>, <span style="color: #BA36A5;">pcov</span> = curve_fit(func, tspan, Ca_data, p0=[2, 2.3])

plt.plot(tspan, Ca_data)
plt.plot(tspan, func(tspan, *pars), <span style="color: #008000;">'g-'</span>)
plt.savefig(<span style="color: #008000;">'images/deriv-funcfit-1.png'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">analytical derivative</span>
k, Ca0 = pars
dCdt = -k * Ca0 * np.exp(-k * tspan)
t = np.linspace(0, 2)
dCdt_res =  -k * Ca0 * np.exp(-k * t)

plt.figure()
plt.plot(tspan, deriv(tspan, Ca_data), label=<span style="color: #008000;">'numerical derivative'</span>)
plt.plot(tspan, dCdt, label=<span style="color: #008000;">'analytical derivative of fit'</span>)
plt.plot(t, dCdt_res, label=<span style="color: #008000;">'extrapolated'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/deriv-funcfit-2.png'</span>)
</pre>
</div>


<div id="org5f79fb9" class="figure">
<p><img src="pycse-chapters/images/deriv-funcfit-1.png" alt="deriv-funcfit-1.png" />
</p>
</div>

<p>
Visually this fit is about the same as a third order polynomial. Note the difference in the derivative though. We can readily extrapolate this derivative and get reasonable predictions of the derivative. That is true in this case because we fitted a physically relevant model for concentration vs. time for an irreversible, first order reaction.
</p>


<div id="orgef80b52" class="figure">
<p><img src="pycse-chapters/images/deriv-funcfit-2.png" alt="deriv-funcfit-2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org733866f" class="outline-3">
<h3 id="org733866f"><span class="section-number-3">3.6.</span> Derivatives by FFT</h3>
<div class="outline-text-3" id="text-3-6">
<p>
<a href="derivative!FFT">derivative!FFT</a>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">N</span> = 101 <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">number of points</span>
<span style="color: #BA36A5;">L</span> = 2 * np.pi <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">interval of data</span>

<span style="color: #BA36A5;">x</span> = np.arange(0.0, L, L/<span style="color: #006FE0;">float</span>(N)) <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">this does not include the endpoint</span>

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">add some random noise</span>
<span style="color: #BA36A5;">y</span> = np.sin(x) + 0.05 * np.random.random(size=x.shape)
dy_analytical = np.cos(x)

<span style="color: #036A07;">'''</span>
<span style="color: #036A07;">http://sci.tech-archive.net/Archive/sci.math/2008-05/msg00401.html</span>

<span style="color: #036A07;">you can use fft to calculate derivatives!</span>
<span style="color: #036A07;">'''</span>

<span style="color: #0000FF;">if</span> N % 2 == 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   k = np.asarray(<span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">range</span>(0, N // 2)) + [0] + <span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">range</span>(-N // 2 + 1, 0)), np.float64)
<span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   k = np.asarray(<span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">range</span>(0, (N - 1) // 2)) + [0] + <span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">range</span>(-(N - 1) // 2, 0)), np.float64)

k *= 2 * np.pi / L

fd = np.real(np.fft.ifft(1.0j * k * np.fft.fft(y)))

plt.plot(x, y, label=<span style="color: #008000;">'function'</span>)
plt.plot(x,dy_analytical,label=<span style="color: #008000;">'analytical der'</span>)
plt.plot(x,fd,label=<span style="color: #008000;">'fft der'</span>)
plt.legend(loc=<span style="color: #008000;">'lower left'</span>)

plt.savefig(<span style="color: #008000;">'images/fft-der.png'</span>)
plt.show()
</pre>
</div>


<div id="org6e59279" class="figure">
<p><img src="pycse-chapters/images/fft-der.png" alt="fft-der.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org54e84e0" class="outline-3">
<h3 id="org54e84e0"><span class="section-number-3">3.7.</span> A novel way to numerically estimate the derivative of a function - complex-step derivative approximation</h3>
<div class="outline-text-3" id="text-3-7">
<p>
<a href="derivative!complex step">derivative!complex step</a>
</p>

<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/24/a-novel-way-to-numerically-estimate-the-derivative-of-a-function-complex-step-derivative-approximation/">Matlab post</a>
</p>

<p>
Adapted from <a href="http://biomedicalcomputationreview.org/2/3/8.pdf">http://biomedicalcomputationreview.org/2/3/8.pdf</a> and
<a href="http://dl.acm.org/citation.cfm?id=838250.838251">http://dl.acm.org/citation.cfm?id=838250.838251</a>
</p>

<p>
This posts introduces a novel way to numerically estimate the derivative
of a function that does not involve finite difference schemes. Finite
difference schemes are approximations to derivatives that become more and
more accurate as the step size goes to zero, except that as the step size
approaches the limits of machine accuracy, new errors can appear in the
approximated results. In the references above, a new way to compute the
derivative is presented that does not rely on differences!
</p>

<p>
The new way is: \(f'(x) = \rm{imag}(f(x + i\Delta x)/\Delta x)\) where the
function \(f\) is evaluated in imaginary space with a small \(\Delta x\) in
the complex plane. The derivative is miraculously equal to the imaginary
part of the result in the limit of \(\Delta x \rightarrow 0\)!
</p>

<p>
This example comes from the first link. The derivative must be evaluated
using the chain rule.  We compare a forward difference, central
difference and complex-step derivative approximations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):   <span style="color: #0000FF;">return</span> np.sin(3*x)*np.log(x)

<span style="color: #BA36A5;">x</span> = 0.7
<span style="color: #BA36A5;">h</span> = 1e-7

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">analytical derivative</span>
<span style="color: #BA36A5;">dfdx_a</span> = 3 * np.cos( 3*x)*np.log(x) + np.sin(3*x) / x

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">finite difference</span>
<span style="color: #BA36A5;">dfdx_fd</span> = (f(x + h) - f(x))/h

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">central difference</span>
<span style="color: #BA36A5;">dfdx_cd</span> = (f(x+h)-f(x-h))/(2*h)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">complex method</span>
<span style="color: #BA36A5;">dfdx_I</span> = np.imag(f(x + np.<span style="color: #006FE0;">complex</span>(0, h))/h)

<span style="color: #0000FF;">print</span>(dfdx_a)
<span style="color: #0000FF;">print</span>(dfdx_fd)
<span style="color: #0000FF;">print</span>(dfdx_cd)
<span style="color: #0000FF;">print</span>(dfdx_I)
</pre>
</div>

<p>
These are all the same to 4 decimal places. The simple finite difference is the least accurate, and the central differences is practically the same as the complex number approach.
</p>

<p>
Let us use this method to verify the fundamental Theorem of Calculus, i.e.
to evaluate the derivative of an integral function. Let \(f(x) =
\int\limits_1^{x^2} tan(t^3)dt\), and we now want to compute df/dx.
Of course, this can be done
<a href="http://mathmistakes.info/facts/CalculusFacts/learn/doi/doif.html">analytically</a>, but it is not trivial!
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f_</span>(z):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.tan(t**3)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> quad(integrand, 0, z**2)

<span style="color: #BA36A5;">f</span> = np.vectorize(f_)

<span style="color: #BA36A5;">x</span> = np.linspace(0, 1)

<span style="color: #BA36A5;">h</span> = 1e-7

<span style="color: #BA36A5;">dfdx</span> = np.imag(f(x + <span style="color: #006FE0;">complex</span>(0, h)))/h
<span style="color: #BA36A5;">dfdx_analytical</span> = 2 * x * np.tan(x**6)

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.plot(x, dfdx, x, dfdx_analytical, <span style="color: #008000;">'r--'</span>)
plt.show()
</pre>
</div>

<p>
Interesting this fails.
</p>
</div>
</div>
<div id="outline-container-org163679d" class="outline-3">
<h3 id="org163679d"><span class="section-number-3">3.8.</span> Vectorized piecewise functions</h3>
<div class="outline-text-3" id="text-3-8">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/05/vectorized-piecewise-functions/">Matlab post</a>
Occasionally we need to define piecewise functions, e.g.
</p>

\begin{eqnarray}
f(x) &=&  0, x < 0 \\
     &=&  x, 0 <= x < 1\\
     &=&  2 - x, 1 < x <= 2\\
     &=&  0, x > 2
\end{eqnarray}

<p>
Today we examine a few ways to define a function like this. A simple way is to use conditional statements.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">f1</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> x &lt; 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> (x &gt;= 0) &amp; (x &lt; 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> (x &gt;= 1) &amp; (x &lt; 2):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 2.0 - x
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0

<span style="color: #0000FF;">print</span>(f1(-1))
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">print(f1([0, 1, 2, 3]))  # does not work!</span>
</pre>
</div>

<p>
This works, but the function is not vectorized, i.e. f([-1 0 2 3]) does not evaluate properly (it should give a list or array). You can get vectorized behavior by using list comprehension, or by writing your own loop. This does not fix all limitations, for example you cannot use the f1 function in the quad function to integrate it.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(-1, 3)
<span style="color: #BA36A5;">y</span> = [f1(xx) <span style="color: #0000FF;">for</span> xx <span style="color: #0000FF;">in</span> x]

plt.plot(x, y)
plt.savefig(<span style="color: #008000;">'images/vector-piecewise.png'</span>)
</pre>
</div>


<div id="orgce3fc0a" class="figure">
<p><img src="pycse-chapters/images/vector-piecewise.png" alt="vector-piecewise.png" />
</p>
</div>

<p>
Neither of those methods is convenient. It would be nicer if the function was vectorized, which would allow the direct notation f1([0, 1, 2, 3, 4]). A simple way to achieve this is through the use of logical arrays. We create logical arrays from comparison statements.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">f2</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'fully vectorized version'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = np.asarray(x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = np.zeros(x.shape)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> += ((x &gt;= 0) &amp; (x &lt; 1)) * x
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> += ((x &gt;= 1) &amp; (x &lt; 2)) * (2 - x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y

<span style="color: #0000FF;">print</span>(f2([-1, 0, 1, 2, 3, 4]))
<span style="color: #BA36A5;">x</span> = np.linspace(-1,3);
plt.plot(x,f2(x))
plt.savefig(<span style="color: #008000;">'images/vector-piecewise-2.png'</span>)
</pre>
</div>


<div id="orga5ddd7b" class="figure">
<p><img src="pycse-chapters/images/vector-piecewise-2.png" alt="vector-piecewise-2.png" />
</p>
</div>

<p>
A third approach is to use Heaviside functions. The Heaviside function is defined to be zero for x less than some value, and 0.5 for x=0, and 1 for x &gt;= 0. If you can live with y=0.5 for x=0, you can define a vectorized function in terms of Heaviside functions like this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">heaviside</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = np.array(x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> x.shape != ():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = np.zeros(x.shape)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span>[x &gt; 0.0] = 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span>[x == 0.0] = 0.5
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">special case for 0d array (a number)</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> x &gt; 0: <span style="color: #BA36A5;">y</span> = 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> x == 0: y = 0.5
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>: y = 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f3</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x = np.array(x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   y1 = (heaviside(x) - heaviside(x - 1)) * x <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">first interval</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   y2 = (heaviside(x - 1) - heaviside(x - 2)) * (2 - x) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">second interval</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y1 + y2

<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad
<span style="color: #0000FF;">print</span>(quad(f3, -1, 3))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-python">plt.plot(x, f3(x))
plt.savefig(<span style="color: #008000;">'images/vector-piecewise-3.png'</span>)
</pre>
</div>


<div id="orgdde8bdc" class="figure">
<p><img src="pycse-chapters/images/vector-piecewise-3.png" alt="vector-piecewise-3.png" />
</p>
</div>

<p>
There are many ways to define piecewise functions, and vectorization is not always necessary. The advantages of vectorization are usually notational simplicity and speed; loops in python are usually very slow compared to vectorized functions.
</p>
</div>
</div>

<div id="outline-container-orgef22869" class="outline-3">
<h3 id="orgef22869"><span class="section-number-3">3.9.</span> Smooth transitions between discontinuous functions</h3>
<div class="outline-text-3" id="text-3-9">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/30/smooth-transitions-between-discontinuous-functions/">original post</a>
</p>

<p>
In <a href="http://matlab.cheme.cmu.edu/2011/10/27/compute-pipe-diameter/">Post 1280</a> we used a correlation for the Fanning friction factor for turbulent flow in a pipe. For laminar flow (Re &lt; 3000), there is another correlation that is commonly used: \(f_F = 16/Re\). Unfortunately, the correlations for laminar flow and turbulent flow have different values at the transition that should occur at Re = 3000. This discontinuity can cause a lot of problems for numerical solvers that rely on derivatives.
</p>

<p>
Today we examine a strategy for smoothly joining these two functions. First we define the two functions.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fF_laminar</span>(Re):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 16.0 / Re

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fF_turbulent_unvectorized</span>(Re):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Nikuradse correlation for turbulent flow</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1/np.sqrt(f) = (4.0*np.log10(Re*np.sqrt(f))-0.4)</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we have to solve this equation to get f</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(f):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">fguess</span> = 0.01
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f</span>, = fsolve(func, fguess)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this enables us to pass vectors to the function and get vectors as</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">solutions</span>
<span style="color: #BA36A5;">fF_turbulent</span> = np.vectorize(fF_turbulent_unvectorized)
</pre>
</div>

<p>
Now we plot the correlations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Re1</span> = np.linspace(500, 3000)
<span style="color: #BA36A5;">f1</span> = fF_laminar(Re1)

<span style="color: #BA36A5;">Re2</span> = np.linspace(3000, 10000)
<span style="color: #BA36A5;">f2</span> = fF_turbulent(Re2)

plt.figure(1); plt.clf()
plt.plot(Re1, f1, label=<span style="color: #008000;">'laminar'</span>)
plt.plot(Re2, f2, label=<span style="color: #008000;">'turbulent'</span>)
plt.xlabel(<span style="color: #008000;">'Re'</span>)
plt.ylabel(<span style="color: #008000;">'$f_F$'</span>)
plt.legend()
plt.savefig(<span style="color: #008000;">'images/smooth-transitions-1.png'</span>)
</pre>
</div>


<div id="org4cc5e44" class="figure">
<p><img src="pycse-chapters/images/smooth-transitions-1.png" alt="smooth-transitions-1.png" />
</p>
</div>

<p>
You can see the discontinuity at Re = 3000. What we need is a method to join these two functions smoothly. We can do that with a sigmoid function.
Sigmoid functions
</p>

<p>
A sigmoid function smoothly varies from 0 to 1 according to the equation: \(\sigma(x) = \frac{1}{1 + e^{-(x-x0)/\alpha}}\). The transition is centered on \(x0\), and \(\alpha\) determines the width of the transition.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">x</span> = np.linspace(-4, 4);
<span style="color: #BA36A5;">y</span> = 1.0 / (1 + np.exp(-x / 0.1))
plt.figure(2)
plt.clf()
plt.plot(x, y)
plt.xlabel(<span style="color: #008000;">'x'</span>); plt.ylabel(<span style="color: #008000;">'y'</span>); plt.title(<span style="color: #008000;">'$\sigma(x)$'</span>)
plt.savefig(<span style="color: #008000;">'images/smooth-transitions-sigma.png'</span>)
</pre>
</div>




<div id="orgd6961ae" class="figure">
<p><img src="pycse-chapters/images/smooth-transitions-sigma.png" alt="smooth-transitions-sigma.png" />
</p>
</div>

<p>
If we have two functions, \(f_1(x)\) and \(f_2(x)\) we want to smoothly join, we do it like this: \(f(x) = (1-\sigma(x))f_1(x) + \sigma(x)f_2(x)\). There is no formal justification for this form of joining, it is simply a mathematical convenience to get a numerically smooth function. Other functions besides the sigmoid function could also be used, as long as they smoothly transition from 0 to 1, or from 1 to zero.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">fanning_friction_factor</span>(Re):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''combined, continuous correlation for the fanning friction factor.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   the alpha parameter is chosen to provide the desired smoothness.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   The transition region is about +- 4*alpha. The value 450 was</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   selected to reasonably match the shape of the correlation</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   function provided by Morrison (see last section of this file)'''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sigma</span> =  1. / (1 + np.exp(-(Re - 3000.0) / 450.0));
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f</span> = (1-sigma) * fF_laminar(Re) + sigma * fF_turbulent(Re)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f

<span style="color: #BA36A5;">Re</span> = np.linspace(500, 10000);
<span style="color: #BA36A5;">f</span> = fanning_friction_factor(Re);

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">add data to figure 1</span>
plt.figure(1)
plt.plot(Re,f, label=<span style="color: #008000;">'smooth transition'</span>)
plt.xlabel(<span style="color: #008000;">'Re'</span>)
plt.ylabel(<span style="color: #008000;">'$f_F$'</span>)
plt.legend()
plt.savefig(<span style="color: #008000;">'images/smooth-transitions-3.png'</span>)
</pre>
</div>


<div id="org5a835fe" class="figure">
<p><img src="pycse-chapters/images/smooth-transitions-3.png" alt="smooth-transitions-3.png" />
</p>
</div>

<p>
You can see that away from the transition the combined function is practically equivalent to the original two functions. That is because away from the transition the sigmoid function is 0 or 1. Near Re = 3000 is a smooth transition from one curve to the other curve.
</p>

<p>
<a href="http://www.chem.mtu.edu/~fmorriso/DataCorrelationForSmoothPipes2010.pdf">Morrison</a> derived a single function for the friction factor correlation over all Re: \(f = \frac{0.0076\left(\frac{3170}{Re}\right)^{0.165}}{1 + \left(\frac{3171}{Re}\right)^{7.0}} + \frac{16}{Re}\). Here we show the comparison with the approach used above. The friction factor differs slightly at high Re, because Morrison's is based on the Prandlt correlation, while the work here is based on the Nikuradse correlation. They are similar, but not the same.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">add this correlation to figure 1</span>
<span style="color: #BA36A5;">h</span>, = plt.plot(Re, 16.0/Re + (0.0076 * (3170 / Re)**0.165) / (1 + (3170.0 / Re)**7))

<span style="color: #BA36A5;">ax</span> = plt.gca()
<span style="color: #BA36A5;">handles</span>, <span style="color: #BA36A5;">labels</span> = ax.get_legend_handles_labels()

handles.append(h)
labels.append(<span style="color: #008000;">'Morrison'</span>)
ax.legend(handles, labels)
plt.savefig(<span style="color: #008000;">'images/smooth-transitions-morrison.png'</span>)
</pre>
</div>


<div id="orge1859a7" class="figure">
<p><img src="pycse-chapters/images/smooth-transitions-morrison.png" alt="smooth-transitions-morrison.png" />
</p>
</div>
</div>

<div id="outline-container-orge0de2db" class="outline-4">
<h4 id="orge0de2db"><span class="section-number-4">3.9.1.</span> Summary</h4>
<div class="outline-text-4" id="text-3-9-1">
<p>
The approach demonstrated here allows one to smoothly join two discontinuous functions that describe physics in different regimes, and that must transition over some range of data. It should be emphasized that the method has no physical basis, it simply allows one to create a mathematically smooth function, which could be necessary for some optimizers or solvers to work.
</p>
</div>
</div>
</div>

<div id="outline-container-org3dd8efa" class="outline-3">
<h3 id="org3dd8efa"><span class="section-number-3">3.10.</span> Smooth transitions between two constants</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Suppose we have a parameter that has two different values depending on the value of a dimensionless number. For example when the dimensionless number is much less than 1, x = 2/3, and when x is much greater than 1, x = 1. We desire a smooth transition from 2/3 to 1  as a function of x to avoid discontinuities in functions of x. We will adapt the smooth transitions between functions to be a smooth transition between constants.
</p>

<p>
We define our function as \(x(D) = x0 + (x1 - x0)*(1 - sigma(D,w)\). We control the rate of the transition by the variable \(w\)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x0</span> = 2.0 / 3.0
<span style="color: #BA36A5;">x1</span> = 1.5

<span style="color: #BA36A5;">w</span> = 0.05

<span style="color: #BA36A5;">D</span> = np.linspace(0,2, 500)

<span style="color: #BA36A5;">sigmaD</span> = 1.0 / (1.0 + np.exp(-(1 - D) / w))

<span style="color: #BA36A5;">x</span> =  x0 + (x1 - x0)*(1 - sigmaD)

plt.plot(D, x)
plt.xlabel(<span style="color: #008000;">'D'</span>); plt.ylabel(<span style="color: #008000;">'x'</span>)
plt.savefig(<span style="color: #008000;">'images/smooth-transitions-constants.png'</span>)
</pre>
</div>


<div id="org59a252b" class="figure">
<p><img src="pycse-chapters/images/smooth-transitions-constants.png" alt="smooth-transitions-constants.png" />
</p>
</div>

<p>
This is a nice trick to get an analytical function with continuous derivatives for a transition between two constants. You could have the transition occur at a value other than D = 1, as well by changing the argument to the exponential function.
</p>
</div>
</div>

<div id="outline-container-org4773855" class="outline-3">
<h3 id="org4773855"><span class="section-number-3">3.11.</span> On the quad or trapz'd in ChemE heaven</h3>
<div class="outline-text-3" id="text-3-11">
<p>
<a href="integration!trapezoid ">integration!trapezoid </a>
<a href="integration!quad">integration!quad</a>
<a href="http://matlab.cheme.cmu.edu/2011/09/12/on-the-quad-or-trapzd-in-cheme-heaven/">Matlab post</a>
</p>

<p>
What is the difference between quad and trapz? The short answer is that quad integrates functions (via a function handle) using numerical quadrature, and trapz performs integration of arrays of data using the trapezoid method.
</p>

<p>
Let us look at some examples. We consider the example of computing \(\int_0^2 x^3 dx\). the analytical integral is \(1/4 x^4\), so we know the integral evaluates to 16/4 = 4. This will be our benchmark for comparison to the numerical methods.
</p>

<p>
We use the scipy.integrate.quad command  to evaluate this \(\int_0^2 x^3 dx\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">err</span> = quad(<span style="color: #0000FF;">lambda</span> x: x**3, 0, 2)
<span style="color: #0000FF;">print</span>(ans)
</pre>
</div>

<p>
you can also define a function for the integrand.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x**3

<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">err</span> = quad(integrand, 0, 2)
<span style="color: #0000FF;">print</span>(ans)
</pre>
</div>
</div>

<div id="outline-container-org72b5dfe" class="outline-4">
<h4 id="org72b5dfe"><span class="section-number-4">3.11.1.</span> Numerical data integration</h4>
<div class="outline-text-4" id="text-3-11-1">
<p>
if we had numerical data like this, we use trapz to integrate it
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x</span> = np.array([0, 0.5, 1, 1.5, 2])
<span style="color: #BA36A5;">y</span> = x**3

<span style="color: #BA36A5;">i2</span> = np.trapz(y, x)

<span style="color: #BA36A5;">error</span> = (i2 - 4) / 4

<span style="color: #0000FF;">print</span>(i2, error)
</pre>
</div>

<p>
Note the integral of these vectors is greater than 4! You can see why here.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #BA36A5;">x</span> = np.array([0, 0.5, 1, 1.5, 2])
<span style="color: #BA36A5;">y</span> = x**3

<span style="color: #BA36A5;">x2</span> = np.linspace(0, 2)
<span style="color: #BA36A5;">y2</span> = x2**3

plt.plot(x, y, label=<span style="color: #008000;">'5 points'</span>)
plt.plot(x2, y2, label=<span style="color: #008000;">'50 points'</span>)
plt.legend()
plt.savefig(<span style="color: #008000;">'images/quad-1.png'</span>)
</pre>
</div>


<div id="orgf25153a" class="figure">
<p><img src="pycse-chapters/images/quad-1.png" alt="quad-1.png" />
</p>
</div>

<p>
The trapezoid method is overestimating the area significantly. With more points, we get much closer to the analytical value.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x2</span> = np.linspace(0, 2, 100)
<span style="color: #BA36A5;">y2</span> = x2**3

<span style="color: #0000FF;">print</span>(np.trapz(y2, x2))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb3ea3f" class="outline-4">
<h4 id="orgcb3ea3f"><span class="section-number-4">3.11.2.</span> Combining numerical data with quad</h4>
<div class="outline-text-4" id="text-3-11-2">
<p>
You might want to combine numerical data with the quad function if you want to perform integrals easily. Let us say you are given this data:
</p>

<p>
x = [0 0.5 1 1.5 2];
y = [0    0.1250    1.0000    3.3750    8.0000];
</p>

<p>
and you want to integrate this from x = 0.25 to 1.75. We do not have data in those regions, so some interpolation is going to be needed. Here is one approach.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x</span> = [0, 0.5, 1, 1.5, 2]
<span style="color: #BA36A5;">y</span> = [0,    0.1250,    1.0000,    3.3750,    8.0000]

<span style="color: #BA36A5;">f</span> = interp1d(x, y)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">numerical trapezoid method</span>
<span style="color: #BA36A5;">xfine</span> = np.linspace(0.25, 1.75)
<span style="color: #BA36A5;">yfine</span> = f(xfine)
<span style="color: #0000FF;">print</span>(np.trapz(yfine, xfine))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">quadrature with interpolation</span>
<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">err</span> = quad(f, 0.25, 1.75)
<span style="color: #0000FF;">print</span>(ans)
</pre>
</div>

<p>
These approaches are very similar, and both rely on linear interpolation. The second approach is simpler, and uses fewer lines of code.
</p>
</div>
</div>

<div id="outline-container-orgb649ce1" class="outline-4">
<h4 id="orgb649ce1"><span class="section-number-4">3.11.3.</span> Summary</h4>
<div class="outline-text-4" id="text-3-11-3">
<p>
trapz and quad are functions for getting integrals. Both can be used with numerical data if interpolation is used. The syntax for the quad and trapz function is different in scipy than in Matlab.
</p>

<p>
Finally, see this <a href="http://matlab.cheme.cmu.edu/2011/08/30/solving-integral-equations/">post</a> for an example of solving an integral equation using quad and fsolve.
</p>
</div>
</div>
</div>
<div id="outline-container-orgafd4221" class="outline-3">
<h3 id="orgafd4221"><span class="section-number-3">3.12.</span> Polynomials in python</h3>
<div class="outline-text-3" id="text-3-12">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/01/polynomials-in-matlab/">Matlab post</a>
</p>

<p>
Polynomials can be represented as a list of coefficients. For example, the polynomial \(4*x^3 + 3*x^2 -2*x + 10 = 0\) can be represented as [4, 3, -2, 10]. Here are some ways to create a polynomial object, and evaluate it.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">ppar</span> = [4, 3, -2, 10]
<span style="color: #BA36A5;">p</span> = np.poly1d(ppar)

<span style="color: #0000FF;">print</span>(p(3))
<span style="color: #0000FF;">print</span>(np.polyval(ppar, 3))

<span style="color: #BA36A5;">x</span> = 3
<span style="color: #0000FF;">print</span>(4*x**3 + 3*x**2 -2*x + 10)
</pre>
</div>

<p>
numpy makes it easy to get the derivative and integral of a polynomial.
</p>

<p>
Consider: \(y = 2x^2 - 1\). We know the derivative is \(4x\). Here we compute the derivative and evaluate it at x=4.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">p</span> = np.poly1d([2, 0, -1])
<span style="color: #BA36A5;">p2</span> = np.polyder(p)
<span style="color: #0000FF;">print</span>(p2)
<span style="color: #0000FF;">print</span>(p2(4))
</pre>
</div>

<p>
The integral of the previous polynomial is \(\frac{2}{3} x^3 - x + c\). We assume \(C=0\). Let us compute the integral \(\int_2^4 2x^2 - 1 dx\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">p</span> = np.poly1d([2, 0, -1])
<span style="color: #BA36A5;">p2</span> = np.polyint(p)
<span style="color: #0000FF;">print</span>(p2)
<span style="color: #0000FF;">print</span>(p2(4) - p2(2))
</pre>
</div>

<p>
One reason to use polynomials is the ease of finding all of the roots using numpy.roots.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.roots([2, 0, -1])) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">roots are +- sqrt(2)</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">note that imaginary roots exist, e.g. x^2 + 1 = 0 has two roots, +-i</span>
<span style="color: #BA36A5;">p</span> = np.poly1d([1, 0, 1])
<span style="color: #0000FF;">print</span>(np.roots(p))
</pre>
</div>

<p>
There are applications of polynomials in thermodynamics. The van der waal equation is a cubic polynomial \(f(V) = V^3 - \frac{p n b + n R T}{p} V^2 + \frac{n^2 a}{p}V - \frac{n^3 a b}{p} = 0\), where \(a\) and \(b\) are constants, \(p\) is the pressure, \(R\) is the gas constant, \(T\) is an absolute temperature and \(n\) is the number of moles. The roots of this equation tell you the volume of the gas at those conditions.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">numerical values of the constants</span>
<span style="color: #BA36A5;">a</span> = 3.49e4
<span style="color: #BA36A5;">b</span> = 1.45
<span style="color: #BA36A5;">p</span> = 679.7   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">pressure in psi</span>
<span style="color: #BA36A5;">T</span> = 683     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">T in Rankine</span>
<span style="color: #BA36A5;">n</span> = 1.136   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">lb-moles</span>
<span style="color: #BA36A5;">R</span> = 10.73   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">ft^3 * psi /R / lb-mol</span>

<span style="color: #BA36A5;">ppar</span> = [1.0, -(p*n*b+n*R*T)/p, n**2*a/p,  -n**3*a*b/p];
<span style="color: #0000FF;">print</span>(np.roots(ppar))
</pre>
</div>

<p>
Note that only one root is real (and even then, we have to interpret 0.j as not being imaginary. Also, in a cubic polynomial, there can only be two imaginary roots). In this case that means there is only one phase present.
</p>
</div>

<div id="outline-container-orgfb49ed9" class="outline-4">
<h4 id="orgfb49ed9"><span class="section-number-4">3.12.1.</span> Summary</h4>
<div class="outline-text-4" id="text-3-12-1">
<p>
Polynomials in numpy are even better than in Matlab, because you get a polynomial object that acts just like a function. Otherwise, they are functionally equivalent.
</p>
</div>
</div>
</div>
<div id="outline-container-orgad36aba" class="outline-3">
<h3 id="orgad36aba"><span class="section-number-3">3.13.</span> Wilkinson's polynomial</h3>
<div class="outline-text-3" id="text-3-13">
<p>
<a href="http://en.wikipedia.org/wiki/Wilkinson%27s_polynomial">Wilkinson's polynomial</a> is defined as
\(  w(x) = \prod_{i=1}^{20} (x - i) = (x-1)(x-2) \ldots (x-20) \).
</p>

<p>
This innocent looking function has 20 roots, which are 1,2,3,&#x2026;,19,20. Here is a plot of the function.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #6434A3;">@np.vectorize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">wilkinson</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">p</span> = np.prod(np.array([x - i <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, 21)]))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> p

<span style="color: #BA36A5;">x</span> = np.linspace(0, 21, 1000)
plt.plot(x, wilkinson(x))
plt.ylim([-5e13, 5e13])
plt.savefig(<span style="color: #008000;">'./images/wilkinson-1.png'</span>)
</pre>
</div>


<div id="org66fbae8" class="figure">
<p><img src="pycse-chapters/images/wilkinson-1.png" alt="wilkinson-1.png" />
</p>
</div>

<p>
Let us consider the expanded version of the polynomial. We will use sympy to expand the polynomial.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Symbol, Poly
<span style="color: #0000FF;">from</span> sympy.polys.polytools <span style="color: #0000FF;">import</span>   poly_from_expr

<span style="color: #BA36A5;">x</span> = Symbol(<span style="color: #008000;">'x'</span>)
<span style="color: #BA36A5;">W</span> = 1
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, 21):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">W</span> = W * (x-i)

<span style="color: #0000FF;">print</span>(W.expand())

<span style="color: #BA36A5;">P</span>,<span style="color: #BA36A5;">d</span> = poly_from_expr(W.expand())
<span style="color: #0000FF;">print</span>(P)
</pre>
</div>

<p>
The coefficients are orders of magnitude apart in size. This should make you nervous, because the roots of this equation are between 1-20, but there are numbers here that are O(19). This is likely to make any rounding errors in the number representations very significant, and may lead to issues with accuracy of the solution. Let us explore that.
</p>

<p>
We will get the roots using numpy.roots.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Symbol
<span style="color: #0000FF;">from</span> sympy.polys.polytools <span style="color: #0000FF;">import</span>   poly_from_expr

<span style="color: #BA36A5;">x</span> = Symbol(<span style="color: #008000;">'x'</span>)
<span style="color: #BA36A5;">W</span> = 1
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, 21):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">W</span> = W * (x-i)

<span style="color: #BA36A5;">P</span>,<span style="color: #BA36A5;">d</span> = poly_from_expr(W.expand())
<span style="color: #BA36A5;">p</span> = P.all_coeffs()
<span style="color: #BA36A5;">x</span> = np.arange(1, 21)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nThese are the known roots\n'</span>,x)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">evaluate the polynomial at the known roots</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nThe polynomial evaluates to {0} at the known roots'</span>.<span style="color: #006FE0;">format</span>(np.polyval(p, x)))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">find the roots ourselves</span>
<span style="color: #BA36A5;">roots</span> = np.roots(p)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nHere are the roots from numpy:\n'</span>, roots)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">evaluate solution at roots</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nHere is the polynomial evaluated at the calculated roots:\n'</span>, np.polyval(p, roots))
</pre>
</div>

<p>
The roots are not exact. Even more to the point, the polynomial does not evaluate to zero at the calculated roots! Something is clearly wrong here. The polynomial function is fine, and it does evaluate to zero at the known roots which are integers. It is subtle, but up to that point, we are using only integers, which can be represented exactly. The roots function is evidently using some float math, and the floats are not the same as the integers.
</p>

<p>
If we simply change the roots to floats, and reevaluate our polynomial, we get dramatically different results.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Symbol
<span style="color: #0000FF;">from</span> sympy.polys.polytools <span style="color: #0000FF;">import</span>   poly_from_expr

<span style="color: #BA36A5;">x</span> = Symbol(<span style="color: #008000;">'x'</span>)
<span style="color: #BA36A5;">W</span> = 1
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, 21):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">W</span> = W * (x - i)

<span style="color: #BA36A5;">P</span>, <span style="color: #BA36A5;">d</span> = poly_from_expr(W.expand())
<span style="color: #BA36A5;">p</span> = P.all_coeffs()
<span style="color: #BA36A5;">x</span> = np.arange(1, 21, dtype=np.<span style="color: #006FE0;">float</span>)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nThese are the known roots\n'</span>,x)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">evaluate the polynomial at the known roots</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nThe polynomial evaluates to {0} at the known roots'</span>.<span style="color: #006FE0;">format</span>(np.polyval(p, x)))
</pre>
</div>

<p>
This also happens if we make the polynomial coefficients floats. That happens because in Python whenever one element is a float the results of math operations with that element are floats.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Symbol
<span style="color: #0000FF;">from</span> sympy.polys.polytools <span style="color: #0000FF;">import</span>   poly_from_expr

<span style="color: #BA36A5;">x</span> = Symbol(<span style="color: #008000;">'x'</span>)
<span style="color: #BA36A5;">W</span> = 1
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, 21):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">W</span> = W * (x - i)

<span style="color: #BA36A5;">P</span>,<span style="color: #BA36A5;">d</span> = poly_from_expr(W.expand())
<span style="color: #BA36A5;">p</span> = [<span style="color: #006FE0;">float</span>(x) <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> P.all_coeffs()]
<span style="color: #BA36A5;">x</span> = np.arange(1, 21)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nThese are the known roots\n'</span>,x)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">evaluate the polynomial at the known roots</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\nThe polynomial evaluates to {0} at the known roots'</span>.<span style="color: #006FE0;">format</span>(np.polyval(p, x)))
</pre>
</div>

<p>
Let us try to understand what is happening here. It turns out that the integer and float representations of the numbers are different! It is known that you cannot exactly represent numbers as floats.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Symbol
<span style="color: #0000FF;">from</span> sympy.polys.polytools <span style="color: #0000FF;">import</span>   poly_from_expr

<span style="color: #BA36A5;">x</span> = Symbol(<span style="color: #008000;">'x'</span>)
<span style="color: #BA36A5;">W</span> = 1
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, 21):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">W</span> = W * (x - i)

<span style="color: #BA36A5;">P</span>, <span style="color: #BA36A5;">d</span> = poly_from_expr(W.expand())
<span style="color: #BA36A5;">p</span> = P.all_coeffs()
<span style="color: #0000FF;">print</span>(p)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:&lt;30s}{1:&lt;30s}{2}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #008000;">'Integer'</span>,<span style="color: #008000;">'Float'</span>,<span style="color: #008000;">'\delta'</span>))
<span style="color: #0000FF;">for</span> pj <span style="color: #0000FF;">in</span> p:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:&lt;30d}{1:&lt;30f}{2:3e}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">int</span>(pj), <span style="color: #006FE0;">float</span>(pj), <span style="color: #006FE0;">int</span>(pj) - <span style="color: #006FE0;">float</span>(pj)))
</pre>
</div>

<p>
Now you can see the issue. Many of these numbers are identical in integer and float form, but some of them are not. The integer <i>cannot</i> be exactly represented as a float, and there is a difference in the representations. It is a small difference compared to the magnitude, but these kinds of differences get raised to high powers, and become larger. You may wonder why I used "0:&lt;30s&gt;" to print the integer? That is because <code>pj</code> in that loop is an object from sympy, which prints as a string.
</p>

<p>
This is a famous, and well known problem that is especially bad for this case. This illustrates that you cannot simply rely on what a computer tells you the answer is, without doing some critical thinking about the problem and the solution. Especially in problems where there are coefficients that vary by many orders of magnitude you should be cautious.
</p>

<p>
There are a few interesting webpages on this topic, which inspired me to work this out in python. These webpages go into more detail on this problem, and provide additional insight into the sensitivity of the solutions to the polynomial coefficients.
</p>
<ol class="org-ol">
<li><a href="http://blogs.mathworks.com/cleve/2013/03/04/wilkinsons-polynomials/">http://blogs.mathworks.com/cleve/2013/03/04/wilkinsons-polynomials/</a></li>
<li><a href="http://www.numericalexpert.com/blog/wilkinson_polynomial/">http://www.numericalexpert.com/blog/wilkinson_polynomial/</a></li>
<li><a href="http://en.wikipedia.org/wiki/Wilkinson%27s_polynomial">http://en.wikipedia.org/wiki/Wilkinson%27s_polynomial</a></li>
</ol>
</div>
</div>
<div id="outline-container-org3202036" class="outline-3">
<h3 id="org3202036"><span class="section-number-3">3.14.</span> The trapezoidal method of integration</h3>
<div class="outline-text-3" id="text-3-14">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/14/the-trapezoidal-method-of-integration/">Matlab post</a>
<a href="integration:trapz">integration:trapz</a>
See <a href="http://en.wikipedia.org/wiki/Trapezoidal_rule">http://en.wikipedia.org/wiki/Trapezoidal_rule</a>
</p>

<p>
\[\int_a^b f(x) dx \approx \frac{1}{2}\displaystyle\sum\limits_{k=1}^N(x_{k+1}-x_k)(f(x_{k+1}) + f(x_k))\]
</p>

<p>
Let us compute the integral of sin(x) from x=0 to \(\pi\). To approximate the integral, we need to divide the interval from \(a\) to \(b\) into \(N\) intervals. The analytical answer is 2.0.
</p>

<p>
We will use this example to illustrate the difference in performance between loops and vectorized operations in python.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> time

<span style="color: #BA36A5;">a</span> = 0.0; <span style="color: #BA36A5;">b</span> = np.pi;
<span style="color: #BA36A5;">N</span> = 1000; <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the number of intervals</span>

<span style="color: #BA36A5;">h</span> = (b - a)/N; <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the width of each interval</span>
<span style="color: #BA36A5;">x</span> = np.linspace(a, b, N)
<span style="color: #BA36A5;">y</span> = np.sin(x); <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the sin function is already vectorized</span>

<span style="color: #BA36A5;">t0</span> = time.time()
<span style="color: #BA36A5;">f</span> = 0.0
<span style="color: #0000FF;">for</span> k <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(x) - 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f</span> += 0.5 * ((x[k+1] - x[k]) * (y[k+1] + y[k]))

<span style="color: #BA36A5;">tf</span> = time.time() - t0
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'time elapsed = {0} sec'</span>.<span style="color: #006FE0;">format</span>(tf))

<span style="color: #0000FF;">print</span>(f)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">t0</span> = time.time()
<span style="color: #BA36A5;">Xk</span> = x[1:-1] - x[0:-2] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">vectorized version of (x[k+1] - x[k])</span>
<span style="color: #BA36A5;">Yk</span> = y[1:-1] + y[0:-2] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">vectorized version of (y[k+1] + y[k])</span>

<span style="color: #BA36A5;">f</span> = 0.5 * np.<span style="color: #006FE0;">sum</span>(Xk * Yk) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">vectorized version of the loop above</span>
<span style="color: #BA36A5;">tf</span> = time.time() - t0
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'time elapsed = {0} sec'</span>.<span style="color: #006FE0;">format</span>(tf))

<span style="color: #0000FF;">print</span>(f)
</pre>
</div>

<p>
In the last example, there may be loop buried in the sum command. Let us do one final method, using linear algebra, in a single line. The key to understanding this is to recognize the sum is just the result of a dot product of the x differences and y sums.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">t0</span> = time.time()
<span style="color: #BA36A5;">f</span> = 0.5 * np.dot(Xk, Yk)
<span style="color: #BA36A5;">tf</span> = time.time() - t0
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'time elapsed = {0} sec'</span>.<span style="color: #006FE0;">format</span>(tf))

<span style="color: #0000FF;">print</span>(f)
</pre>
</div>

<p>
The loop method is straightforward to code, and looks alot like the formula that defines the trapezoid method. the vectorized methods are not as easy to read, and take fewer lines of code to write. However, the vectorized methods are much faster than the loop, so the loss of readability could be worth it for very large problems.
</p>

<p>
The times here are considerably slower than in Matlab. I am not sure if that is a totally fair comparison. Here I am running python through emacs, which may result in slower performance. I also used a very crude way of timing the performance which lumps some system performance in too.
</p>
</div>
</div>

<div id="outline-container-orgac63143" class="outline-3">
<h3 id="orgac63143"><span class="section-number-3">3.15.</span> Numerical Simpsons rule</h3>
<div class="outline-text-3" id="text-3-15">
<p>
<a href="integration!Simpson's rule">integration!Simpson's rule</a>
A more accurate numerical integration than the trapezoid method is <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simps.html">Simpson's rule</a>. The syntax is similar to trapz, but the method is in scipy.integrate.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> simps, romb

<span style="color: #BA36A5;">a</span> = 0.0; <span style="color: #BA36A5;">b</span> = np.pi / 4.0;
<span style="color: #BA36A5;">N</span> = 10  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the number of intervals</span>

<span style="color: #BA36A5;">x</span> = np.linspace(a, b, N)
<span style="color: #BA36A5;">y</span> = np.cos(x)

<span style="color: #BA36A5;">t</span> = np.trapz(y, x)
<span style="color: #BA36A5;">s</span> = simps(y, x)
<span style="color: #BA36A5;">a</span> = np.sin(b) - np.sin(a)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'trapz = {0} ({1:%} error)'</span>.<span style="color: #006FE0;">format</span>(t, (t - a)/a))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'simps = {0} ({1:%} error)'</span>.<span style="color: #006FE0;">format</span>(s, (s - a)/a))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'analy = {0}'</span>.<span style="color: #006FE0;">format</span>(a))
</pre>
</div>

<p>
You can see the Simpson's method is more accurate than the trapezoid method.
</p>
</div>
</div>

<div id="outline-container-org9ac0edf" class="outline-3">
<h3 id="org9ac0edf"><span class="section-number-3">3.16.</span> Integrating functions in python</h3>
<div class="outline-text-3" id="text-3-16">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/01/integrating-functions-in-matlab/">Matlab post</a>
</p>

<p>
<b>Problem statement</b>
</p>

<p>
find the integral of a function f(x) from a to b i.e.
</p>

<p>
\[\int_a^b f(x) dx\]
</p>

<p>
In python we use numerical quadrature to achieve this with the scipy.integrate.quad command.
</p>

<p>
as a specific example, lets integrate
</p>

<p>
\[y=x^2\]
</p>

<p>
from x=0 to x=1. You should be able to work out that the answer is 1/3.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x**2

<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">err</span> = quad(integrand, 0, 1)
<span style="color: #0000FF;">print</span>(ans)
</pre>
</div>
</div>

<div id="outline-container-orgea5675c" class="outline-4">
<h4 id="orgea5675c"><span class="section-number-4">3.16.1.</span> double integrals</h4>
<div class="outline-text-4" id="text-3-16-1">
<p>
we use the scipy.integrate.dblquad command
</p>

<p>
Integrate \(f(x,y)=y sin(x)+x cos(y)\) over
</p>

<p>
\(\pi <= x <= 2\pi\)
</p>

<p>
\(0 <= y <= \pi\)
</p>

<p>
i.e.
</p>

<p>
\(\int_{x=\pi}^{2\pi}\int_{y=0}^{\pi}y sin(x)+x cos(y)dydx\)
</p>

<p>
The syntax in dblquad is a bit more complicated than in Matlab. We have to provide callable functions for the range of the y-variable. Here they are constants, so we create lambda functions that return the constants. Also, note that the order of arguments in the integrand is different than in Matlab.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> dblquad
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'y must be the first argument, and x the second.'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y * np.sin(x) + x * np.cos(y)

<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">err</span> = dblquad(integrand, np.pi, 2*np.pi,
                   <span style="color: #0000FF;">lambda</span> x: 0,
                   <span style="color: #0000FF;">lambda</span> x: np.pi)
<span style="color: #0000FF;">print</span> (ans)
</pre>
</div>

<p>
we use the tplquad command  to integrate \(f(x,y,z)=y sin(x)+z cos(x)\) over the region
</p>

<p>
\(0 <= x <= \pi\)
</p>

<p>
\(0 <= y <= 1\)
</p>

<p>
\(-1 <= z <= 1\)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> tplquad
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(z, y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y * np.sin(x) + z * np.cos(x)

<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">err</span> = tplquad(integrand,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  0, np.pi,  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">x limits</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  <span style="color: #0000FF;">lambda</span> x: 0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  <span style="color: #0000FF;">lambda</span> x: 1, <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">y limits</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  <span style="color: #0000FF;">lambda</span> x,y: -1,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  <span style="color: #0000FF;">lambda</span> x,y: 1) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">z limits</span>

<span style="color: #0000FF;">print</span> (ans)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga761bca" class="outline-4">
<h4 id="orga761bca"><span class="section-number-4">3.16.2.</span> Summary</h4>
<div class="outline-text-4" id="text-3-16-2">
<p>
scipy.integrate offers the same basic functionality as Matlab does. The syntax differs significantly for these simple examples, but the use of functions for the limits enables freedom to integrate over non-constant limits.
</p>
</div>
</div>
</div>
<div id="outline-container-org41625cf" class="outline-3">
<h3 id="org41625cf"><span class="section-number-3">3.17.</span> Integrating equations in python</h3>
<div class="outline-text-3" id="text-3-17">
<p>
A common need in engineering calculations is to integrate an equation over some range to determine the total change. For example, say we know the volumetric flow changes with time according to \(d\nu/dt = \alpha t\), where \(\alpha = 1\) L/min and we want to know how much liquid flows into a tank over 10 minutes if the volumetric flowrate is \(\nu_0 = 5\) L/min at \(t=0\). The answer to that question is the value of this integral: \(V = \int_0^{10} \nu_0 + \alpha t dt\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> scipy
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #BA36A5;">nu0</span> = 5     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">L/min</span>
<span style="color: #BA36A5;">alpha</span> = 1.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">L/min</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> nu0 + alpha * t

<span style="color: #BA36A5;">t0</span> = 0.0
<span style="color: #BA36A5;">tfinal</span> = 10.0
<span style="color: #BA36A5;">V</span>, <span style="color: #BA36A5;">estimated_error</span> = quad(integrand, t0, tfinal)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.2f} L flowed into the tank over 10 minutes'</span>.<span style="color: #006FE0;">format</span>(V))
</pre>
</div>

<p>
That is all there is too it!
</p>
</div>
</div>
<div id="outline-container-org976bbac" class="outline-3">
<h3 id="org976bbac"><span class="section-number-3">3.18.</span> Function integration by the Romberg method</h3>
<div class="outline-text-3" id="text-3-18">
<p>
An alternative to the scipy.integrate.quad function is the <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.romberg.html">Romberg method</a>. This method is not likely to be more accurate than quad, and it does not give you an error estimate.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad, romberg

<span style="color: #BA36A5;">a</span> = 0.0
<span style="color: #BA36A5;">b</span> = np.pi / 4.0

<span style="color: #0000FF;">print</span>(quad(np.sin, a, b))
<span style="color: #0000FF;">print</span>(romberg(np.sin, a, b))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c5d7f5" class="outline-3">
<h3 id="org4c5d7f5"><span class="section-number-3">3.19.</span> Symbolic math in python</h3>
<div class="outline-text-3" id="text-3-19">
<p>
 <a href="http://matlab.cheme.cmu.edu/2011/08/10/symbolic-math-in-matlab/">Matlab post</a>
Python has capability to do symbolic math through the sympy package.
</p>
</div>
<div id="outline-container-org5ca3f06" class="outline-4">
<h4 id="org5ca3f06"><span class="section-number-4">3.19.1.</span> Solve the quadratic equation</h4>
<div class="outline-text-4" id="text-3-19-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> solve, symbols, pprint

<span style="color: #BA36A5;">a</span>, <span style="color: #BA36A5;">b</span>, <span style="color: #BA36A5;">c</span>, <span style="color: #BA36A5;">x</span> = symbols(<span style="color: #008000;">'a,b,c,x'</span>)

<span style="color: #BA36A5;">f</span> = a*x**2 + b*x + c

<span style="color: #BA36A5;">solution</span> = solve(f, x)
<span style="color: #0000FF;">print</span>(solution)
pprint(solution)
</pre>
</div>

<p>
The solution you should recognize in the form of \(\frac{b \pm \sqrt{b^2 - 4 a c}}{2 a}\) although python does not print it this nicely!
</p>
</div>
</div>

<div id="outline-container-orgf901243" class="outline-4">
<h4 id="orgf901243"><span class="section-number-4">3.19.2.</span> differentiation</h4>
<div class="outline-text-4" id="text-3-19-2">
<p>
you might find this helpful!
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> diff

<span style="color: #0000FF;">print</span>(diff(f, x))
<span style="color: #0000FF;">print</span>(diff(f, x, 2))

<span style="color: #0000FF;">print</span>(diff(f, a))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga2facbb" class="outline-4">
<h4 id="orga2facbb"><span class="section-number-4">3.19.3.</span> integration</h4>
<div class="outline-text-4" id="text-3-19-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> integrate

<span style="color: #0000FF;">print</span>(integrate(f, x))          <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">indefinite integral</span>
<span style="color: #0000FF;">print</span>(integrate(f, (x, 0, 1)))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">definite integral from x=0..1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a1364a" class="outline-4">
<h4 id="org9a1364a"><span class="section-number-4">3.19.4.</span> Analytically solve a simple ODE</h4>
<div class="outline-text-4" id="text-3-19-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Function, Symbol, dsolve
<span style="color: #BA36A5;">f</span> = Function(<span style="color: #008000;">'f'</span>)
<span style="color: #BA36A5;">x</span> = Symbol(<span style="color: #008000;">'x'</span>)
<span style="color: #BA36A5;">fprime</span> = f(x).diff(x) - f(x) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f' = f(x)</span>

<span style="color: #BA36A5;">y</span> = dsolve(fprime, f(x))

<span style="color: #0000FF;">print</span>(y)
<span style="color: #0000FF;">print</span>(y.subs(x,4))
<span style="color: #0000FF;">print</span>([y.subs(x, X) <span style="color: #0000FF;">for</span> X <span style="color: #0000FF;">in</span> [0, 0.5, 1]]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">multiple values</span>
</pre>
</div>

<p>
It is not clear you can solve the initial value problem to get C1.
</p>

<p>
The symbolic math in sympy is pretty good. It is not up to the capability of Maple or Mathematica, (but neither is Matlab) but it continues to be developed, and could be helpful in some situations.
</p>
</div>
</div>
</div>

<div id="outline-container-org4a3d6e7" class="outline-3">
<h3 id="org4a3d6e7"><span class="section-number-3">3.20.</span> Is your ice cream float bigger than mine</h3>
<div class="outline-text-3" id="text-3-20">
<p>
Float numbers (i.e. the ones with decimals) cannot be perfectly represented in a computer. This can lead to some artifacts when you have to compare float numbers that on paper should be the same, but in silico are not. Let us look at some examples. In this example, we do some simple math that should result in an answer of 1, and then see if the answer is "equal" to one.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(3.0 * (1.0/3.0))
<span style="color: #0000FF;">print</span>(1.0 == 3.0 * (1.0/3.0))
</pre>
</div>

<p>
Everything looks fine. Now, consider this example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(49.0 * (1.0/49.0))
<span style="color: #0000FF;">print</span>(1.0 == 49.0 * (1.0/49.0))
</pre>
</div>

<p>
The first line shows the result is not 1.0, and the equality fails!
You can see here why the equality statement fails. We will print the two numbers to sixteen decimal places.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.16f}'</span>.<span style="color: #006FE0;">format</span>(49.0 * (1.0 / 49.0) ))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:1.16f}'</span>.<span style="color: #006FE0;">format</span>(1.0))
<span style="color: #0000FF;">print</span>(1 - 49.0 * (1.0 / 49.0))
</pre>
</div>

<p>
The two numbers actually are not equal to each other because of float math. They are <i>very, very</i> close to each other, but not the same.
</p>

<p>
This leads to the idea of asking if two numbers are equal to each other within some tolerance. The question of what tolerance to use requires thought. Should it be an absolute tolerance? a relative tolerance? How large should the tolerance be? We will use the distance between 1 and the nearest floating point number (this is <code>eps</code> in Matlab). <code>numpy</code> can tell us this number with the <code>np.spacing</code> command.
</p>

<p>
Below, we implement a comparison function from <a href="http://dx.doi.org/10.1107/S010876730302186X">doi:10.1107/S010876730302186X</a> that allows comparisons with tolerance.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Implemented from Acta Crystallographica A60, 1-6 (2003). doi:10.1107/S010876730302186X</span>

<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.spacing(1))

<span style="color: #0000FF;">def</span> <span style="color: #006699;">feq</span>(x, y, epsilon):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x == y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">not</span>((x &lt; (y - epsilon)) <span style="color: #0000FF;">or</span> (y &lt; (x - epsilon)))

<span style="color: #0000FF;">print</span>(feq(1.0, 49.0 * (1.0/49.0), np.spacing(1)))

</pre>
</div>

<p>
For completeness, here are the other float comparison operators from that paper. We also show a few examples.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">flt</span>(x, y, epsilon):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &lt; y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x &lt; (y - epsilon)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fgt</span>(x, y, epsilon):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &gt; y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y &lt; (x - epsilon)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fle</span>(x, y, epsilon):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &lt;= y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">not</span>(y &lt; (x - epsilon))

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fge</span>(x, y, epsilon):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &gt;= y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">not</span>(x &lt; (y - epsilon))

<span style="color: #0000FF;">print</span>(fge(1.0, 49.0 * (1.0/49.0), np.spacing(1)))
<span style="color: #0000FF;">print</span>(fle(1.0, 49.0 * (1.0/49.0), np.spacing(1)))

<span style="color: #0000FF;">print</span>(fgt(1.0 + np.spacing(1), 49.0 * (1.0/49.0), np.spacing(1)))
<span style="color: #0000FF;">print</span>(flt(1.0 - 2 * np.spacing(1), 49.0 * (1.0/49.0), np.spacing(1)))
</pre>
</div>

<p>
As you can see, float comparisons can be tricky. You have to give a lot of thought to how to make the comparisons, and the functions shown above are not the only way to do it. You need to build in testing to make sure your comparisons are doing what you want.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcd7a5aa" class="outline-2">
<h2 id="orgcd7a5aa"><span class="section-number-2">4.</span> Linear algebra</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org9778c9c" class="outline-3">
<h3 id="org9778c9c"><span class="section-number-3">4.1.</span> Potential gotchas in linear algebra in numpy</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Numpy has some gotcha features for linear algebra purists. The first is that a 1d array is neither a row, nor a column vector. That is, \(a\) = \(a^T\) if \(a\) is a 1d array. That means you can take the dot product of \(a\) with itself, without transposing the second argument. This would not be allowed in Matlab.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">a</span> = np.array([0, 1, 2])
<span style="color: #0000FF;">print</span>(a.shape)
<span style="color: #0000FF;">print</span>(a)
<span style="color: #0000FF;">print</span>(a.T)


<span style="color: #0000FF;">print</span>(np.dot(a, a))
<span style="color: #0000FF;">print</span>(np.dot(a, a.T))
</pre>
</div>

<p>
Compare the syntax to the new Python 3.5 syntax:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(a @ a)
</pre>
</div>

<p>
Compare the previous behavior with this 2d array. In this case, you cannot take the dot product of \(b\) with itself, because the dimensions are incompatible. You must transpose the second argument to make it dimensionally consistent. Also, the result of the dot product is not a simple scalar, but a 1 &times; 1 array.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">b</span> = np.array([[0, 1, 2]])
<span style="color: #0000FF;">print</span>(b.shape)
<span style="color: #0000FF;">print</span>(b)
<span style="color: #0000FF;">print</span>(b.T)

<span style="color: #0000FF;">print</span>(np.dot(b, b))    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is not ok, the dimensions are wrong.</span>
<span style="color: #0000FF;">print</span>(np.dot(b, b.T))
<span style="color: #0000FF;">print</span>(np.dot(b, b.T).shape)
</pre>
</div>

<p>
Try to figure this one out! x is a column vector, and y is a 1d vector. Just by adding them you get a 2d array.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">x</span> = np.array([[2], [4], [6], [8]])
<span style="color: #BA36A5;">y</span> = np.array([1, 1, 1, 1, 1, 2])
<span style="color: #0000FF;">print</span>(x + y)
</pre>
</div>

<p>
Or this crazy alternative way to do the same thing.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">x</span> = np.array([2, 4, 6, 8])
<span style="color: #BA36A5;">y</span> = np.array([1, 1, 1, 1, 1, 1, 2])

<span style="color: #0000FF;">print</span>(x[:, np.newaxis] + y)
</pre>
</div>

<p>
In the next example,  we have a 3 element vector and a 4 element vector. We convert \(b\) to a 2D array with np.newaxis, and compute the outer product of the two arrays. The result is a 4 &times; 3 array.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = np.array([1, 2, 3])
<span style="color: #BA36A5;">b</span> = np.array([10, 20, 30, 40])

<span style="color: #0000FF;">print</span>(a * b[:, np.newaxis])
</pre>
</div>

<p>
These concepts are known in numpy as array broadcasting. See <a href="http://www.scipy.org/EricsBroadcastingDoc">http://www.scipy.org/EricsBroadcastingDoc</a> and <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html</a> for more details.
</p>

<p>
These are points to keep in mind, as the operations do not strictly follow the conventions of linear algebra, and may be confusing at times.
</p>
</div>
</div>

<div id="outline-container-orgd5057e3" class="outline-3">
<h3 id="orgd5057e3"><span class="section-number-3">4.2.</span> Solving linear equations</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Given these equations, find [x1, x2, x3]
</p>
\begin{eqnarray}
x_1 - x_2 + x_3 &=& 0 \\
10 x_2 + 25 x_3 &=& 90 \\
20 x_1 + 10 x_2 &=& 80
\end{eqnarray}

<p>
reference: Kreysig, Advanced Engineering Mathematics, 9th ed. Sec. 7.3
</p>

<p>
When solving linear equations, we can represent them in matrix form. The we simply use <code>numpy.linalg.solve</code> to get the solution.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">A</span> = np.array([[1, -1, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [0, 10, 25],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [20, 10, 0]])

<span style="color: #BA36A5;">b</span> = np.array([0, 90, 80])

<span style="color: #BA36A5;">x</span> = np.linalg.solve(A, b)
<span style="color: #0000FF;">print</span>(x)
<span style="color: #0000FF;">print</span>(np.dot(A,x))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Let us confirm the solution.</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this shows one element is not equal because of float tolerance</span>
<span style="color: #0000FF;">print</span>(np.dot(A,x) == b)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">here we use a tolerance comparison to show the differences is less</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">than a defined tolerance.</span>
<span style="color: #BA36A5;">TOLERANCE</span> = 1e-12
<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">abs</span>((np.dot(A, x) - b)) &lt;= TOLERANCE)
</pre>
</div>

<p>
It can be useful to confirm there should be a solution, e.g. that the equations are all independent. The matrix rank will tell us that. Note that numpy:rank does not give you the matrix rank, but rather the number of dimensions of the array. We compute the rank by computing the number of singular values of the matrix that are greater than zero, within a prescribed tolerance. We use the <code>numpy.linalg.svd</code> function for that. In Matlab you would use the rref command to see if there are any rows that are all zero, but this command does not exist in numpy. That command does not have practical use in numerical linear algebra and has not been implemented.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">A</span> = np.array([[1, -1, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [0, 10, 25],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [20, 10, 0]])

<span style="color: #BA36A5;">b</span> = np.array([0, 90, 80])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">determine number of independent rows in A we get the singular values</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">and count the number greater than 0.</span>
<span style="color: #BA36A5;">TOLERANCE</span> = 1e-12
<span style="color: #BA36A5;">u</span>, <span style="color: #BA36A5;">s</span>, <span style="color: #BA36A5;">v</span> = np.linalg.svd(A)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Singular values: {0}'</span>.<span style="color: #006FE0;">format</span>(s))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'# of independent rows: {0}'</span>.<span style="color: #006FE0;">format</span>(np.<span style="color: #006FE0;">sum</span>(np.<span style="color: #006FE0;">abs</span>(s) &gt; TOLERANCE)))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">to illustrate a case where there are only 2 independent rows</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">consider this case where row3 = 2*row2.</span>
<span style="color: #BA36A5;">A</span> = np.array([[1, -1, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [0, 10, 25],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [0, 20, 50]])

<span style="color: #BA36A5;">u</span>, <span style="color: #BA36A5;">s</span>, <span style="color: #BA36A5;">v</span> = np.linalg.svd(A)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Singular values: {0}'</span>.<span style="color: #006FE0;">format</span>(s))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'# of independent rows: {0}'</span>.<span style="color: #006FE0;">format</span>(np.<span style="color: #006FE0;">sum</span>(np.<span style="color: #006FE0;">abs</span>(s) &gt; TOLERANCE)))
</pre>
</div>

<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/01/solving-linear-equations/">Matlab comparison</a>
</p>
</div>
</div>
<div id="outline-container-orge163aae" class="outline-3">
<h3 id="orge163aae"><span class="section-number-3">4.3.</span> Rules for transposition</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<a href="transpose">transpose</a>
<a href="http://matlab.cheme.cmu.edu/2011/08/01/illustrating-matrix-transpose-rules-in-matrix-multiplication/">Matlab comparison</a>
</p>

<p>
Here are the four rules for matrix multiplication and transposition
</p>

<ol class="org-ol">
<li>\((\mathbf{A}^T)^T = \mathbf{A}\)</li>

<li>\((\mathbf{A}+\mathbf{B})^T = \mathbf{A}^T+\mathbf{B}^T\)</li>

<li>\((\mathit{c}\mathbf{A})^T = \mathit{c}\mathbf{A}^T\)</li>

<li>\((\mathbf{AB})^T = \mathbf{B}^T\mathbf{A}^T\)</li>
</ol>

<p>
reference: Chapter 7.2 in Advanced Engineering Mathematics, 9th edition.
by E. Kreyszig.
</p>
</div>

<div id="outline-container-org32abd6a" class="outline-4">
<h4 id="org32abd6a"><span class="section-number-4">4.3.1.</span> The transpose in Python</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
There are two ways to get the transpose of a matrix: with a notation, and
with a function.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">A</span> = np.array([[5, -8, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [4, 0, 0]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">function</span>
<span style="color: #0000FF;">print</span>(np.transpose(A))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">notation</span>
<span style="color: #0000FF;">print</span>(A.T)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga2c49b8" class="outline-4">
<h4 id="orga2c49b8"><span class="section-number-4">4.3.2.</span> Rule 1</h4>
<div class="outline-text-4" id="text-4-3-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[5, -8, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [4, 0, 0]])

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">all</span>(A == (A.T).T))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd49134" class="outline-4">
<h4 id="orgbd49134"><span class="section-number-4">4.3.3.</span> Rule 2</h4>
<div class="outline-text-4" id="text-4-3-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">A</span> = np.array([[5, -8, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [4, 0, 0]])

<span style="color: #BA36A5;">B</span> = np.array([[3, 4, 5], [1, 2,3]])

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">all</span>( A.T + B.T == (A + B).T))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8e165b4" class="outline-4">
<h4 id="org8e165b4"><span class="section-number-4">4.3.4.</span> Rule 3</h4>
<div class="outline-text-4" id="text-4-3-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">A</span> = np.array([[5, -8, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [4, 0, 0]])

<span style="color: #BA36A5;">c</span> = 2.1

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">all</span>((c*A).T == c*A.T))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8dfad0b" class="outline-4">
<h4 id="org8dfad0b"><span class="section-number-4">4.3.5.</span> Rule 4</h4>
<div class="outline-text-4" id="text-4-3-5">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">A</span> = np.array([[5, -8, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [4, 0, 0]])

<span style="color: #BA36A5;">B</span> = np.array([[0, 2],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [1, 2],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [6, 7]])

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">all</span>(np.dot(A, B).T == np.dot(B.T, A.T)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaec3f14" class="outline-4">
<h4 id="orgaec3f14"><span class="section-number-4">4.3.6.</span> Summary</h4>
<div class="outline-text-4" id="text-4-3-6">
<p>
That wraps up showing numerically the transpose rules work for these examples.
</p>
</div>
</div>
</div>
<div id="outline-container-orgaaa61e1" class="outline-3">
<h3 id="orgaaa61e1"><span class="section-number-3">4.4.</span> Sums products and linear algebra notation - avoiding loops where possible</h3>
<div class="outline-text-3" id="text-4-4">
<p>
<a href="http://matlab.cheme.cmu.edu/2012/01/03/sums-products-and-linear-algebra-notation-avoiding-loops-where-possible/">Matlab comparison</a>
</p>

<p>
Today we examine some methods of linear algebra that allow us to
avoid writing explicit loops in Matlab for some kinds of
mathematical operations.
</p>

<p>
Consider the operation on two vectors \(\bf{a}\)
and \(\bf{b}\).
</p>


<p>
\[y=\sum\limits_{i=1}^n a_ib_i\]
</p>

<p>
a = [1 2 3 4 5]
</p>

<p>
b = [3 6 8 9 10]
</p>
</div>

<div id="outline-container-orge48f2a6" class="outline-4">
<h4 id="orge48f2a6"><span class="section-number-4">4.4.1.</span> Old-fashioned way with a loop</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
We can compute this with a loop, where you initialize y, and then
 add the product of the ith elements of a and b to y in each
iteration of the loop. This is known to be slow for large vectors
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [1, 2, 3, 4, 5]
<span style="color: #BA36A5;">b</span> = [3, 6, 8, 9, 10]

<span style="color: #006FE0;">sum</span> = 0
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(a)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #006FE0;">sum</span> = <span style="color: #006FE0;">sum</span> + a[i] * b[i]
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sum</span>)
</pre>
</div>

<p>
This is an old fashioned style of coding. A more modern, pythonic approach is:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [1, 2, 3, 4, 5]
<span style="color: #BA36A5;">b</span> = [3, 6, 8, 9, 10]

<span style="color: #006FE0;">sum</span> = 0
<span style="color: #0000FF;">for</span> x,y <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(a,b):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #006FE0;">sum</span> += x * y
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sum</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga598be0" class="outline-4">
<h4 id="orga598be0"><span class="section-number-4">4.4.2.</span> The numpy approach</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
The most compact method is to use the  methods in numpy.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">a</span> = np.array([1, 2, 3, 4, 5])
<span style="color: #BA36A5;">b</span> = np.array([3, 6, 8, 9, 10])

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(a * b))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9fdb04f" class="outline-4">
<h4 id="org9fdb04f"><span class="section-number-4">4.4.3.</span> Matrix algebra approach.</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
The operation defined above is actually a dot product. We an directly compute the dot product in numpy. Note that with 1d arrays, python knows what to do and does not require any transpose operations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">a</span> = np.array([1, 2, 3, 4, 5])
<span style="color: #BA36A5;">b</span> = np.array([3, 6, 8, 9, 10])

<span style="color: #0000FF;">print</span>(np.dot(a, b))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8c3be2" class="outline-4">
<h4 id="orga8c3be2"><span class="section-number-4">4.4.4.</span> Another example</h4>
<div class="outline-text-4" id="text-4-4-4">
<p>
Consider \(y = \sum\limits_{i=1}^n w_i x_i^2\). This operation is like a weighted sum of squares.
The old-fashioned way to do this is with a loop.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">w</span> = [0.1, 0.25, 0.12, 0.45, 0.98];
<span style="color: #BA36A5;">x</span> = [9, 7, 11, 12, 8];
<span style="color: #BA36A5;">y</span> = 0
<span style="color: #0000FF;">for</span> wi, xi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(w,x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>  <span style="color: #BA36A5;">y</span> += wi * xi**2
<span style="color: #0000FF;">print</span>(y)
</pre>
</div>

<p>
Compare this to the more modern numpy approach.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">w</span> = np.array([0.1, 0.25, 0.12, 0.45, 0.98])
<span style="color: #BA36A5;">x</span> = np.array([9, 7, 11, 12, 8])
<span style="color: #BA36A5;">y</span> = np.<span style="color: #006FE0;">sum</span>(w * x**2)
<span style="color: #0000FF;">print</span>(y)
</pre>
</div>

<p>
We can also express this in matrix algebra form. The operation is equivalent to \(y = \vec{x} \cdot D_w \cdot \vec{x}^T\) where \(D_w\) is a diagonal matrix with the weights on the diagonal.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">w</span> = np.array([0.1, 0.25, 0.12, 0.45, 0.98])
<span style="color: #BA36A5;">x</span> = np.array([9, 7, 11, 12, 8])
<span style="color: #BA36A5;">y</span> = np.dot(x, np.dot(np.diag(w), x))
<span style="color: #0000FF;">print</span>(y)
</pre>
</div>

<p>
This last form avoids explicit loops and sums, and relies on fast linear algebra routines.
</p>
</div>
</div>

<div id="outline-container-org9ed9f38" class="outline-4">
<h4 id="org9ed9f38"><span class="section-number-4">4.4.5.</span> Last example</h4>
<div class="outline-text-4" id="text-4-4-5">
<p>
Consider the sum of the product of three vectors. Let \(y = \sum\limits_{i=1}^n w_i x_i y_i\). This is like a weighted sum of products.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">w</span> = np.array([0.1, 0.25, 0.12, 0.45, 0.98])
<span style="color: #BA36A5;">x</span> = np.array([9, 7, 11, 12, 8])
<span style="color: #BA36A5;">y</span> = np.array([2, 5, 3, 8, 0])

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(w * x * y))
<span style="color: #0000FF;">print</span>(np.dot(w, np.dot(np.diag(x), y)))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgae6f280" class="outline-4">
<h4 id="orgae6f280"><span class="section-number-4">4.4.6.</span> Summary</h4>
<div class="outline-text-4" id="text-4-4-6">
<p>
We showed examples of the following equalities between traditional
sum notations and linear algebra
</p>


<p>
\[\bf{a}\bf{b}=\sum\limits_{i=1}^n a_ib_i\]
</p>

<p>
\[\bf{x}\bf{D_w}\bf{x^T}=\sum\limits_{i=1}^n w_ix_i^2\]
</p>


<p>
\[\bf{x}\bf{D_w}\bf{y^T}=\sum\limits_{i=1}^n w_i x_i y_i\]
</p>

<p>
These relationships enable one to write the sums as a single line of
python code, which utilizes fast linear algebra subroutines, avoids
the construction of slow loops, and reduces the opportunity for
errors in the code. Admittedly, it introduces the opportunity for
new types of errors, like using the wrong relationship, or linear
algebra errors due to matrix size mismatches.
</p>
</div>
</div>
</div>
<div id="outline-container-org675bb53" class="outline-3">
<h3 id="org675bb53"><span class="section-number-3">4.5.</span> Determining linear independence of a set of vectors</h3>
<div class="outline-text-3" id="text-4-5">
<p>
 <a href="http://matlab.cheme.cmu.edu/2011/08/02/determining-linear-independence-of-a-set-of-vectors/">Matlab post</a>
Occasionally we have a set of vectors and we need to determine whether the vectors are linearly independent of each other. This may be necessary to determine if the vectors form a basis, or to determine how many independent equations there are, or to determine how many independent reactions there are.
</p>

<p>
Reference: Kreysig, Advanced Engineering Mathematics, sec. 7.4
</p>

<p>
Matlab provides a rank command which gives you the number of singular values greater than some tolerance. The numpy.rank function, unfortunately, does not do that. It returns the number of dimensions in the array. We will just compute the rank from singular value decomposition.
</p>

<p>
The default tolerance used in Matlab is max(size(A))*eps(norm(A)). Let us break that down. eps(norm(A)) is the positive distance from abs(X) to the next larger in magnitude floating point number of the same precision as X. Basically, the smallest significant number. We multiply that by the size of A, and take the largest number. We have to use some judgment in what the tolerance is, and what "zero" means.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">v1</span> = [6, 0, 3, 1, 4, 2];
<span style="color: #BA36A5;">v2</span> = [0, -1, 2, 7, 0, 5];
<span style="color: #BA36A5;">v3</span> = [12, 3, 0, -19, 8, -11];

<span style="color: #BA36A5;">A</span> = np.row_stack([v1, v2, v3])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">matlab definition</span>
<span style="color: #BA36A5;">eps</span> = np.finfo(np.linalg.norm(A).dtype).eps
<span style="color: #BA36A5;">TOLERANCE</span> = <span style="color: #006FE0;">max</span>(eps * np.array(A.shape))

<span style="color: #BA36A5;">U</span>, <span style="color: #BA36A5;">s</span>, <span style="color: #BA36A5;">V</span> = np.linalg.svd(A)
<span style="color: #0000FF;">print</span>(s)
<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(s &gt; TOLERANCE))

<span style="color: #BA36A5;">TOLERANCE</span> = 1e-14
<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(s &gt; TOLERANCE))
</pre>
</div>

<p>
You can see if you choose too small a TOLERANCE, nothing looks like zero. the result with TOLERANCE=1e-14 suggests the rows are not linearly independent. Let us show that one row can be expressed as a linear combination of the other rows.
</p>

<p>
The number of rows is greater than the rank, so these vectors are not
independent. Let's demonstrate that one vector can be defined as a linear
combination of the other two vectors. Mathematically we represent this
as:
</p>

<p>
\(x_1 \mathit{v1} + x_2 \mathit{v2} = v3\)
</p>

<p>
or
</p>

<p>
\([x_1 x_2][v1; v2] = v3\)
</p>

<p>
This is not the usual linear algebra form of Ax = b. To get there, we
transpose each side of the equation to get:
</p>

<p>
[v1.T v2.T][x_1; x_2] = v3.T
</p>

<p>
which is the form Ax = b. We solve it in a least-squares sense.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">A</span> = np.column_stack([v1, v2])
<span style="color: #BA36A5;">x</span> = np.linalg.lstsq(A, v3)
<span style="color: #0000FF;">print</span>(x[0])
</pre>
</div>

<p>
This shows that v3 = 2*v1 - 3*v2
</p>
</div>

<div id="outline-container-org802948f" class="outline-4">
<h4 id="org802948f"><span class="section-number-4">4.5.1.</span> another example</h4>
<div class="outline-text-4" id="text-4-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">Problem set 7.4 #17</span>
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">v1</span> = [0.2, 1.2, 5.3, 2.8, 1.6]
<span style="color: #BA36A5;">v2</span> = [4.3, 3.4, 0.9, 2.0, -4.3]

<span style="color: #BA36A5;">A</span> = np.row_stack([v1, v2])
<span style="color: #BA36A5;">U</span>, <span style="color: #BA36A5;">s</span>, <span style="color: #BA36A5;">V</span> = np.linalg.svd(A)
<span style="color: #0000FF;">print</span>(s)
</pre>
</div>

<p>
You can tell by inspection the rank is 2 because there are no near-zero singular values.
</p>
</div>
</div>

<div id="outline-container-org08e604f" class="outline-4">
<h4 id="org08e604f"><span class="section-number-4">4.5.2.</span> Near deficient rank</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
the rank command roughly works in the following way: the matrix is converted to a reduced row echelon form, and then the number of rows that are not all equal to zero are counted. Matlab uses a tolerance to determine what is equal to zero. If there is uncertainty in the numbers, you may have to define what zero is, e.g. if the absolute value of a number is less than 1e-5, you may consider that close enough to be zero. The default tolerance is usually very small, of order 1e-15. If we believe that any number less than 1e-5 is practically equivalent to zero, we can use that information to compute the rank like this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = [[1, 2, 3],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[0, 2, 3],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[0, 0, 1e-6]]

<span style="color: #BA36A5;">U</span>, <span style="color: #BA36A5;">s</span>, <span style="color: #BA36A5;">V</span> = np.linalg.svd(A)
<span style="color: #0000FF;">print</span>(s)
<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(np.<span style="color: #006FE0;">abs</span>(s) &gt; 1e-15))
<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(np.<span style="color: #006FE0;">abs</span>(s) &gt; 1e-5))
</pre>
</div>
</div>
</div>

<div id="outline-container-org00fba43" class="outline-4">
<h4 id="org00fba43"><span class="section-number-4">4.5.3.</span> Application to independent chemical reactions.</h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
reference: Exercise 2.4 in Chemical Reactor Analysis and Design Fundamentals by Rawlings and Ekerdt.
</p>

<p>
The following reactions are proposed in the hydrogenation of bromine:
</p>

<p>
Let this be our species vector: v = [H2 H Br2 Br HBr].T
</p>

<p>
the reactions are then defined by M*v where M is a stoichometric matrix in which each row represents a reaction with negative stoichiometric coefficients for reactants, and positive stoichiometric coefficients for products. A stoichiometric coefficient of 0 is used for species not participating in the reaction.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #8D8D84;">#    </span><span style="color: #8D8D84; font-style: italic;">[H2  H Br2 Br HBr]</span>
<span style="color: #BA36A5;">M</span> = [[-1,  0, -1,  0,  2],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H2 + Br2 == 2HBR</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[ 0,  0, -1,  2,  0],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Br2 == 2Br</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[-1,  1,  0, -1,  1],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Br + H2 == HBr + H</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[ 0, -1, -1,  1,  1],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H + Br2 == HBr + Br</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[ 1, -1,  0,  1,  -1], <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H + HBr == H2 + Br</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[ 0,  0,  1, -2,  0]]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">2Br == Br2</span>

<span style="color: #BA36A5;">U</span>, <span style="color: #BA36A5;">s</span>, <span style="color: #BA36A5;">V</span> = np.linalg.svd(M)
<span style="color: #0000FF;">print</span>(s)
<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(np.<span style="color: #006FE0;">abs</span>(s) &gt; 1e-15))

<span style="color: #0000FF;">import</span> sympy
M = sympy.Matrix(M)
<span style="color: #BA36A5;">reduced_form</span>, <span style="color: #BA36A5;">inds</span> = M.rref()

<span style="color: #0000FF;">print</span>(reduced_form)

labels = [<span style="color: #008000;">'H2'</span>,  <span style="color: #008000;">'H'</span>, <span style="color: #008000;">'Br2'</span>, <span style="color: #008000;">'Br'</span>, <span style="color: #008000;">'HBr'</span>]
<span style="color: #0000FF;">for</span> row <span style="color: #0000FF;">in</span> reduced_form.tolist():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   s = <span style="color: #008000;">'0 = '</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> nu,species <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(row,labels):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> nu != 0:

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   s += <span style="color: #008000;">' {0:+d}{1}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">int</span>(nu), species)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> s != <span style="color: #008000;">'0 = '</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(s)
</pre>
</div>

<p>
6 reactions are given, but the rank of the matrix is only 3. so there
are only three independent reactions. You can see that reaction 6 is just
the opposite of reaction 2, so it is clearly not independent. Also,
reactions 3 and 5 are just the reverse of each other, so one of them can
also be eliminated. finally, reaction 4 is equal to reaction 1 minus
reaction 3.
</p>

<p>
There are many possible independent reactions. In the code above, we use sympy to put the matrix into reduced row echelon form, which enables us to identify three independent reactions, and shows that three rows are all zero, i.e. they are not independent of the other three reactions. The choice of independent reactions is not unique.
</p>
</div>
</div>
</div>

<div id="outline-container-org1f389e0" class="outline-3">
<h3 id="org1f389e0"><span class="section-number-3">4.6.</span> Reduced row echelon form</h3>
<div class="outline-text-3" id="text-4-6">
<p>
There is a nice discussion <a href="http://numpy-discussion.10968.n7.nabble.com/Reduced-row-echelon-form-td16486.html">here</a> on why there is not a rref command in numpy, primarily because one rarely actually needs it in linear algebra. Still, it is so often taught, and it helps visually see what the rank of a matrix is that I wanted to examine ways to get it.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Matrix

<span style="color: #BA36A5;">A</span> = np.array([[3, 2, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [2, 1, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [6, 2, 4]])

<span style="color: #BA36A5;">rA</span>, <span style="color: #BA36A5;">pivots</span> =  Matrix(A).rref()
<span style="color: #0000FF;">print</span>(rA)
</pre>
</div>

<p>
This rref form is a bit different than you might get from doing it by hand. The rows are also normalized.
</p>

<p>
Based on this, we conclude the \(A\) matrix has a rank of 2 since one row of the reduced form contains all zeros. That means the determinant will be zero, and it should not be possible to compute the inverse of the matrix, and there should be no solution to linear equations of \(A x = b\). Let us check it out.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> Matrix

<span style="color: #BA36A5;">A</span> = np.array([[3, 2, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [2, 1, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [6, 2, 4]])

<span style="color: #0000FF;">print</span>(np.linalg.det(A))
<span style="color: #0000FF;">print</span>(np.linalg.inv(A))

<span style="color: #BA36A5;">b</span> = np.array([3, 0, 6])

<span style="color: #0000FF;">print</span>(np.linalg.solve(A, b))
</pre>
</div>

<p>
There are "solutions", but there are a couple of red flags that should catch your eye. First, the determinant is within machine precision of zero. Second the elements of the inverse are all "large". Third, the solutions are all "large". All of these are indications of or artifacts of numerical imprecision.
</p>
</div>
</div>

<div id="outline-container-orgcbe7079" class="outline-3">
<h3 id="orgcbe7079"><span class="section-number-3">4.7.</span> Computing determinants from matrix decompositions</h3>
<div class="outline-text-3" id="text-4-7">
<p>
<a href="LU decomposition,determinant">LU decomposition,determinant</a>
There are a few properties of a matrix that can make it easy to compute determinants.
</p>

<ol class="org-ol">
<li>The determinant of a triangular matrix is the product of the elements on the diagonal.</li>
<li>The determinant of a permutation matrix is (-1)**n where n is the number of permutations. Recall a permutation matrix is a matrix with a one in each row, and column, and zeros everywhere else.</li>
<li>The determinant of a product of matrices is equal to the product of the determinant of the matrices.</li>
</ol>

<p>
The LU decomposition computes three matrices such that \(A = P L U\). Thus, \(\det A = \det P \det L \det U\). \(L\) and \(U\) are triangular, so we just need to compute the product of the diagonals. \(P\) is not triangular, but if the elements of the diagonal are not 1, they will be zero, and then there has been a swap. So we simply subtract the sum of the diagonal from the length of the diagonal and then subtract 1 to get the number of swaps.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.linalg <span style="color: #0000FF;">import</span> lu

<span style="color: #BA36A5;">A</span> = np.array([[6, 2, 3],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [1, 1, 1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [0, 4, 9]])

<span style="color: #BA36A5;">P</span>, <span style="color: #BA36A5;">L</span>, <span style="color: #BA36A5;">U</span> = lu(A)

<span style="color: #BA36A5;">nswaps</span> = <span style="color: #006FE0;">len</span>(np.diag(P)) - np.<span style="color: #006FE0;">sum</span>(np.diag(P)) - 1

<span style="color: #BA36A5;">detP</span> = (-1)**nswaps
<span style="color: #BA36A5;">detL</span> =  np.prod(np.diag(L))
<span style="color: #BA36A5;">detU</span> = np.prod(np.diag(U))

<span style="color: #0000FF;">print</span>(detP * detL * detU)

<span style="color: #0000FF;">print</span>(np.linalg.det(A))
</pre>
</div>

<p>
According to the numpy documentation, a method similar to this is used to compute the determinant.
</p>
</div>
</div>

<div id="outline-container-orgb107968" class="outline-3">
<h3 id="orgb107968"><span class="section-number-3">4.8.</span> Calling lapack directly from scipy</h3>
<div class="outline-text-3" id="text-4-8">
<p>
If the built in linear algebra functions in numpy and scipy do not meet your needs, it is often possible to directly call lapack functions. Here we call a function to solve a set of complex linear equations. The lapack function for this is ZGBSV. The description of this function (<a href="http://linux.die.net/man/l/zgbsv">http://linux.die.net/man/l/zgbsv</a>) is:
</p>

<p>
ZGBSV computes the solution to a complex system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.
</p>

<p>
The python signature is (<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgbsv.html#scipy.linalg.lapack.zgbsv">http://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgbsv.html#scipy.linalg.lapack.zgbsv</a>):
</p>

<p>
lub,piv,x,info = zgbsv(kl,ku,ab,b,[overwrite_ab,overwrite_b])
</p>

<p>
We will look at an example from <a href="http://www.nag.com/lapack-ex/node22.html">http://www.nag.com/lapack-ex/node22.html</a>.
</p>

<p>
We solve \(A x = b\) with
</p>

\begin{equation}
A = \left(
       \begin{array}{cccc}
          -1.65 + 2.26 i & -2.05 - 0.85 i &  0.97 - 2.84 i &       0        \\
                  6.30 i & -1.48 - 1.75 i & -3.99 + 4.01 i &  0.59 - 0.48 i \\
                0        & -0.77 + 2.83 i & -1.06 + 1.94 i &  3.33 - 1.04 i \\
                0        &       0        &  4.48 - 1.09 i & -0.46 - 1.72 i
       \end{array}
       \right)
\end{equation}

<p>
and
</p>

\begin{equation}
b = \left(
       \begin{array}{cc}
           -1.06 + 21.50 i \\
          -22.72 - 53.90 i \\
           28.24 - 38.60 i \\
          -34.56 + 16.73 i
       \end{array}
       \right).
\end{equation}

<p>
The \(A\) matrix has one lower diagonal (kl = 1) and two upper diagonals (ku = 2), four equations (n = 4) and one right-hand side.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> scipy.linalg.lapack <span style="color: #0000FF;">as</span> la

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">http://www.nag.com/lapack-ex/node22.html</span>
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">A</span> = np.array([[-1.65 + 2.26j, -2.05 - 0.85j,  0.97 - 2.84j,  0.0         ],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [6.30j,         -1.48 - 1.75j, -3.99 + 4.01j,  0.59 - 0.48j],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [0.0,           -0.77 + 2.83j, -1.06 + 1.94j,  3.33 - 1.04j],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [0.0,            0.0,           4.48 - 1.09j, -0.46 - 1.72j]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">construction of Ab is tricky.  Fortran indexing starts at 1, not</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">0. This code is based on the definition of Ab at</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">http://linux.die.net/man/l/zgbsv. First, we create the Fortran</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">indices based on the loops, and then subtract one from them to index</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the numpy arrays.</span>
<span style="color: #BA36A5;">Ab</span> = np.zeros((5,4),dtype=np.<span style="color: #006FE0;">complex</span>)
<span style="color: #BA36A5;">n</span>, <span style="color: #BA36A5;">kl</span>, <span style="color: #BA36A5;">ku</span> = 4, 1, 2

<span style="color: #0000FF;">for</span> j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, n + 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">max</span>(1, j - ku), <span style="color: #006FE0;">min</span>(n, j + kl) + 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   Ab[kl + ku + 1 + i - j - 1, j - 1] = A[i-1, j-1]

b = np.array([[-1.06  + 21.50j],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [-22.72 - 53.90j],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [28.24 - 38.60j],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [-34.56 + 16.73j]])

<span style="color: #BA36A5;">lub</span>, <span style="color: #BA36A5;">piv</span>, <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">info</span> = la.flapack.zgbsv(kl, ku, Ab, b)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">compare to results at http://www.nag.com/lapack-ex/examples/results/zgbsv-ex.r</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'x = '</span>,x)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'info = '</span>,info)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">check solution</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'solved: '</span>,np.<span style="color: #006FE0;">all</span>(np.dot(A,x) - b &lt; 1e-12))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">here is the easy way!!!</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'\n\nbuilt-in solver'</span>)
<span style="color: #0000FF;">print</span>(np.linalg.solve(A,b))
</pre>
</div>

<p>
Some points of discussion.
</p>

<ol class="org-ol">
<li>Kind of painful! but, nevertheless, possible. You have to do a lot more work figuring out the dimensions of the problem, how to setup the problem, keeping track of indices, etc&#x2026;</li>
</ol>

<p>
But, one day it might be helpful to know this can be done, e.g. to debug an installation, to validate an approach against known results, etc&#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-orgf4419c1" class="outline-2">
<h2 id="orgf4419c1"><span class="section-number-2">5.</span> Nonlinear algebra</h2>
<div class="outline-text-2" id="text-5">
<p>
Nonlinear algebra problems are typically solved using an iterative process that terminates when the solution is found within a specified tolerance. This process is hidden from the user. The canonical standard form to solve is \(f(X) = 0\).
</p>
</div>

<div id="outline-container-orgdf004d8" class="outline-3">
<h3 id="orgdf004d8"><span class="section-number-3">5.1.</span> Know your tolerance</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/02/know-your-tolerance/">Matlab post</a>
\[V = \frac{\nu (C_{Ao} - C_A)}{k C_A^2}\]
</p>

<p>
with the information given below, solve for the exit concentration. This should be simple.
</p>

<pre class="example" id="orgcbaa25b">
Cao = 2*u.mol/u.L;
V = 10*u.L;
nu = 0.5*u.L/u.s;
k = 0.23 * u.L/u.mol/u.s;
</pre>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">unit definitions</span>
<span style="color: #BA36A5;">m</span> = 1.0
<span style="color: #BA36A5;">L</span> = m**3 / 1000.0
<span style="color: #BA36A5;">mol</span> = 1.0
<span style="color: #BA36A5;">s</span> = 1.0

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">provide data</span>
<span style="color: #BA36A5;">Cao</span> = 2.0 * mol / L
<span style="color: #BA36A5;">V</span> = 10.0 * L
<span style="color: #BA36A5;">nu</span> = 0.5 * L / s
<span style="color: #BA36A5;">k</span> = 0.23 * L / mol / s

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Ca):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> V - nu * (Cao - Ca)/(k * Ca**2)
</pre>
</div>

<p>
Let us plot the function to estimate the solution.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">c</span> = np.linspace(0.001, 2) * mol / L

plt.clf()
plt.plot(c, func(c))
plt.xlabel(<span style="color: #008000;">'C (mol/m^3)'</span>)
plt.ylim([-0.1, 0.1])
plt.savefig(<span style="color: #008000;">'images/nonlin-tolerance.png'</span>)
</pre>
</div>


<div id="org74db2b2" class="figure">
<p><img src="pycse-chapters/images/nonlin-tolerance.png" alt="nonlin-tolerance.png" />
</p>
</div>

<p>
Now let us solve the equation. It looks like an answer is near C=500.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">cguess</span> = 500
<span style="color: #BA36A5;">c</span>, = fsolve(func, cguess)
<span style="color: #0000FF;">print</span>(c)
<span style="color: #0000FF;">print</span>(func(c))
<span style="color: #0000FF;">print</span>(func(c) / (mol / L))
</pre>
</div>

<p>
Interesting. In Matlab, the default tolerance was not sufficient to get a good solution. Here it is.
</p>
</div>
</div>
<div id="outline-container-org2068b9a" class="outline-3">
<h3 id="org2068b9a"><span class="section-number-3">5.2.</span> Solving integral equations with fsolve</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/30/solving-integral-equations/">Original post in Matlab</a>
</p>

<p>
Occasionally we have integral equations we need to solve in engineering problems, for example, the volume of plug flow reactor can be defined by this equation: \(V = \int_{Fa(V=0)}^{Fa} \frac{1}{r_a} dFa\) where \(r_a\) is the rate law. Suppose we know the reactor volume is 100 L, the inlet molar flow of A is 1 mol/L, the volumetric flow is 10 L/min, and \(r_a = -k Ca\), with \(k=0.23\) 1/min. What is the exit molar flow rate? We need to solve the following equation:
</p>

<p>
\[100 = \int_{Fa(V=0)}^{Fa} \frac{1}{-k Fa/\nu} dFa\]
</p>

<p>
We start by creating a function handle that describes the integrand. We can use this function in the quad command to evaluate the integral.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">k</span> = 0.23
<span style="color: #BA36A5;">nu</span> = 10.0
<span style="color: #BA36A5;">Fao</span> = 1.0

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(Fa):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -1.0 / (k * Fa / nu)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Fa):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">integral</span>,<span style="color: #BA36A5;">err</span> = quad(integrand, Fao, Fa)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 100.0 - integral

<span style="color: #BA36A5;">vfunc</span> = np.vectorize(func)
</pre>
</div>

<p>
We will need an initial guess, so we make a plot of our function to get an idea.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">f</span> = np.linspace(0.01, 1)
plt.plot(f, vfunc(f))
plt.xlabel(<span style="color: #008000;">'Molar flow rate'</span>)
plt.savefig(<span style="color: #008000;">'images/integral-eqn-guess.png'</span>)
</pre>
</div>


<div id="org75c2c68" class="figure">
<p><img src="pycse-chapters/images/integral-eqn-guess.png" alt="integral-eqn-guess.png" />
</p>
</div>

<p>
Now we can see a zero is near Fa = 0.1, so we proceed to solve the equation.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Fa_guess</span> = 0.1
<span style="color: #BA36A5;">Fa_exit</span>, = fsolve(vfunc, Fa_guess)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The exit concentration is {0:1.2f} mol/L'</span>.<span style="color: #006FE0;">format</span>(Fa_exit / nu))
</pre>
</div>
</div>

<div id="outline-container-org12abae2" class="outline-4">
<h4 id="org12abae2"><span class="section-number-4">5.2.1.</span> Summary notes</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
This example seemed a little easier in Matlab, where the quad function seemed to get automatically vectorized. Here we had to do it by hand.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc70097d" class="outline-3">
<h3 id="orgc70097d"><span class="section-number-3">5.3.</span> Method of continuity for nonlinear equation solving</h3>
<div class="outline-text-3" id="text-5-3">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/01/method-of-continuity-for-nonlinear-equation-solving/">Matlab post</a>
<a href="Continuation">Continuation</a>
Adapted from Perry's Chemical Engineers Handbook, 6th edition 2-63.
</p>

<p>
We seek the solution to the following nonlinear equations:
</p>

<p>
\(2 + x + y - x^2 + 8 x y + y^3 = 0\)
</p>

<p>
\(1 + 2x - 3y + x^2 + xy - y e^x = 0\)
</p>

<p>
In principle this is easy, we simply need some initial guesses and a nonlinear solver. The challenge here is what would you guess? There could be many solutions. The equations are implicit, so it is not easy to graph them, but let us give it a shot, starting on the x range -5 to 5. The idea is set a value for x, and then solve for y in each equation.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 2 + x + y - x**2 + 8*x*y + y**3;

<span style="color: #0000FF;">def</span> <span style="color: #006699;">g</span>(x, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1 + 2*x - 3*y + x**2 + x*y - y*np.exp(x)

<span style="color: #BA36A5;">x</span> = np.linspace(-5, 5, 500)

<span style="color: #6434A3;">@np.vectorize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">fy</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x0</span> = 0.0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">tmp</span>(y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f(x, y)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y1</span>, = fsolve(tmp, x0)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y1

<span style="color: #6434A3;">@np.vectorize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">gy</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x0</span> = 0.0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">tmp</span>(y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> g(x, y)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y1</span>, = fsolve(tmp, x0)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y1


plt.plot(x, fy(x), x, gy(x))
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.legend([<span style="color: #008000;">'fy'</span>, <span style="color: #008000;">'gy'</span>])
plt.savefig(<span style="color: #008000;">'images/continuation-1.png'</span>)
</pre>
</div>


<div id="orgd8bcd4e" class="figure">
<p><img src="pycse-chapters/images/continuation-1.png" alt="continuation-1.png" />
</p>
</div>

<p>
You can see there is a solution near x = -1, y = 0, because both functions equal zero there. We can even use that guess with fsolve. It is disappointly easy! But, keep in mind that in 3 or more dimensions, you cannot perform this visualization, and another method could be required.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [f(x, y), g(x, y)]

<span style="color: #0000FF;">print</span>(fsolve(func, [-2, -2]))
</pre>
</div>


<p>
We explore a method that bypasses this problem today. The principle is to introduce a new variable, \(\lambda\), which will vary from 0 to 1. at \(\lambda=0\) we will have a simpler equation, preferably a linear one, which can be easily solved, or which can be analytically solved. At \(\lambda=1\), we have the original equations. Then, we create a system of differential equations that start at the easy solution, and integrate from \(\lambda=0\) to \(\lambda=1\), to recover the final solution.
</p>

<p>
We rewrite the equations as:
</p>

<p>
\(f(x,y) = (2 + x + y) + \lambda(- x^2 + 8 x y + y^3) = 0\)
</p>

<p>
\(g(x,y) = (1 + 2x - 3y) + \lambda(x^2 + xy - y e^x) = 0\)
</p>

<p>
Now, at \(\lambda=0\) we have the simple linear equations:
</p>

<p>
\(x + y = -2\)
</p>

<p>
\(2x - 3y = -1\)
</p>

<p>
These equations are trivial to solve:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">x0</span> = np.linalg.solve([[1., 1.], [2., -3.]],[ -2, -1])
<span style="color: #0000FF;">print</span>(x0)
</pre>
</div>

<p>
We form the system of ODEs by differentiating the new equations with respect to \(\lambda\). Why do we do that? The solution, (x,y) will be a function of \(\lambda\). From calculus, you can show that:
</p>

<p>
\(\frac{\partial f}{\partial x}\frac{\partial x}{\partial \lambda}+\frac{\partial f}{\partial y}\frac{\partial y}{\partial \lambda}=-\frac{\partial f}{\partial \lambda}\)
</p>

<p>
\(\frac{\partial g}{\partial x}\frac{\partial x}{\partial \lambda}+\frac{\partial g}{\partial y}\frac{\partial y}{\partial \lambda}=-\frac{\partial g}{\partial \lambda}\)
</p>

<p>
Now, solve this for \(\frac{\partial x}{\partial \lambda}\) and \(\frac{\partial y}{\partial \lambda}\). You can use Cramer's rule to solve for these to yield:
</p>

\begin{eqnarray} \
\frac{\partial x}{\partial \lambda} &=& \frac{\partial f/\partial y \partial g/\partial \lambda - \partial f/\partial \lambda \partial g/\partial y}{\partial f/\partial x \partial g/\partial y - \partial f/\partial y \partial g/\partial x } \\\\
\frac{\partial y}{\partial \lambda} &=& \frac{\partial f/\partial \lambda \partial g/\partial x - \partial f/\partial x \partial g/\partial \lambda}{\partial f/\partial x \partial g/\partial y - \partial f/\partial y \partial g/\partial x } \end{eqnarray}

<p>
For this set of equations:
</p>

\begin{eqnarray} \
\partial f/\partial x &=& 1 - 2\lambda x + 8\lambda y \\\\
\partial f/\partial y &=& 1 + 8 \lambda x + 3 \lambda y^2 \\\\
\partial g/\partial x &=& 2 + 2 \lambda x + \lambda y - \lambda y e^x\\\\
\partial g/\partial y &=& -3 + \lambda x - \lambda e^x
\end{eqnarray}

<p>
Now, we simply set up those two differential equations on \(\frac{\partial x}{\partial \lambda}\) and \(\frac{\partial y}{\partial \lambda}\), with the initial conditions at \(\lambda = 0\) which is the solution of the simpler linear equations, and integrate to \(\lambda = 1\), which is the final solution of the original equations!
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">ode</span>(X, LAMBDA):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">pfpx</span> = 1.0 - 2.0 * LAMBDA * x + 8 * LAMBDA * y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">pfpy</span> = 1.0 + 8.0 * LAMBDA * x + 3.0 * LAMBDA * y**2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">pfpLAMBDA</span> = -x**2 + 8.0 * x * y + y**3;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">pgpx</span> = 2. + 2. * LAMBDA * x + LAMBDA * y - LAMBDA * y * np.exp(x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">pgpy</span> = -3. + LAMBDA * x - LAMBDA * np.exp(x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">pgpLAMBDA</span> = x**2 + x * y - y * np.exp(x);
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dxdLAMBDA</span> = (pfpy * pgpLAMBDA - pfpLAMBDA * pgpy) / (pfpx * pgpy - pfpy * pgpx)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dydLAMBDA</span> = (pfpLAMBDA * pgpx - pfpx * pgpLAMBDA) / (pfpx * pgpy - pfpy * pgpx)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dXdLAMBDA</span> = [dxdLAMBDA, dydLAMBDA]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> dXdLAMBDA


<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #BA36A5;">lambda_span</span> = np.linspace(0, 1, 100)

<span style="color: #BA36A5;">X</span> = odeint(ode, x0, lambda_span)

<span style="color: #BA36A5;">xsol</span>, <span style="color: #BA36A5;">ysol</span> = X[-1]
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The solution is at x={0:1.3f}, y={1:1.3f}'</span>.<span style="color: #006FE0;">format</span>(xsol, ysol))
<span style="color: #0000FF;">print</span>(f(xsol, ysol), g(xsol, ysol))
</pre>
</div>

<p>
You can see the solution is somewhat approximate; the true solution is x = -1, y = 0. The approximation could be improved by lowering the tolerance on the ODE solver. The functions evaluate to a small number, close to zero. You have to apply some judgment to determine if that is sufficiently accurate. For instance if the units on that answer are kilometers, but you need an answer accurate to a millimeter, this may not be accurate enough.
</p>

<p>
This is a fair amount of work to get a solution! The idea is to solve a simple problem, and then gradually turn on the hard part by the lambda parameter. What happens if there are multiple solutions? The answer you finally get will depend on your \(\lambda=0\)  starting point, so it is possible to miss solutions this way. For problems with lots of variables, this would be a good approach if you can identify the easy problem.
</p>
</div>
</div>

<div id="outline-container-org8a44562" class="outline-3">
<h3 id="org8a44562"><span class="section-number-3">5.4.</span> Method of continuity for solving nonlinear equations - Part II</h3>
<div class="outline-text-3" id="text-5-4">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/02/method-of-continuity-for-solving-nonlinear-equations-part-ii-2/">Matlab post</a>
Yesterday in Post 1324 we looked at a way to solve nonlinear equations that takes away some of the burden of initial guess generation. The idea was to reformulate the equations with a new variable \(\lambda\), so that at \(\lambda=0\) we have a simpler problem we know how to solve, and at \(\lambda=1\) we have the original set of equations. Then, we derive a set of ODEs on how the solution changes with \(\lambda\), and solve them.
</p>

<p>
Today we look at a simpler example and explain a little more about what is going on. Consider the equation: \(f(x) = x^2 - 5x + 6 = 0\), which has two roots, \(x=2\) and \(x=3\). We will use the method of continuity to solve this equation to illustrate a few ideas. First, we introduce a new variable \(\lambda\) as: \(f(x; \lambda) = 0\). For example, we could write \(f(x;\lambda) = \lambda x^2 - 5x + 6 = 0\). Now, when \(\lambda=0\), we hve the simpler equation \(- 5x + 6 = 0\), with the solution \(x=6/5\). The question now is, how does \(x\) change as \(\lambda\) changes? We get that from the total derivative of how \(f(x,\lambda)\) changes with \(\lambda\). The total derivative is:
</p>

<p>
\[\frac{df}{d\lambda} = \frac{\partial f}{\partial \lambda} + \frac{\partial f}{\partial x}\frac{\partial x}{\partial \lambda}=0\]
</p>

<p>
We can calculate two of those quantities: \(\frac{\partial f}{\partial \lambda}\) and \(\frac{\partial f}{\partial x}\) analytically from our equation and solve for \(\frac{\partial x}{\partial \lambda}\) as
</p>

<p>
\[ \frac{\partial x}{\partial \lambda} = -\frac{\partial f}{\partial \lambda}/\frac{\partial f}{\partial x}\]
</p>

<p>
That defines an ordinary differential equation that we can solve by integrating from \(\lambda=0\) where we know the solution to \(\lambda=1\) which is the solution to the real problem. For this problem: \(\frac{\partial f}{\partial \lambda}=x^2\) and \(\frac{\partial f}{\partial x}=-5 + 2\lambda x\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dxdL</span>(x, Lambda):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -x**2 / (-5.0 + 2 * Lambda * x)

<span style="color: #BA36A5;">x0</span> = 6.0/5.0
<span style="color: #BA36A5;">Lspan</span> = np.linspace(0, 1)
<span style="color: #BA36A5;">x</span> = odeint(dxdL, x0, Lspan)

plt.plot(Lspan, x)
plt.xlabel(<span style="color: #008000;">'$\lambda$'</span>)
plt.ylabel(<span style="color: #008000;">'x'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlin-contin-II-1.png'</span>)
</pre>
</div>


<div id="org338f86d" class="figure">
<p><img src="pycse-chapters/images/nonlin-contin-II-1.png" alt="nonlin-contin-II-1.png" />
</p>
</div>

<p>
We found one solution at x=2. What about the other solution? To get that we have to introduce \(\lambda\) into the equations in another way. We could try: \(f(x;\lambda) = x^2 + \lambda(-5x + 6)\), but this leads to an ODE that is singular at the initial starting point. Another approach is \(f(x;\lambda) = x^2 + 6 + \lambda(-5x)\), but now the solution at \(\lambda=0\) is imaginary, and we do not have a way to integrate that! What we can do instead is add and subtract a number like this: \(f(x;\lambda) = x^2 - 4 + \lambda(-5x + 6 + 4)\). Now at \(\lambda=0\), we have a simple equation with roots at \(\pm 2\), and we already know that \(x=2\) is a solution. So, we create our ODE on \(dx/d\lambda\) with initial condition \(x(0) = -2\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dxdL</span>(x, Lambda):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> (5 * x - 10) / (2 * x - 5 * Lambda)

<span style="color: #BA36A5;">x0</span> = -2
<span style="color: #BA36A5;">Lspan</span> = np.linspace(0, 1)
<span style="color: #BA36A5;">x</span> = odeint(dxdL, x0, Lspan)

plt.plot(Lspan, x)
plt.xlabel(<span style="color: #008000;">'$\lambda$'</span>)
plt.ylabel(<span style="color: #008000;">'x'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlin-contin-II-2.png'</span>)
</pre>
</div>


<div id="org0c46367" class="figure">
<p><img src="pycse-chapters/images/nonlin-contin-II-2.png" alt="nonlin-contin-II-2.png" />
</p>
</div>

<p>
Now we have the other solution. Note if you choose the other root, \(x=2\), you find that 2 is a root, and learn nothing new. You could choose other values to add, e.g., if you chose to add and subtract 16, then you would find that one starting point leads to one root, and the other starting point leads to the other root. This method does not solve all problems associated with nonlinear root solving, namely, how many roots are there, and which one is "best" or physically reasonable? But it does give a way to solve an equation where you have no idea what an initial guess should be. You can see, however, that just like you can get different answers from different initial guesses, here you can get different answers by setting up the equations differently.
</p>
</div>
</div>

<div id="outline-container-org61edc2e" class="outline-3">
<h3 id="org61edc2e"><span class="section-number-3">5.5.</span> Counting roots</h3>
<div class="outline-text-3" id="text-5-5">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/10/counting-roots/">Matlab post</a>
The goal here is to determine how many roots there are in a nonlinear function we are interested in solving. For this example, we use a cubic polynomial because we know there are three roots.
</p>

<p>
\[f(x) = x^3 + 6x^2 - 4x -24\]
</p>
</div>

<div id="outline-container-orgfbf2091" class="outline-4">
<h4 id="orgfbf2091"><span class="section-number-4">5.5.1.</span> Use roots for this polynomial</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
This ony works for a polynomial, it does not work for any other nonlinear function.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.roots([1, 6, -4, -24]))
</pre>
</div>

<p>
Let us plot the function to see where the roots are.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(-8, 4)
<span style="color: #BA36A5;">y</span> = x**3 + 6 * x**2 - 4*x - 24
plt.plot(x, y)
plt.savefig(<span style="color: #008000;">'images/count-roots-1.png'</span>)
</pre>
</div>


<div id="org40fcf89" class="figure">
<p><img src="pycse-chapters/images/count-roots-1.png" alt="count-roots-1.png" />
</p>
</div>

<p>
Now we consider several approaches to counting the number of roots in this interval. Visually it is pretty easy, you just look for where the function crosses zero. Computationally, it is tricker.
</p>
</div>
</div>

<div id="outline-container-org354cb94" class="outline-4">
<h4 id="org354cb94"><span class="section-number-4">5.5.2.</span> method 1</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
Count the number of times the sign changes in the interval. What we have to do is multiply neighboring elements together, and look for negative values. That indicates a sign change. For example the product of two positive or negative numbers is a positive number. You only get a negative number from the product of a positive and negative number, which means the sign changed.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(-8, 4)
<span style="color: #BA36A5;">y</span> = x**3 + 6 * x**2 - 4*x - 24

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(y[0:-2] * y[1:-1] &lt; 0))
</pre>
</div>

<p>
This method gives us the number of roots, but not where the roots are.
</p>
</div>
</div>

<div id="outline-container-org52e6e28" class="outline-4">
<h4 id="org52e6e28"><span class="section-number-4">5.5.3.</span> Method 2</h4>
<div class="outline-text-4" id="text-5-5-3">
<p>
Using events in an ODE solver python can identify events in the solution to an ODE, for example, when a function has a certain value, e.g. f(x) = 0. We can take advantage of this to find the roots and number of roots in this case. We take the derivative of our function, and integrate it from an initial starting point, and define an event function that counts zeros.
</p>

<p>
\[f'(x) = 3x^2 + 12x - 4\]
</p>

<p>
with f(-8) = -120
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> odelay

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fprime</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 3.0 * x**2 + 12.0*x - 4.0

<span style="color: #0000FF;">def</span> <span style="color: #006699;">event</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">value</span> = f <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we want f = 0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">isterminal</span> = <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">direction</span> = 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> value, isterminal, direction

<span style="color: #BA36A5;">xspan</span> = np.linspace(-8, 4)
<span style="color: #BA36A5;">f0</span> = -120

<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">F</span>, <span style="color: #BA36A5;">TE</span>, <span style="color: #BA36A5;">YE</span>, <span style="color: #BA36A5;">IE</span> = odelay(fprime, f0, xspan, events=[event])
<span style="color: #0000FF;">for</span> te, ye <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(TE, YE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'root found at x = {0: 1.3f}, f={1: 1.3f}'</span>.<span style="color: #006FE0;">format</span>(te, <span style="color: #006FE0;">float</span>(ye)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgaa9edb8" class="outline-3">
<h3 id="orgaa9edb8"><span class="section-number-3">5.6.</span> Finding the nth root of a periodic function</h3>
<div class="outline-text-3" id="text-5-6">
<p>
There is a heat transfer problem where one needs to find the n^th root of the following equation: \(x J_1(x) - Bi J_0(x)=0\) where \(J_0\) and \(J_1\) are the Bessel functions of zero and first order, and \(Bi\) is the Biot number. We examine an approach to finding these roots.
</p>

<p>
First,  we plot the function.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.special <span style="color: #0000FF;">import</span> jn, jn_zeros
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">Bi</span> = 1

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x * jn(1, x) - Bi * jn(0, x)

<span style="color: #BA36A5;">X</span> = np.linspace(0, 30, 200)
plt.plot(X, f(X))
plt.savefig(<span style="color: #008000;">'images/heat-transfer-roots-1.png'</span>)
</pre>
</div>


<div id="orgcecdc85" class="figure">
<p><img src="pycse-chapters/images/heat-transfer-roots-1.png" alt="heat-transfer-roots-1.png" />
</p>
</div>

<p>
You can see there are many roots to this equation, and we want to be sure we get the n^{th} root. This function is pretty well behaved, so if you make a good guess about the solution you will get an answer, but if you make a bad guess, you may get the wrong root. We examine next a way to do it without guessing the solution. What we want is the solution to \(f(x) = 0\), but we want all the solutions in a given interval. We derive a new equation, \(f'(x) = 0\), with initial condition \(f(0) = f0\), and integrate the ODE with an event function that identifies all zeros of \(f\) for us. The derivative of our function is \(df/dx = d/dx(x J_1(x)) - Bi J'_0(x)\). It is known (<a href="http://www.markrobrien.com/besselfunct.pdf">http://www.markrobrien.com/besselfunct.pdf</a>) that \(d/dx(x J_1(x)) = x J_0(x)\), and \(J'_0(x) = -J_1(x)\). All we have to do now is set up the problem and run it.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> *  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">contains the ode integrator with events</span>

<span style="color: #0000FF;">from</span> scipy.special <span style="color: #0000FF;">import</span> jn, jn_zeros
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">Bi</span> = 1

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"function we want roots for"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x * jn(1, x) - Bi * jn(0, x)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fprime</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"df/dx"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x * jn(0, x) - Bi * (-jn(1, x))

<span style="color: #0000FF;">def</span> <span style="color: #006699;">e1</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"event function to find zeros of f"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">isterminal</span> = <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">value</span> = f
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">direction</span> = 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> value, isterminal, direction

<span style="color: #BA36A5;">f0</span> = f(0)
<span style="color: #BA36A5;">xspan</span> = np.linspace(0, 30, 200)

<span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">fsol</span>, <span style="color: #BA36A5;">XE</span>, <span style="color: #BA36A5;">FE</span>, <span style="color: #BA36A5;">IE</span> = odelay(fprime, f0, xspan, events=[e1])

plt.plot(x, fsol, <span style="color: #008000;">'.-'</span>, label=<span style="color: #008000;">'Numerical solution'</span>)
plt.plot(xspan, f(xspan), <span style="color: #008000;">'--'</span>, label=<span style="color: #008000;">'Analytical function'</span>)
plt.plot(XE, FE, <span style="color: #008000;">'ro'</span>, label=<span style="color: #008000;">'roots'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/heat-transfer-roots-2.png'</span>)

<span style="color: #0000FF;">for</span> i, root <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(XE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'root {0} is at {1}'</span>.<span style="color: #006FE0;">format</span>(i, root))
</pre>
</div>


<div id="org20af74f" class="figure">
<p><img src="pycse-chapters/images/heat-transfer-roots-2.png" alt="heat-transfer-roots-2.png" />
</p>
</div>

<p>
You can work this out once, and then you have all the roots in the interval and you can select the one you want.
</p>
</div>
</div>

<div id="outline-container-org7613579" class="outline-3">
<h3 id="org7613579"><span class="section-number-3">5.7.</span> Coupled nonlinear equations</h3>
<div class="outline-text-3" id="text-5-7">
<p>
Suppose we seek the solution to this set of equations:
</p>

\begin{align}
y &=& x^2 \\
y &=& 8 - x^2
\end{align}

<p>
To solve this we need to setup a function that is equal to zero at the solution. We have two equations, so our function must return two values. There are two variables, so the argument to our function will be an array of values.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = X            <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">unpack the array in the argument</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">z1</span> = y - x**2       <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">first equation</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">z2</span> = y - 8 + x**2   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">second equation</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [z1, z2]     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">list of zeros</span>

<span style="color: #BA36A5;">x0</span>, <span style="color: #BA36A5;">y0</span> = 1, 1           <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial guesses</span>
<span style="color: #BA36A5;">guess</span> = [x0, y0]
<span style="color: #BA36A5;">sol</span> = fsolve(objective, guess)
<span style="color: #0000FF;">print</span>(sol)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">of course there may be more than one solution</span>
<span style="color: #BA36A5;">x0</span>, <span style="color: #BA36A5;">y0</span> = -1, -1           <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial guesses</span>
<span style="color: #BA36A5;">guess</span> = [x0, y0]
<span style="color: #BA36A5;">sol</span> = fsolve(objective, guess)
<span style="color: #0000FF;">print</span>(sol)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd471e05" class="outline-2">
<h2 id="orgd471e05"><span class="section-number-2">6.</span> Statistics</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org11eaf3f" class="outline-3">
<h3 id="org11eaf3f"><span class="section-number-3">6.1.</span> Introduction to statistical data analysis</h3>
<div class="outline-text-3" id="text-6-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/27/introduction-to-statistical-data-analysis/">Matlab post</a>
</p>

<p>
Given several measurements of a single quantity, determine the average value of the measurements, the standard deviation of the measurements and the 95% confidence interval for the average.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">y</span> = [8.1, 8.0, 8.1]

<span style="color: #BA36A5;">ybar</span> = np.mean(y)
<span style="color: #BA36A5;">s</span> = np.std(y, ddof=1)

<span style="color: #0000FF;">print</span>(ybar, s)
</pre>
</div>

<p>
Interesting, we have to specify the divisor in numpy.std by the ddof argument. The default for this in Matlab is 1, the default for this function is 0.
</p>

<p>
Here is the principle of computing a confidence interval.
</p>

<ol class="org-ol">
<li>Compute the average</li>
<li>Compute the standard deviation of your data</li>
<li>Define the confidence interval, e.g. 95% = 0.95</li>
<li>Compute the student-t multiplier. This is a function of the confidence
interval you specify, and the number of data points you have minus 1. You
subtract 1 because one degree of freedom is lost from calculating the
average.</li>
</ol>

<p>
The confidence interval is defined as ybar ± T_multiplier*std/sqrt(n).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t
<span style="color: #BA36A5;">ci</span> = 0.95
<span style="color: #BA36A5;">alpha</span> = 1.0 - ci

<span style="color: #BA36A5;">n</span> = <span style="color: #006FE0;">len</span>(y)
<span style="color: #BA36A5;">T_multiplier</span> = t.ppf(1.0 - alpha / 2.0, n - 1)

<span style="color: #BA36A5;">ci95</span> = T_multiplier * s / np.sqrt(n)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'T_multiplier = {0}'</span>.<span style="color: #006FE0;">format</span>(T_multiplier))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'ci95 = {0}'</span>.<span style="color: #006FE0;">format</span>(ci95))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The true average is between {0} and {1} at a 95% confidence level'</span>.<span style="color: #006FE0;">format</span>(ybar - ci95, ybar + ci95))
</pre>
</div>
</div>
</div>


<div id="outline-container-org724da8c" class="outline-3">
<h3 id="org724da8c"><span class="section-number-3">6.2.</span> Basic statistics</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Given several measurements of a single quantity, determine the average value of the measurements, the standard deviation of the measurements and the 95% confidence interval for the average.
</p>

<p>
This is a recipe for computing the confidence interval. The strategy is:
</p>
<ol class="org-ol">
<li>compute the average</li>
<li>Compute the standard deviation of your data</li>
<li>Define the confidence interval, e.g. 95% = 0.95</li>
<li>compute the student-t multiplier. This is a function of the confidence</li>
</ol>
<p>
interval you specify, and the number of data points you have minus 1. You
subtract 1 because one degree of freedom is lost from calculating the
average. The confidence interval is defined as
ybar +- T_multiplier*std/sqrt(n).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t

<span style="color: #BA36A5;">y</span> = [8.1, 8.0, 8.1]

<span style="color: #BA36A5;">ybar</span> = np.mean(y)
<span style="color: #BA36A5;">s</span> = np.std(y)

<span style="color: #BA36A5;">ci</span> = 0.95
<span style="color: #BA36A5;">alpha</span> = 1.0 - ci

<span style="color: #BA36A5;">n</span> = <span style="color: #006FE0;">len</span>(y)
<span style="color: #BA36A5;">T_multiplier</span> = t.ppf(1-alpha/2.0, n-1)

<span style="color: #BA36A5;">ci95</span> = T_multiplier * s / np.sqrt(n-1)

<span style="color: #0000FF;">print</span>([ybar - ci95, ybar + ci95])
</pre>
</div>

<p>
We are 95% certain the next measurement will fall in the interval above.
</p>
</div>
</div>

<div id="outline-container-orgc51ce1d" class="outline-3">
<h3 id="orgc51ce1d"><span class="section-number-3">6.3.</span> Confidence interval on an average</h3>
<div class="outline-text-3" id="text-6-3">
<p>
mod:scipy has a statistical package available for getting statistical distributions. This is useful for computing confidence intervals using the student-t tables. Here is an example of computing a 95% confidence interval on an average.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t

<span style="color: #BA36A5;">n</span> = 10 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of measurements</span>
<span style="color: #BA36A5;">dof</span> = n - 1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">degrees of freedom</span>
<span style="color: #BA36A5;">avg_x</span> = 16.1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">average measurement</span>
<span style="color: #BA36A5;">std_x</span> = 0.01 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">standard deviation of measurements</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Find 95% prediction interval for next measurement</span>

<span style="color: #BA36A5;">alpha</span> = 1.0 - 0.95

<span style="color: #BA36A5;">pred_interval</span> = t.ppf(1-alpha/2.0, dof) * std_x / np.sqrt(n)

<span style="color: #BA36A5;">s</span> = [<span style="color: #008000;">'We are 95% confident the next measurement'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  <span style="color: #008000;">' will be between {0:1.3f} and {1:1.3f}'</span>]
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">''</span>.join(s).<span style="color: #006FE0;">format</span>(avg_x - pred_interval, avg_x + pred_interval))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf945004" class="outline-3">
<h3 id="orgf945004"><span class="section-number-3">6.4.</span> Are averages different</h3>
<div class="outline-text-3" id="text-6-4">
<p>
<a href="http://matlab.cheme.cmu.edu/2012/01/28/are-two-averages-different/">Matlab post</a>
</p>

<p>
Adapted from <a href="http://stattrek.com/ap-statistics-4/unpaired-means.aspx">http://stattrek.com/ap-statistics-4/unpaired-means.aspx</a>
</p>

<p>
Class A had 30 students who received an average test score of 78, with standard deviation of 10. Class B had 25 students an average test score of 85, with a standard deviation of 15. We want to know if the difference in these averages is statistically relevant. Note that we only have estimates of the true average and standard deviation for each class, and there is uncertainty in those estimates. As a result, we are unsure if the averages are really different. It could have just been luck that a few students in class B did better.
</p>
</div>

<div id="outline-container-orge5815fb" class="outline-4">
<h4 id="orge5815fb"><span class="section-number-4">6.4.1.</span> The hypothesis</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
the true averages are the same. We need to perform a two-sample t-test of the hypothesis that \(\mu_1 - \mu_2 = 0\) (this is often called the null hypothesis). we use a two-tailed test because we do not care if the difference is positive or negative, either way means the averages are not the same.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">n1</span> = 30  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">students in class A</span>
<span style="color: #BA36A5;">x1</span> = 78.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">average grade in class A</span>
<span style="color: #BA36A5;">s1</span> = 10.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">std dev of exam grade in class A</span>

<span style="color: #BA36A5;">n2</span> = 25  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">students in class B</span>
<span style="color: #BA36A5;">x2</span> = 85.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">average grade in class B</span>
<span style="color: #BA36A5;">s2</span> = 15.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">std dev of exam grade in class B</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the standard error of the difference between the two averages.</span>
<span style="color: #BA36A5;">SE</span> = np.sqrt(s1**2 / n1 + s2**2 / n2)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">compute DOF</span>
<span style="color: #BA36A5;">DF</span> = (n1 - 1) + (n2 - 1)
</pre>
</div>

<p>
See the discussion at <a href="http://stattrek.com/Help/Glossary.aspx?Target=Two-sample%20t-test">http://stattrek.com/Help/Glossary.aspx?Target=Two-sample%20t-test</a> for a more complex definition of degrees of freedom. Here we simply subtract one from each sample size to account for the estimation of the average of each sample.
</p>
</div>
</div>


<div id="outline-container-org25ec248" class="outline-4">
<h4 id="org25ec248"><span class="section-number-4">6.4.2.</span> Compute the t-score for our data</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
The difference between two averages determined from small sample numbers follows the t-distribution. the t-score is the difference between the difference of the means and the hypothesized difference of the means, normalized by the standard error. we compute the absolute value of the t-score to make sure it is positive for convenience later.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">tscore</span> = np.<span style="color: #006FE0;">abs</span>(((x1 - x2) - 0) / SE)
<span style="color: #0000FF;">print</span>(tscore)
</pre>
</div>
</div>
</div>

<div id="outline-container-org49f5dff" class="outline-4">
<h4 id="org49f5dff"><span class="section-number-4">6.4.3.</span> Interpretation</h4>
<div class="outline-text-4" id="text-6-4-3">
<p>
A way to approach determining if the difference is significant or not is to ask, does our computed average fall within a confidence range of the hypothesized value (zero)? If it does, then we can attribute the difference to statistical variations at that confidence level. If it does not, we can say that statistical variations do not account for the difference at that confidence level, and hence the averages must be different.
</p>

<p>
Let us compute the t-value that corresponds to a 95% confidence level for a mean of zero with the degrees of freedom computed earlier. This means that 95% of the t-scores we expect to get will fall within ± t95.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t

<span style="color: #BA36A5;">ci</span> = 0.95;
<span style="color: #BA36A5;">alpha</span> = 1 - ci;
<span style="color: #BA36A5;">t95</span> = t.ppf(1.0 - alpha/2.0, DF)

<span style="color: #0000FF;">print</span>(t95)
</pre>
</div>

<p>
since tscore &lt; t95, we conclude that at the 95% confidence level we cannot say these averages are statistically different because our computed t-score falls in the expected range of deviations. Note that our t-score is very close to the 95% limit. Let us consider a smaller confidence interval.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">ci</span> = 0.94
<span style="color: #BA36A5;">alpha</span> = 1 - ci;
<span style="color: #BA36A5;">t95</span> = t.ppf(1.0 - alpha/2.0, DF)

<span style="color: #0000FF;">print</span>(t95)
</pre>
</div>

<p>
at the 94% confidence level, however, tscore &gt; t94, which means we can say with 94% confidence that the two averages are different; class B performed better than class A did. Alternatively, there is only about a 6% chance we are wrong about that statement.
another way to get there
</p>

<p>
An alternative way to get the confidence that the averages are different is to directly compute it from the cumulative t-distribution function. We compute the difference between all the t-values less than tscore and the t-values less than -tscore, which is the fraction of measurements that are between them. You can see here that we are practically 95% sure that the averages are different.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">f</span> = t.cdf(tscore, DF) - t.cdf(-tscore, DF)
<span style="color: #0000FF;">print</span>(f)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5b8c90d" class="outline-3">
<h3 id="org5b8c90d"><span class="section-number-3">6.5.</span> Model selection</h3>
<div class="outline-text-3" id="text-6-5">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/01/model-selection/">Matlab post</a>
</p>

<p>
adapted from <a href="http://www.itl.nist.gov/div898/handbook/pmd/section4/pmd44.htm">http://www.itl.nist.gov/div898/handbook/pmd/section4/pmd44.htm</a>
</p>

<p>
In this example, we show some ways to choose which of several models fit data the best. We have data for the total pressure and temperature of a fixed amount of a gas in a tank that was measured over the course of several days. We want to select a model that relates the pressure to the gas temperature.
</p>

<p>
The data is stored in a text file download PT.txt , with the following structure:
</p>

<pre class="example" id="orgce8d4f4">
Run          Ambient                            Fitted
 Order  Day  Temperature  Temperature  Pressure    Value    Residual
  1      1      23.820      54.749      225.066   222.920     2.146
...
</pre>

<p>
We need to read the data in, and perform a regression analysis on P vs. T. In python we start counting at 0, so we actually want columns 3 and 4.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">data</span> = np.loadtxt(<span style="color: #008000;">'data/PT.txt'</span>, skiprows=2)
T = data[:, 3]
P = data[:, 4]

plt.plot(T, P, <span style="color: #008000;">'k.'</span>)
plt.xlabel(<span style="color: #008000;">'Temperature'</span>)
plt.ylabel(<span style="color: #008000;">'Pressure'</span>)
plt.savefig(<span style="color: #008000;">'images/model-selection-1.png'</span>)
</pre>
</div>


<div id="orgf775889" class="figure">
<p><img src="pycse-chapters/images/model-selection-1.png" alt="model-selection-1.png" />
</p>
</div>

<p>
It appears the data is roughly linear, and we know from the ideal gas law that PV = nRT, or P = nR/V*T, which says P should be linearly correlated with V. Note that the temperature data is in degC, not in K, so it is not expected that P=0 at T = 0. We will use linear algebra to compute the line coefficients.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">A</span> = np.vstack([T**0, T]).T
<span style="color: #BA36A5;">b</span> = P

<span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">res</span>, <span style="color: #BA36A5;">rank</span>, <span style="color: #BA36A5;">s</span> = np.linalg.lstsq(A, b)
<span style="color: #BA36A5;">intercept</span>, <span style="color: #BA36A5;">slope</span> = x
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'b, m ='</span>, intercept, slope)

n = <span style="color: #006FE0;">len</span>(b)
k = <span style="color: #006FE0;">len</span>(x)

sigma2 = np.<span style="color: #006FE0;">sum</span>((b - np.dot(A,x))**2) / (n - k)

C = sigma2 * np.linalg.inv(np.dot(A.T, A))
se = np.sqrt(np.diag(C))

<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t
alpha = 0.05

sT = t.ppf(1-alpha/2., n - k) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">student T multiplier</span>
CI = sT * se

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'CI = '</span>,CI)
<span style="color: #0000FF;">for</span> beta, ci <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(x, CI):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'[{0} {1}]'</span>.<span style="color: #006FE0;">format</span>(beta - ci, beta + ci))
</pre>
</div>

<p>
The confidence interval on the intercept is large, but it does not contain zero at the 95% confidence level.
</p>

<p>
The R^2 value accounts roughly for the fraction of variation in the data that can be described by the model. Hence, a value close to one means nearly all the variations are described by the model, except for random variations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">ybar</span> = np.mean(P)
<span style="color: #BA36A5;">SStot</span> = np.<span style="color: #006FE0;">sum</span>((P - ybar)**2)
<span style="color: #BA36A5;">SSerr</span> = np.<span style="color: #006FE0;">sum</span>((P - np.dot(A, x))**2)
<span style="color: #BA36A5;">R2</span> = 1 - SSerr/SStot
<span style="color: #0000FF;">print</span>(R2)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">plt.figure(); plt.clf()
plt.plot(T, P, <span style="color: #008000;">'k.'</span>, T, np.dot(A, x), <span style="color: #008000;">'b-'</span>)
plt.xlabel(<span style="color: #008000;">'Temperature'</span>)
plt.ylabel(<span style="color: #008000;">'Pressure'</span>)
plt.title(<span style="color: #008000;">'R^2 = {0:1.3f}'</span>.<span style="color: #006FE0;">format</span>(R2))
plt.savefig(<span style="color: #008000;">'images/model-selection-2.png'</span>)
</pre>
</div>


<div id="org6ab9930" class="figure">
<p><img src="pycse-chapters/images/model-selection-2.png" alt="model-selection-2.png" />
</p>
</div>

<p>
The fit looks good, and R^2 is near one, but is it a good model? There are a few ways to examine this. We want to make sure that there are no systematic trends in the errors between the fit and the data, and we want to make sure there are not hidden correlations with other variables. The residuals are the error between the fit and the data. The residuals should not show any patterns when plotted against any variables, and they do not in this case.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">residuals</span> = P - np.dot(A, x)

plt.figure()

f, (<span style="color: #BA36A5;">ax1</span>, <span style="color: #BA36A5;">ax2</span>, <span style="color: #BA36A5;">ax3</span>) = plt.subplots(3)

ax1.plot(T,residuals,<span style="color: #008000;">'ko'</span>)
ax1.set_xlabel(<span style="color: #008000;">'Temperature'</span>)


<span style="color: #BA36A5;">run_order</span> = data[:, 0]
ax2.plot(run_order, residuals,<span style="color: #008000;">'ko '</span>)
ax2.set_xlabel(<span style="color: #008000;">'run order'</span>)

<span style="color: #BA36A5;">ambientT</span> = data[:, 2]
ax3.plot(ambientT, residuals,<span style="color: #008000;">'ko'</span>)
ax3.set_xlabel(<span style="color: #008000;">'ambient temperature'</span>)

plt.tight_layout() <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">make sure plots do not overlap</span>
plt.savefig(<span style="color: #008000;">'images/model-selection-3.png'</span>)
</pre>
</div>


<div id="orgf537440" class="figure">
<p><img src="pycse-chapters/images/model-selection-3.png" alt="model-selection-3.png" />
</p>
</div>

<p>
There may be some correlations in the residuals with the run order. That could indicate an experimental source of error.
</p>

<p>
We assume all the errors are uncorrelated with each other. We can use a lag plot to assess this, where we plot residual[i] vs residual[i-1], i.e. we look for correlations between adjacent residuals. This plot should look random, with no correlations if the model is good.
</p>

<div class="org-src-container">
<pre class="src src-python">plt.figure(); plt.clf()
plt.plot(residuals[1:-1], residuals[0:-2],<span style="color: #008000;">'ko'</span>)
plt.xlabel(<span style="color: #008000;">'residual[i]'</span>)
plt.ylabel(<span style="color: #008000;">'residual[i-1]'</span>)
plt.savefig(<span style="color: #008000;">'images/model-selection-correlated-residuals.png'</span>)
</pre>
</div>


<div id="org23f28d9" class="figure">
<p><img src="pycse-chapters/images/model-selection-correlated-residuals.png" alt="model-selection-correlated-residuals.png" />
</p>
</div>

<p>
It is hard to argue there is any correlation here.
</p>

<p>
Lets consider a quadratic model instead.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">A</span> = np.vstack([T**0, T, T**2]).T
<span style="color: #BA36A5;">b</span> = P;

<span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">res</span>, <span style="color: #BA36A5;">rank</span>, <span style="color: #BA36A5;">s</span> = np.linalg.lstsq(A, b)
<span style="color: #0000FF;">print</span>(x)

<span style="color: #BA36A5;">n</span> = <span style="color: #006FE0;">len</span>(b)
<span style="color: #BA36A5;">k</span> = <span style="color: #006FE0;">len</span>(x)

<span style="color: #BA36A5;">sigma2</span> = np.<span style="color: #006FE0;">sum</span>((b - np.dot(A,x))**2) / (n - k)

<span style="color: #BA36A5;">C</span> = sigma2 * np.linalg.inv(np.dot(A.T, A))
<span style="color: #BA36A5;">se</span> = np.sqrt(np.diag(C))

<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t
<span style="color: #BA36A5;">alpha</span> = 0.05

<span style="color: #BA36A5;">sT</span> = t.ppf(1-alpha/2., n - k) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">student T multiplier</span>
<span style="color: #BA36A5;">CI</span> = sT * se

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'CI = '</span>,CI)
<span style="color: #0000FF;">for</span> beta, ci <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(x, CI):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'[{0} {1}]'</span>.<span style="color: #006FE0;">format</span>(beta - ci, beta + ci))


ybar = np.mean(P)
SStot = np.<span style="color: #006FE0;">sum</span>((P - ybar)**2)
SSerr = np.<span style="color: #006FE0;">sum</span>((P - np.dot(A,x))**2)
R2 = 1 - SSerr/SStot
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'R^2 = {0}'</span>.<span style="color: #006FE0;">format</span>(R2))
</pre>
</div>

<p>
You can see that the confidence interval on the constant and T^2 term includes zero. That is a good indication this additional parameter is not significant. You can see also that the R^2 value is not better than the one from a linear fit,  so adding a parameter does not increase the goodness of fit. This is an example of overfitting the data. Since the constant in this model is apparently not significant, let us consider the simplest model with a fixed intercept of zero.
</p>

<p>
Let us consider a model with intercept = 0, P = alpha*T.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">A</span> = np.vstack([T]).T
<span style="color: #BA36A5;">b</span> = P;

<span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">res</span>, <span style="color: #BA36A5;">rank</span>, <span style="color: #BA36A5;">s</span> = np.linalg.lstsq(A, b)

<span style="color: #BA36A5;">n</span> = <span style="color: #006FE0;">len</span>(b)
<span style="color: #BA36A5;">k</span> = <span style="color: #006FE0;">len</span>(x)

<span style="color: #BA36A5;">sigma2</span> = np.<span style="color: #006FE0;">sum</span>((b - np.dot(A,x))**2) / (n - k)

<span style="color: #BA36A5;">C</span> = sigma2 * np.linalg.inv(np.dot(A.T, A))
<span style="color: #BA36A5;">se</span> = np.sqrt(np.diag(C))

<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t
<span style="color: #BA36A5;">alpha</span> = 0.05

<span style="color: #BA36A5;">sT</span> = t.ppf(1-alpha/2.0, n - k) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">student T multiplier</span>
<span style="color: #BA36A5;">CI</span> = sT * se

<span style="color: #0000FF;">for</span> beta, ci <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(x, CI):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'[{0} {1}]'</span>.<span style="color: #006FE0;">format</span>(beta - ci, beta + ci))

plt.figure()
plt.plot(T, P, <span style="color: #008000;">'k. '</span>, T, np.dot(A, x))
plt.xlabel(<span style="color: #008000;">'Temperature'</span>)
plt.ylabel(<span style="color: #008000;">'Pressure'</span>)
plt.legend([<span style="color: #008000;">'data'</span>, <span style="color: #008000;">'fit'</span>])

<span style="color: #BA36A5;">ybar</span> = np.mean(P)
<span style="color: #BA36A5;">SStot</span> = np.<span style="color: #006FE0;">sum</span>((P - ybar)**2)
<span style="color: #BA36A5;">SSerr</span> = np.<span style="color: #006FE0;">sum</span>((P - np.dot(A,x))**2)
<span style="color: #BA36A5;">R2</span> = 1 - SSerr/SStot
plt.title(<span style="color: #008000;">'R^2 = {0:1.3f}'</span>.<span style="color: #006FE0;">format</span>(R2))
plt.savefig(<span style="color: #008000;">'images/model-selection-no-intercept.png'</span>)
</pre>
</div>

<p>
<img src="pycse-chapters/images/model-selection-no-intercept.png" alt="model-selection-no-intercept.png" />
The fit is visually still pretty good, and the R^2 value is only slightly worse. Let us examine the residuals again.
</p>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">residuals</span> = P - np.dot(A,x)

plt.figure()
plt.plot(T,residuals,<span style="color: #008000;">'ko'</span>)
plt.xlabel(<span style="color: #008000;">'Temperature'</span>)
plt.ylabel(<span style="color: #008000;">'residuals'</span>)
plt.savefig(<span style="color: #008000;">'images/model-selection-no-incpt-resid.png'</span>)
</pre>
</div>


<div id="orga39d148" class="figure">
<p><img src="pycse-chapters/images/model-selection-no-incpt-resid.png" alt="model-selection-no-incpt-resid.png" />
</p>
</div>

<p>
You can see a slight trend of decreasing value of the residuals as the Temperature increases. This may indicate a deficiency in the model with no intercept. For the ideal gas law in degC: \(PV = nR(T+273)\) or \(P = nR/V*T + 273*nR/V\), so the intercept is expected to be non-zero in this case. Specifically, we expect the intercept to be 273*R*n/V. Since the molar density of a gas is pretty small, the intercept may be close to, but not equal to zero. That is why the fit still looks ok, but is not as good as letting the intercept be a fitting parameter. That is an example of the deficiency in our model.
</p>

<p>
In the end, it is hard to justify a model more complex than a line in this case.
</p>
</div>
</div>

<div id="outline-container-orgae44f37" class="outline-3">
<h3 id="orgae44f37"><span class="section-number-3">6.6.</span> Numerical propagation of errors</h3>
<div class="outline-text-3" id="text-6-6">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/05/numerical-propogation-of-errors/">Matlab post</a>
</p>

<p>
Propagation of errors is essential to understanding how the uncertainty in a parameter affects computations that use that parameter. The uncertainty propagates by a set of rules into your solution. These rules are not easy to remember, or apply to complicated situations, and are only approximate for equations that are nonlinear in the parameters.
</p>

<p>
We will use a Monte Carlo simulation to illustrate error propagation. The idea is to generate a distribution of possible parameter values, and to evaluate your equation for each parameter value. Then, we perform statistical analysis on the results to determine the standard error of the results.
</p>

<p>
We will assume all parameters are defined by a normal distribution with known mean and standard deviation.
</p>
</div>

<div id="outline-container-org455fa4c" class="outline-4">
<h4 id="org455fa4c"><span class="section-number-4">6.6.1.</span> Addition and subtraction</h4>
<div class="outline-text-4" id="text-6-6-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">N</span> = 1e4 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of samples of parameters</span>

<span style="color: #BA36A5;">A_mu</span> = 2.5; <span style="color: #BA36A5;">A_sigma</span> = 0.4
<span style="color: #BA36A5;">B_mu</span> = 4.1; <span style="color: #BA36A5;">B_sigma</span> = 0.3

<span style="color: #BA36A5;">A</span> = np.random.normal(A_mu, A_sigma, size=N)
B = np.random.normal(B_mu, B_sigma, size=N)

p = A + B
m = A - B

plt.hist(p)
plt.show()

<span style="color: #0000FF;">print</span>(np.std(p))
<span style="color: #0000FF;">print</span>(np.std(m))

<span style="color: #0000FF;">print</span>(np.sqrt(A_sigma**2 + B_sigma**2)) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the analytical std dev</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge40f70c" class="outline-4">
<h4 id="orge40f70c"><span class="section-number-4">6.6.2.</span> Multiplication</h4>
<div class="outline-text-4" id="text-6-6-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">F_mu</span> = 25.0; <span style="color: #BA36A5;">F_sigma</span> = 1;
<span style="color: #BA36A5;">x_mu</span> = 6.4; <span style="color: #BA36A5;">x_sigma</span> = 0.4;

<span style="color: #BA36A5;">F</span> = np.random.normal(F_mu, F_sigma, size=N)
x = np.random.normal(x_mu, x_sigma, size=N)

t = F * x
<span style="color: #0000FF;">print</span>(np.std(t))
<span style="color: #0000FF;">print</span>(np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu * x_mu)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc7ef074" class="outline-4">
<h4 id="orgc7ef074"><span class="section-number-4">6.6.3.</span> Division</h4>
<div class="outline-text-4" id="text-6-6-3">
<p>
This is really like multiplication: F / x = F * (1 / x).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">d</span> = F / x
<span style="color: #0000FF;">print</span>(np.std(d))
<span style="color: #0000FF;">print</span>(np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu / x_mu)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6136a1" class="outline-4">
<h4 id="orgc6136a1"><span class="section-number-4">6.6.4.</span> exponents</h4>
<div class="outline-text-4" id="text-6-6-4">
<p>
This rule is different than multiplication (A^2 = A*A) because in the previous examples we assumed the errors in A and B for A*B were uncorrelated. in A*A, the errors are not uncorrelated, so there is a different rule for error propagation.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">t_mu</span> = 2.03; <span style="color: #BA36A5;">t_sigma</span> = 0.01*t_mu; <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1% error</span>
<span style="color: #BA36A5;">A_mu</span> = 16.07; <span style="color: #BA36A5;">A_sigma</span> = 0.06;

<span style="color: #BA36A5;">t</span> = np.random.normal(t_mu, t_sigma, size=(1, N))
A = np.random.normal(A_mu, A_sigma, size=(1, N))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Compute t^5 and sqrt(A) with error propagation</span>
<span style="color: #0000FF;">print</span>(np.std(t**5))
<span style="color: #0000FF;">print</span>((5 * t_sigma / t_mu) * t_mu**5)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(np.std(np.sqrt(A)))
<span style="color: #0000FF;">print</span>(1.0 / 2.0 * A_sigma / A_mu * np.sqrt(A_mu))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5c622dd" class="outline-4">
<h4 id="org5c622dd"><span class="section-number-4">6.6.5.</span> the chain rule in error propagation</h4>
<div class="outline-text-4" id="text-6-6-5">
<p>
let v = v0 + a*t, with uncertainties in vo,a and t
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">vo_mu</span> = 1.2; <span style="color: #BA36A5;">vo_sigma</span> = 0.02;
<span style="color: #BA36A5;">a_mu</span> = 3.0;  <span style="color: #BA36A5;">a_sigma</span>  = 0.3;
<span style="color: #BA36A5;">t_mu</span> = 12.0; <span style="color: #BA36A5;">t_sigma</span>  = 0.12;

<span style="color: #BA36A5;">vo</span> = np.random.normal(vo_mu, vo_sigma, (1, N))
<span style="color: #BA36A5;">a</span> = np.random.normal(a_mu, a_sigma, (1, N))
<span style="color: #BA36A5;">t</span> = np.random.normal(t_mu, t_sigma, (1, N))

<span style="color: #BA36A5;">v</span> = vo + a*t

<span style="color: #0000FF;">print</span>(np.std(v))
<span style="color: #0000FF;">print</span>(np.sqrt(vo_sigma**2 + t_mu**2 * a_sigma**2 + a_mu**2 * t_sigma**2))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6c807dc" class="outline-4">
<h4 id="org6c807dc"><span class="section-number-4">6.6.6.</span> Summary</h4>
<div class="outline-text-4" id="text-6-6-6">
<p>
You can numerically perform error propagation analysis if you know the underlying distribution of errors on the parameters in your equations. One benefit of the numerical propagation is you do not have to remember the error propagation rules, and you directly look at the distribution in nonlinear cases. Some limitations of this approach include
</p>

<ol class="org-ol">
<li>You have to know the distribution of the errors in the parameters</li>
<li>You have to assume the errors in parameters are uncorrelated.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org4c0752c" class="outline-3">
<h3 id="org4c0752c"><span class="section-number-3">6.7.</span> Another approach to error propagation</h3>
<div class="outline-text-3" id="text-6-7">
<p>
In the previous section we examined an analytical approach to error propagation, and a simulation based approach. There is another approach to error propagation, using the uncertainties module (<a href="https://pypi.python.org/pypi/uncertainties/">https://pypi.python.org/pypi/uncertainties/</a>). You have to install this package, e.g. <code>pip install uncertainties</code>. After that, the module provides new classes of numbers and functions that incorporate uncertainty and propagate the uncertainty through the functions. In the examples that follow, we repeat the calculations from the previous section using the uncertainties module.
</p>

<p>
<span class="underline">Addition and subtraction</span>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> uncertainties <span style="color: #0000FF;">as</span> u

<span style="color: #BA36A5;">A</span> = u.ufloat((2.5, 0.4))
<span style="color: #BA36A5;">B</span> = u.ufloat((4.1, 0.3))
<span style="color: #0000FF;">print</span>(A + B)
<span style="color: #0000FF;">print</span>(A - B)
</pre>
</div>

<p>
<span class="underline">Multiplication and division</span>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">F</span> = u.ufloat((25, 1))
<span style="color: #BA36A5;">x</span> = u.ufloat((6.4, 0.4))

<span style="color: #BA36A5;">t</span> = F * x
<span style="color: #0000FF;">print</span>(t)

<span style="color: #BA36A5;">d</span> = F / x
<span style="color: #0000FF;">print</span>(d)
</pre>
</div>

<p>
<span class="underline">Exponentiation</span>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">t</span> = u.ufloat((2.03, 0.0203))
<span style="color: #0000FF;">print</span>(t**5)

<span style="color: #0000FF;">from</span> uncertainties.umath <span style="color: #0000FF;">import</span> sqrt
<span style="color: #BA36A5;">A</span> = u.ufloat((16.07, 0.06))
<span style="color: #0000FF;">print</span>(sqrt(A))
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print np.sqrt(A) # this does not work</span>

<span style="color: #0000FF;">from</span> uncertainties <span style="color: #0000FF;">import</span> unumpy <span style="color: #0000FF;">as</span> unp
<span style="color: #0000FF;">print</span>(unp.sqrt(A))
</pre>
</div>

<p>
Note in the last example, we had to either import a function from uncertainties.umath or import a special version of numpy that handles uncertainty. This may be a limitation of the uncertainties package as not all functions in arbitrary modules can be covered. Note, however, that you can wrap a function to make it handle uncertainty like this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">wrapped_sqrt</span> = u.wrap(np.sqrt)
<span style="color: #0000FF;">print</span>(wrapped_sqrt(A))
</pre>
</div>

<p>
<span class="underline">Propagation of errors in an integral</span>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> uncertainties <span style="color: #0000FF;">as</span> u

<span style="color: #BA36A5;">x</span> = np.array([u.ufloat((1, 0.01)),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> u.ufloat((2, 0.1)),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> u.ufloat((3, 0.1))])

<span style="color: #BA36A5;">y</span> = 2 * x

<span style="color: #0000FF;">print</span>(np.trapz(x, y))
</pre>
</div>

<p>
<span class="underline">Chain rule in error propagation</span>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">v0</span> = u.ufloat((1.2, 0.02))
<span style="color: #BA36A5;">a</span> = u.ufloat((3.0, 0.3))
<span style="color: #BA36A5;">t</span> = u.ufloat((12.0, 0.12))

<span style="color: #BA36A5;">v</span> = v0 + a * t
<span style="color: #0000FF;">print</span>(v)
</pre>
</div>

<p>
<span class="underline">A real example?</span>
This is what I would setup for a real working example. We try to compute the exit concentration from a CSTR. The idea is to wrap the "external" fsolve function using the <code>uncertainties.wrap</code> function, which handles the units. Unfortunately, it does not work, and it is not clear why. But see the following discussion for a fix.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">Fa0</span> = u.ufloat((5.0, 0.05))
<span style="color: #BA36A5;">v0</span> = u.ufloat((10., 0.1))

<span style="color: #BA36A5;">V</span> = u.ufloat((66000.0, 100))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reactor volume L^3</span>
<span style="color: #BA36A5;">k</span> = u.ufloat((3.0, 0.2))      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate constant L/mol/h</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Ca):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Fa</span> = v0 * Ca     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">exit molar flow of A</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ra</span> = -k * Ca**2  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate of reaction of A L/mol/h</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Fa0 - Fa + V * ra

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">CA guess that that 90 % is reacted away</span>
<span style="color: #BA36A5;">CA_guess</span> = 0.1 * Fa0 / v0

<span style="color: #BA36A5;">wrapped_fsolve</span> = u.wrap(fsolve)
<span style="color: #BA36A5;">CA_sol</span> = wrapped_fsolve(func, CA_guess)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The exit concentration is {0} mol/L'</span>.<span style="color: #006FE0;">format</span>(CA_sol))
</pre>
</div>

<p>
I got a note from the author of the uncertainties package explaining the cryptic error above, and a solution for it. The error arises because fsolve does not know how to deal with uncertainties. The idea is to create a function that returns a float, when everything is given as a float. Then, we wrap the fsolve call, and finally wrap the wrapped fsolve call!
</p>

<ul class="org-ul">
<li>Step 1. Write the function to solve with arguments for all unitted quantities. This function may be called with uncertainties, or with floats.</li>

<li>Step 2. Wrap the call to fsolve in a function that takes all the parameters as arguments, and that returns the solution.</li>

<li>Step 3. Use uncertainties.wrap to wrap the function in Step 2 to get the answer with uncertainties.</li>
</ul>

<p>
Here is the code that does work:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> uncertainties <span style="color: #0000FF;">as</span> u
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">Fa0</span> = u.ufloat((5.0, 0.05))
<span style="color: #BA36A5;">v0</span> = u.ufloat((10., 0.1))

<span style="color: #BA36A5;">V</span> = u.ufloat((66000.0, 100.0))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reactor volume L^3</span>
<span style="color: #BA36A5;">k</span> = u.ufloat((3.0, 0.2))      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate constant L/mol/h</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Step 1</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Ca, v0, k, Fa0, V):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Fa</span> = v0 * Ca     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">exit molar flow of A</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ra</span> = -k * Ca**2  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate of reaction of A L/mol/h</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Fa0 - Fa + V * ra

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Step 2</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">Ca_solve</span>(v0, k, Fa0, V):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'wrap fsolve to pass parameters as float or units'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is a little fragile. You must put [0] at the end or</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">you get the NotImplemented result</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">guess</span> = 0.1 * Fa0 / v0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sol</span> = fsolve(func, guess, args=(v0, k, Fa0, V))[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> sol

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Step 3</span>
<span style="color: #0000FF;">print</span>(u.wrap(Ca_solve)(v0, k, Fa0, V))
</pre>
</div>

<p>
It would take some practice to get used to this, but the payoff is that you have an "automatic" error propagation method.
</p>

<p>
Being ever the skeptic, let us compare the result above to the Monte Carlo approach to error estimation below.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">N</span> = 10000
<span style="color: #BA36A5;">Fa0</span> = np.random.normal(5, 0.05, (1, N))
<span style="color: #BA36A5;">v0</span> = np.random.normal(10.0, 0.1, (1, N))
<span style="color: #BA36A5;">V</span> =  np.random.normal(66000, 100, (1,N))
<span style="color: #BA36A5;">k</span> = np.random.normal(3.0, 0.2, (1, N))

<span style="color: #BA36A5;">SOL</span> = np.zeros((1, N))

<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(N):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Ca):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Fa0[0,i] - v0[0,i] * Ca + V[0,i] * (-k[0,i] * Ca**2)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">SOL</span>[0,i] = fsolve(func, 0.1 * Fa0[0,i] / v0[0,i])[0]

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Ca(exit) = {0}+/-{1}'</span>.<span style="color: #006FE0;">format</span>(np.mean(SOL), np.std(SOL)))
</pre>
</div>

<p>
I am pretty content those are the same!
</p>
</div>

<div id="outline-container-orgf7baa28" class="outline-4">
<h4 id="orgf7baa28"><span class="section-number-4">6.7.1.</span> Summary</h4>
<div class="outline-text-4" id="text-6-7-1">
<p>
The uncertainties module is pretty amazing. It automatically propagates errors through a pretty broad range of computations. It is a little tricky for third-party packages, but it seems doable.
</p>

<p>
Read more about the package at <a href="http://pythonhosted.org/uncertainties/index.html">http://pythonhosted.org/uncertainties/index.html</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-org75b655f" class="outline-3">
<h3 id="org75b655f"><span class="section-number-3">6.8.</span> Random thoughts</h3>
<div class="outline-text-3" id="text-6-8">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/04/random-thoughts/">Matlab post</a>
</p>

<p>
Random numbers are used in a variety of simulation methods, most notably Monte Carlo simulations. In another later example, we will see how we can use random numbers for error propagation analysis. First, we discuss two types of pseudorandom numbers we can use in python: uniformly distributed and normally distributed numbers.
</p>

<p>
Say you are the gambling type, and bet your friend $5 the next random number will be greater than 0.49. Let us ask Python to roll the random number generator for us.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">n</span> = np.random.uniform()
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'n = {0}'</span>.<span style="color: #006FE0;">format</span>(n))

<span style="color: #0000FF;">if</span> n &gt; 0.49:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'You win!'</span>)
<span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'you lose.'</span>)
</pre>
</div>

<p>
The odds of you winning the last bet are slightly stacked in your favor. There is only a 49% chance your friend wins, but a 51% chance that you win. Lets play the game a lot of times times and see how many times you win, and your friend wins. First, lets generate a bunch of numbers and look at the distribution with a histogram.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">N</span> = 10000
<span style="color: #BA36A5;">games</span> = np.random.uniform(size=N)

wins = np.<span style="color: #006FE0;">sum</span>(games &gt; 0.49)
losses = N - wins

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'You won {0} times ({1:%})'</span>.<span style="color: #006FE0;">format</span>(wins, <span style="color: #006FE0;">float</span>(wins) / N))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #BA36A5;">count</span>, <span style="color: #BA36A5;">bins</span>, <span style="color: #BA36A5;">ignored</span> = plt.hist(games)
plt.savefig(<span style="color: #008000;">'images/random-thoughts-1.png'</span>)
</pre>
</div>


<div id="org34ba4ed" class="figure">
<p><img src="pycse-chapters/images/random-thoughts-1.png" alt="random-thoughts-1.png" />
</p>
</div>

<p>
As you can see you win slightly more than you lost.
</p>

<p>
It is possible to get random integers. Here are a few examples of getting a random integer between 1 and 100. You might do this to get random indices of a list, for example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">print</span>(np.random.random_integers(1, 100))
<span style="color: #0000FF;">print</span>(np.random.random_integers(1, 100, 3))
<span style="color: #0000FF;">print</span>(np.random.random_integers(1, 100, (2, 2)))
</pre>
</div>

<p>
The normal distribution is defined by \(f(x)=\frac{1}{\sqrt{2\pi \sigma^2}} \exp (-\frac{(x-\mu)^2}{2\sigma^2})\) where \(\mu\) is the mean value, and \(\sigma\) is the standard deviation. In the standard distribution, \(\mu=0\) and \(\sigma=1\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">mu</span> = 1
<span style="color: #BA36A5;">sigma</span> = 0.5
<span style="color: #0000FF;">print</span>(np.random.normal(mu, sigma))
<span style="color: #0000FF;">print</span>(np.random.normal(mu, sigma, 2))
</pre>
</div>

<p>
Let us compare the sampled distribution to the analytical distribution. We generate a large set of samples, and calculate the probability of getting each value using the matplotlib.pyplot.hist command.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">mu</span> = 0; <span style="color: #BA36A5;">sigma</span> = 1

<span style="color: #BA36A5;">N</span> = 5000
<span style="color: #BA36A5;">samples</span> = np.random.normal(mu, sigma, N)

<span style="color: #BA36A5;">counts</span>, <span style="color: #BA36A5;">bins</span>, <span style="color: #BA36A5;">ignored</span> = plt.hist(samples, 50, normed=<span style="color: #D0372D;">True</span>)

plt.plot(bins, 1.0/np.sqrt(2 * np.pi * sigma**2)*np.exp(-((bins - mu)**2)/(2*sigma**2)))
plt.savefig(<span style="color: #008000;">'images/random-thoughts-2.png'</span>)
</pre>
</div>


<div id="orga4ace77" class="figure">
<p><img src="pycse-chapters/images/random-thoughts-2.png" alt="random-thoughts-2.png" />
</p>
</div>

<p>
What fraction of points lie between plus and minus one standard deviation of the mean?
</p>

<p>
samples &gt;= mu-sigma will return a vector of ones where the inequality is true, and zeros where it is not. (samples &gt;= mu-sigma) &amp; (samples &lt;= mu+sigma) will return a vector of ones where there is a one in both vectors, and a zero where there is not. In other words, a vector where both inequalities are true. Finally, we can sum the vector to get the number of elements where the two inequalities are true, and finally normalize by the total number of samples to get the fraction of samples that are greater than -sigma and less than sigma.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">mu</span> = 0; <span style="color: #BA36A5;">sigma</span> = 1

<span style="color: #BA36A5;">N</span> = 5000
<span style="color: #BA36A5;">samples</span> = np.random.normal(mu, sigma, N)

<span style="color: #BA36A5;">a</span> = np.<span style="color: #006FE0;">sum</span>((samples &gt;= (mu - sigma)) &amp; (samples &lt;= (mu + sigma))) / <span style="color: #006FE0;">float</span>(N)
<span style="color: #BA36A5;">b</span> = np.<span style="color: #006FE0;">sum</span>((samples &gt;= (mu - 2*sigma)) &amp; (samples &lt;= (mu + 2*sigma))) / <span style="color: #006FE0;">float</span>(N)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:%} of samples are within +- standard deviations of the mean'</span>.<span style="color: #006FE0;">format</span>(a))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:%} of samples are within +- 2standard deviations of the mean'</span>.<span style="color: #006FE0;">format</span>(b))
</pre>
</div>
</div>

<div id="outline-container-org81aa4e7" class="outline-4">
<h4 id="org81aa4e7"><span class="section-number-4">6.8.1.</span> Summary</h4>
<div class="outline-text-4" id="text-6-8-1">
<p>
We only considered the numpy.random functions here, and not all of them. There are many distributions of random numbers to choose from. There are also random numbers in the python random module. Remember these are only <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudorandom</a> numbers, but they are still useful for many applications.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org8e5e2b2" class="outline-2">
<h2 id="org8e5e2b2"><span class="section-number-2">7.</span> Data analysis</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgbff29e7" class="outline-3">
<h3 id="orgbff29e7"><span class="section-number-3">7.1.</span> Fit a line to numerical data</h3>
<div class="outline-text-3" id="text-7-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/04/fit-a-line-to-numerical-data/">Matlab post</a>
</p>

<p>
We want to fit a line to this data:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">x</span> = [0, 0.5, 1, 1.5, 2.0, 3.0, 4.0, 6.0, 10]
<span style="color: #BA36A5;">y</span> = [0, -0.157, -0.315, -0.472, -0.629, -0.942, -1.255, -1.884, -3.147]
</pre>
</div>

<p>
We use the polyfit(x, y, n) command where n is the polynomial order, n=1 for a line.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">p</span> = np.polyfit(x, y, 1)
<span style="color: #0000FF;">print</span>(p)
<span style="color: #BA36A5;">slope</span>, <span style="color: #BA36A5;">intercept</span> = p
<span style="color: #0000FF;">print</span>(slope, intercept)
</pre>
</div>

<p>
To show the fit, we can use numpy.polyval to evaluate the fit at many points.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">xfit</span> = np.linspace(0, 10)
<span style="color: #BA36A5;">yfit</span> = np.polyval(p, xfit)

plt.plot(x, y, <span style="color: #008000;">'bo'</span>, label=<span style="color: #008000;">'raw data'</span>)
plt.plot(xfit, yfit, <span style="color: #008000;">'r-'</span>, label=<span style="color: #008000;">'fit'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.legend()
plt.savefig(<span style="color: #008000;">'images/linefit-1.png'</span>)
</pre>
</div>


<div id="orgcc0a259" class="figure">
<p><img src="pycse-chapters/images/linefit-1.png" alt="linefit-1.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgdfcc7c7" class="outline-3">
<h3 id="orgdfcc7c7"><span class="section-number-3">7.2.</span> Linear least squares fitting with linear algebra</h3>
<div class="outline-text-3" id="text-7-2">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/24/linear-least-squares-fitting-with-linear-algebra/">Matlab post</a>
</p>

<p>
The idea here is to formulate a set of linear equations that is easy to solve. We  can express the equations in terms of our unknown fitting parameters \(p_i\) as:
</p>

<pre class="example" id="org0033161">
x1^0*p0 + x1*p1 = y1
x2^0*p0 + x2*p1 = y2
x3^0*p0 + x3*p1 = y3
etc...
</pre>

<p>
Which we write in matrix form as \(A p = y\) where \(A\) is a matrix of column vectors, e.g. [1, x_i]. \(A\) is not a square matrix, so we cannot solve it as written. Instead, we form \(A^T A p = A^T y\) and solve that set of equations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">x</span> = np.array([0, 0.5, 1, 1.5, 2.0, 3.0, 4.0, 6.0, 10])
<span style="color: #BA36A5;">y</span> = np.array([0, -0.157, -0.315, -0.472, -0.629, -0.942, -1.255, -1.884, -3.147])

<span style="color: #BA36A5;">A</span> = np.column_stack([x**0, x])

<span style="color: #BA36A5;">M</span> = np.dot(A.T, A)
<span style="color: #BA36A5;">b</span> = np.dot(A.T, y)

<span style="color: #BA36A5;">i1</span>, <span style="color: #BA36A5;">slope1</span> = np.dot(np.linalg.inv(M), b)
<span style="color: #BA36A5;">i2</span>, <span style="color: #BA36A5;">slope2</span> = np.linalg.solve(M, b) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">an alternative approach.</span>

<span style="color: #0000FF;">print</span>(i1, slope1)
<span style="color: #0000FF;">print</span>(i2, slope2)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plot data and fit</span>
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.plot(x, y, <span style="color: #008000;">'bo'</span>)
plt.plot(x, np.dot(A, [i1, slope1]), <span style="color: #008000;">'r--'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.savefig(<span style="color: #008000;">'images/la-line-fit.png'</span>)
</pre>
</div>


<div id="org52491cd" class="figure">
<p><img src="pycse-chapters/images/la-line-fit.png" alt="la-line-fit.png" />
</p>
</div>

<p>
This method can be readily extended to fitting any polynomial model, or other linear model that is fit in a least squares sense. This method does not provide confidence intervals.
</p>
</div>
</div>

<div id="outline-container-orgb8b7e87" class="outline-3">
<h3 id="orgb8b7e87"><span class="section-number-3">7.3.</span> Linear regression with confidence intervals (updated)</h3>
<div class="outline-text-3" id="text-7-3">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/28/linear-regression-with-confidence-intervals/">Matlab post</a>
Fit a fourth order polynomial to this data and determine the confidence interval for each parameter. Data from example 5-1 in Fogler, Elements of Chemical Reaction Engineering.
</p>

<p>
We want the equation \(Ca(t) = b0 + b1*t + b2*t^2 + b3*t^3 + b4*t^4\) fit to the data in the least squares sense. We can write this in a linear algebra form as: T*p = Ca where T is a matrix of columns [1 t t^2 t^3 t^4], and p is a column vector of the fitting parameters. We want to solve for the p vector and estimate the confidence intervals.
</p>

<p>
<code>pycse</code> now has a regress function similar to Matlab. That function just uses the code in the next example (also seen <a href="http://jkitchin.github.io/blog/2013/02/18/Linear-regression-with-confidence-intervals/">here</a>).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> regress
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">time</span> = np.array([0.0, 50.0, 100.0, 150.0, 200.0, 250.0, 300.0])
<span style="color: #BA36A5;">Ca</span> = np.array([50.0, 38.0, 30.6, 25.6, 22.2, 19.5, 17.4])*1e-3

<span style="color: #BA36A5;">T</span> = np.column_stack([time**0, time, time**2, time**3, time**4])

<span style="color: #BA36A5;">alpha</span> = 0.05
<span style="color: #BA36A5;">p</span>, <span style="color: #BA36A5;">pint</span>, <span style="color: #BA36A5;">se</span> = regress(T, Ca, alpha)
<span style="color: #0000FF;">print</span>(pint)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf71d382" class="outline-3">
<h3 id="orgf71d382"><span class="section-number-3">7.4.</span> Linear regression with confidence intervals.</h3>
<div class="outline-text-3" id="text-7-4">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/28/linear-regression-with-confidence-intervals/">Matlab post</a>
Fit a fourth order polynomial to this data and determine the confidence interval for each parameter. Data from example 5-1 in Fogler, Elements of Chemical Reaction Engineering.
</p>

<p>
We want the equation \(Ca(t) = b0 + b1*t + b2*t^2 + b3*t^3 + b4*t^4\) fit to the data in the least squares sense. We can write this in a linear algebra form as: T*p = Ca where T is a matrix of columns [1 t t^2 t^3 t^4], and p is a column vector of the fitting parameters. We want to solve for the p vector and estimate the confidence intervals.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t

<span style="color: #BA36A5;">time</span> = np.array([0.0, 50.0, 100.0, 150.0, 200.0, 250.0, 300.0])
<span style="color: #BA36A5;">Ca</span> = np.array([50.0, 38.0, 30.6, 25.6, 22.2, 19.5, 17.4])*1e-3

<span style="color: #BA36A5;">T</span> = np.column_stack([time**0, time, time**2, time**3, time**4])

<span style="color: #BA36A5;">p</span>, <span style="color: #BA36A5;">res</span>, <span style="color: #BA36A5;">rank</span>, <span style="color: #BA36A5;">s</span> = np.linalg.lstsq(T, Ca)
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the parameters are now in p</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">compute the confidence intervals</span>
<span style="color: #BA36A5;">n</span> = <span style="color: #006FE0;">len</span>(Ca)
<span style="color: #BA36A5;">k</span> = <span style="color: #006FE0;">len</span>(p)

<span style="color: #BA36A5;">sigma2</span> = np.<span style="color: #006FE0;">sum</span>((Ca - np.dot(T, p))**2) / (n - k)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">RMSE</span>

<span style="color: #BA36A5;">C</span> = sigma2 * np.linalg.inv(np.dot(T.T, T)) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">covariance matrix</span>
<span style="color: #BA36A5;">se</span> = np.sqrt(np.diag(C)) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">standard error</span>

<span style="color: #BA36A5;">alpha</span> = 0.05 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">100*(1 - alpha) confidence level</span>

<span style="color: #BA36A5;">sT</span> = t.ppf(1.0 - alpha/2.0, n - k) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">student T multiplier</span>
<span style="color: #BA36A5;">CI</span> = sT * se

<span style="color: #0000FF;">for</span> beta, ci <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(p, CI):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{2: 1.2e} [{0: 1.4e} {1: 1.4e}]'</span>.<span style="color: #006FE0;">format</span>(beta - ci, beta + ci, beta))

<span style="color: #BA36A5;">SS_tot</span> = np.<span style="color: #006FE0;">sum</span>((Ca - np.mean(Ca))**2)
<span style="color: #BA36A5;">SS_err</span> = np.<span style="color: #006FE0;">sum</span>((np.dot(T, p) - Ca)**2)

<span style="color: #8D8D84;">#  </span><span style="color: #8D8D84; font-style: italic;">http://en.wikipedia.org/wiki/Coefficient_of_determination</span>
<span style="color: #BA36A5;">Rsq</span> = 1 - SS_err/SS_tot
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'R^2 = {0}'</span>.<span style="color: #006FE0;">format</span>(Rsq))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plot fit</span>
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(time, Ca, <span style="color: #008000;">'bo'</span>, label=<span style="color: #008000;">'raw data'</span>)
plt.plot(time, np.dot(T, p), <span style="color: #008000;">'r-'</span>, label=<span style="color: #008000;">'fit'</span>)
plt.xlabel(<span style="color: #008000;">'Time'</span>)
plt.ylabel(<span style="color: #008000;">'Ca (mol/L)'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/linregress-conf.png'</span>)
</pre>
</div>


<div id="org5baa51a" class="figure">
<p><img src="pycse-chapters/images/linregress-conf.png" alt="linregress-conf.png" />
</p>
</div>

<p>
A fourth order polynomial fits the data well, with a good R^2 value. All of the parameters appear to be significant, i.e. zero is not included in any of the parameter confidence intervals. This does not mean this is the best model for the data, just that the model fits well.
</p>
</div>
</div>

<div id="outline-container-org4bd7033" class="outline-3">
<h3 id="org4bd7033"><span class="section-number-3">7.5.</span> Nonlinear curve fitting</h3>
<div class="outline-text-3" id="text-7-5">
<p>
Here is a typical nonlinear function fit to data. you need to provide an initial guess. In this example we fit the Birch-Murnaghan equation of state to energy vs. volume data from density functional theory calculations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> leastsq
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">vols</span> = np.array([13.71, 14.82, 16.0, 17.23, 18.52])

<span style="color: #BA36A5;">energies</span> = np.array([-56.29, -56.41, -56.46, -56.463, -56.41])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Murnaghan</span>(parameters, vol):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'From Phys. Rev. B 28, 5480 (1983)'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">E0</span>, <span style="color: #BA36A5;">B0</span>, <span style="color: #BA36A5;">BP</span>, <span style="color: #BA36A5;">V0</span> = parameters

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">E</span> = E0 + B0 * vol / BP * (((V0 / vol)**BP) / (BP - 1) + 1) - V0 * B0 / (BP - 1.0)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> E

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(pars, y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we will minimize this function</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">err</span> =  y - Murnaghan(pars, x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> err

<span style="color: #BA36A5;">x0</span> = [ -56.0, 0.54, 2.0, 16.5] <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">initial guess of parameters</span>

<span style="color: #BA36A5;">plsq</span> = leastsq(objective, x0, args=(energies, vols))

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Fitted parameters = {0}'</span>.<span style="color: #006FE0;">format</span>(plsq[0]))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(vols,energies, <span style="color: #008000;">'ro'</span>)

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">plot the fitted curve on top</span>
x = np.linspace(<span style="color: #006FE0;">min</span>(vols), <span style="color: #006FE0;">max</span>(vols), 50)
y = Murnaghan(plsq[0], x)
plt.plot(x, y, <span style="color: #008000;">'k-'</span>)
plt.xlabel(<span style="color: #008000;">'Volume'</span>)
plt.ylabel(<span style="color: #008000;">'Energy'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlinear-curve-fitting.png'</span>)
</pre>
</div>


<div id="orgb7ddba3" class="figure">
<p><img src="pycse-chapters/images/nonlinear-curve-fitting.png" alt="nonlinear-curve-fitting.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Example of least-squares non-linear curve fitting.</p>
</div>

<p>
See additional examples at \url{http://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html}.
</p>
</div>
</div>

<div id="outline-container-org8318a31" class="outline-3">
<h3 id="org8318a31"><span class="section-number-3">7.6.</span> Nonlinear curve fitting by direct least squares minimization</h3>
<div class="outline-text-3" id="text-7-6">
<p>
Here is an example of fitting a nonlinear function to data by direct minimization of the summed squared error.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">volumes</span> = np.array([13.71, 14.82, 16.0, 17.23, 18.52])

<span style="color: #BA36A5;">energies</span> = np.array([-56.29, -56.41, -56.46, -56.463,-56.41])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Murnaghan</span>(parameters,vol):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'From PRB 28,5480 (1983'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">E0</span> = parameters[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">B0</span> = parameters[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">BP</span> = parameters[2]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">V0</span> = parameters[3]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">E</span> = E0 + B0*vol/BP*(((V0/vol)**BP)/(BP-1)+1) - V0*B0/(BP-1.)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> E

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(pars,vol):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we will minimize this function</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">err</span> =  energies - Murnaghan(pars,vol)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.<span style="color: #006FE0;">sum</span>(err**2) <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we return the summed squared error directly</span>

<span style="color: #BA36A5;">x0</span> = [ -56., 0.54, 2., 16.5] <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">initial guess of parameters</span>

<span style="color: #BA36A5;">plsq</span> = fmin(objective,x0,args=(volumes,)) <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">note args is a tuple</span>

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'parameters = {0}'</span>.<span style="color: #006FE0;">format</span>(plsq))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(volumes,energies,<span style="color: #008000;">'ro'</span>)

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">plot the fitted curve on top</span>
x = np.linspace(<span style="color: #006FE0;">min</span>(volumes),<span style="color: #006FE0;">max</span>(volumes),50)
y = Murnaghan(plsq,x)
plt.plot(x,y,<span style="color: #008000;">'k-'</span>)
plt.xlabel(<span style="color: #008000;">'Volume ($\AA^3$)'</span>)
plt.ylabel(<span style="color: #008000;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlinear-fitting-lsq.png'</span>)
</pre>
</div>


<div id="org57b3208" class="figure">
<p><img src="pycse-chapters/images/nonlinear-fitting-lsq.png" alt="nonlinear-fitting-lsq.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Fitting a nonlinear function.</p>
</div>
</div>
</div>
<div id="outline-container-orgfcbba45" class="outline-3">
<h3 id="orgfcbba45"><span class="section-number-3">7.7.</span> Parameter estimation by directly minimizing summed squared errors</h3>
<div class="outline-text-3" id="text-7-7">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/10/nonlinearfit_minsse-m/">Matlab post</a>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.array([0.0,       1.1,       2.3,      3.1,       4.05,      6.0])
<span style="color: #BA36A5;">y</span> = np.array([0.0039,    1.2270,    5.7035,   10.6472,   18.6032,   42.3024])

plt.plot(x, y)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlin-minsse-1.png'</span>)
</pre>
</div>


<div id="orgf93e167" class="figure">
<p><img src="pycse-chapters/images/nonlin-minsse-1.png" alt="nonlin-minsse-1.png" />
</p>
</div>

<p>
We are going to fit the function \(y = x^a\) to the data. The best \(a\) will minimize the summed squared error between the model and the fit.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">errfunc_</span>(a):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.<span style="color: #006FE0;">sum</span>((y - x**a)**2)

<span style="color: #BA36A5;">errfunc</span> = np.vectorize(errfunc_)

<span style="color: #BA36A5;">arange</span> = np.linspace(1, 3)
<span style="color: #BA36A5;">sse</span> = errfunc(arange)

plt.figure()
plt.plot(arange, sse)
plt.xlabel(<span style="color: #008000;">'a'</span>)
plt.ylabel(<span style="color: #008000;">'$\Sigma (y - y_{pred})^2$'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlin-minsse-2.png'</span>)
</pre>
</div>


<div id="org2ca7a66" class="figure">
<p><img src="pycse-chapters/images/nonlin-minsse-2.png" alt="nonlin-minsse-2.png" />
</p>
</div>

<p>
Based on the graph above, you can see a minimum in the summed squared error near \(a = 2.1\). We use that as our initial guess. Since we know the answer is bounded, we use scipy.optimize.fminbound
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fminbound

<span style="color: #BA36A5;">amin</span> = fminbound(errfunc, 1.0, 3.0)

<span style="color: #0000FF;">print</span>(amin)

plt.figure()
plt.plot(x, y, <span style="color: #008000;">'bo'</span>, label=<span style="color: #008000;">'data'</span>)
plt.plot(x, x**amin, <span style="color: #008000;">'r-'</span>, label=<span style="color: #008000;">'fit'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlin-minsse-3.png'</span>)
</pre>
</div>


<div id="org8f8dd43" class="figure">
<p><img src="pycse-chapters/images/nonlin-minsse-3.png" alt="nonlin-minsse-3.png" />
</p>
</div>

<p>
We can do nonlinear fitting by directly minimizing the summed squared error between a model and data. This method lacks some of the features of other methods, notably the simple ability to get the confidence interval. However, this method is flexible and may offer more insight into how the solution depends on the parameters.
</p>
</div>
</div>

<div id="outline-container-org3b0364a" class="outline-3">
<h3 id="org3b0364a"><span class="section-number-3">7.8.</span> Nonlinear curve fitting with parameter confidence intervals</h3>
<div class="outline-text-3" id="text-7-8">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/29/nonlinear-curve-fitting-with-parameter-confidence-intervals/">Matlab post</a>
</p>

<p>
We often need to estimate parameters from nonlinear regression of data. We should also consider how good the parameters are, and one way to do that is to consider the confidence interval. A confidence interval tells us a range that we are confident the true parameter lies in.
</p>

<p>
In this example we use a nonlinear curve-fitting function: scipy.optimize.curve_fit to give us the parameters in a function that we define which best fit the data. The scipy.optimize.curve_fit function also gives us the <a href="http://en.wikipedia.org/wiki/Covariance_matrix">covariance</a> matrix which we can use to estimate the standard error of each parameter. Finally,  we modify the standard error by a student-t value which accounts for the additional uncertainty in our estimates due to the small number of data points we are fitting to.
</p>

<p>
We will fit the function \(y = a x / (b + x)\) to some data, and compute the 95% confidence intervals on the parameters.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Nonlinear curve fit with confidence interval</span>
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> curve_fit
<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t

<span style="color: #BA36A5;">x</span> = np.array([0.5, 0.387, 0.24, 0.136, 0.04, 0.011])
<span style="color: #BA36A5;">y</span> = np.array([1.255, 1.25, 1.189, 1.124, 0.783, 0.402])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the function we want to fit to our data</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(x, a, b):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'nonlinear function in a and b to fit to data'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> a * x / (b + x)

<span style="color: #BA36A5;">initial_guess</span> = [1.2, 0.03]
<span style="color: #BA36A5;">pars</span>, <span style="color: #BA36A5;">pcov</span> = curve_fit(func, x, y, p0=initial_guess)

alpha = 0.05 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">95% confidence interval = 100*(1-alpha)</span>

n = <span style="color: #006FE0;">len</span>(y)    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of data points</span>
p = <span style="color: #006FE0;">len</span>(pars) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of parameters</span>

dof = <span style="color: #006FE0;">max</span>(0, n - p) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of degrees of freedom</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">student-t value for the dof and confidence level</span>
tval = t.ppf(1.0-alpha/2., dof)

<span style="color: #0000FF;">for</span> i, p,var <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(<span style="color: #006FE0;">range</span>(n), pars, np.diag(pcov)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sigma = var**0.5
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'p{0}: {1} [{2}  {3}]'</span>.<span style="color: #006FE0;">format</span>(i, p,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   p - sigma*tval,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   p + sigma*tval))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(x,y,<span style="color: #008000;">'bo '</span>)
xfit = np.linspace(0,1)
yfit = func(xfit, pars[0], pars[1])
plt.plot(xfit,yfit,<span style="color: #008000;">'b-'</span>)

plt.legend([<span style="color: #008000;">'data'</span>,<span style="color: #008000;">'fit'</span>],loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlin-curve-fit-ci.png'</span>)
</pre>
</div>


<div id="org5401c0a" class="figure">
<p><img src="pycse-chapters/images/nonlin-curve-fit-ci.png" alt="nonlin-curve-fit-ci.png" />
</p>
</div>

<p>
You can see by inspection that the fit looks pretty reasonable. The parameter confidence intervals are not too big, so we can be pretty confident of their values.
</p>
</div>
</div>

<div id="outline-container-orgf7065b6" class="outline-3">
<h3 id="orgf7065b6"><span class="section-number-3">7.9.</span> Nonlinear curve fitting with confidence intervals</h3>
<div class="outline-text-3" id="text-7-9">
<p>
Our goal is to fit this equation to data \(y = c1 exp(-x) + c2*x\) and compute the confidence intervals on the parameters.
</p>

<p>
This is actually could be a linear regression problem, but it is convenient to illustrate the  use the nonlinear fitting routine because it makes it easy to get
confidence intervals for comparison. The basic idea is to use the covariance matrix returned from the nonlinear fitting routine to estimate the student-t corrected confidence interval.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Nonlinear curve fit with confidence interval</span>
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> curve_fit
<span style="color: #0000FF;">from</span> scipy.stats.distributions <span style="color: #0000FF;">import</span>  t

<span style="color: #BA36A5;">x</span> = np.array([ 0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ])
<span style="color: #BA36A5;">y</span> = np.array([ 4.70192769,  4.46826356,  4.57021389,  4.29240134,  3.88155125,
               3.78382253,  3.65454727,  3.86379487,  4.16428541,  4.06079909])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the function we want to fit to our data</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(x,c0, c1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> c0 * np.exp(-x) + c1*x

<span style="color: #BA36A5;">pars</span>, <span style="color: #BA36A5;">pcov</span> = curve_fit(func, x, y, p0=[4.96, 2.11])

alpha = 0.05 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">95% confidence interval</span>

n = <span style="color: #006FE0;">len</span>(y)    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of data points</span>
p = <span style="color: #006FE0;">len</span>(pars) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of parameters</span>

dof = <span style="color: #006FE0;">max</span>(0, n-p) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of degrees of freedom</span>

tval = t.ppf(1.0 - alpha / 2.0, dof) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">student-t value for the dof and confidence level</span>

<span style="color: #0000FF;">for</span> i, p,var <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(<span style="color: #006FE0;">range</span>(n), pars, np.diag(pcov)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sigma = var**0.5
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'c{0}: {1} [{2}  {3}]'</span>.<span style="color: #006FE0;">format</span>(i, p,
                                        p - sigma*tval,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   p + sigma*tval))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(x,y,<span style="color: #008000;">'bo '</span>)
xfit = np.linspace(0,1)
yfit = func(xfit, pars[0], pars[1])
plt.plot(xfit,yfit,<span style="color: #008000;">'b-'</span>)
plt.legend([<span style="color: #008000;">'data'</span>,<span style="color: #008000;">'fit'</span>],loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/nonlin-fit-ci.png'</span>)
</pre>
</div>


<div id="orgb3346f3" class="figure">
<p><img src="pycse-chapters/images/nonlin-fit-ci.png" alt="nonlin-fit-ci.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Nonlinear fit to data.</p>
</div>
</div>
</div>
<div id="outline-container-org8d79233" class="outline-3">
<h3 id="org8d79233"><span class="section-number-3">7.10.</span> Graphical methods to help get initial guesses for multivariate nonlinear regression</h3>
<div class="outline-text-3" id="text-7-10">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/09/graphical-methods-to-help-get-initial-guesses-for-multivariate-nonlinear-regression/">Matlab post</a>
</p>

<p>
Fit the model f(x1,x2; a,b) = a*x1 + x2^b to the data given below. This model has two independent variables, and two parameters.
</p>

<p>
We want to do a nonlinear fit to find a and b that minimize the summed squared errors between the model predictions and the data. With only two variables, we can graph how the summed squared error varies with the parameters, which may help us get initial guesses. Let us assume the parameters lie in a range, here we choose 0 to 5. In other problems you would adjust this as needed.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> mpl_toolkits.mplot3d <span style="color: #0000FF;">import</span> Axes3D
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x1</span> = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
<span style="color: #BA36A5;">x2</span> = [0.2, 0.4, 0.8, 0.9, 1.1, 2.1]
<span style="color: #BA36A5;">X</span> = np.column_stack([x1, x2]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">independent variables</span>

<span style="color: #BA36A5;">f</span> = [ 3.3079,    6.6358,   10.3143,   13.6492,   17.2755,   23.6271]

<span style="color: #BA36A5;">fig</span> = plt.figure()
<span style="color: #BA36A5;">ax</span> = fig.gca(projection = <span style="color: #008000;">'3d'</span>)

ax.plot(x1, x2, f)
ax.set_xlabel(<span style="color: #008000;">'x1'</span>)
ax.set_ylabel(<span style="color: #008000;">'x2'</span>)
ax.set_zlabel(<span style="color: #008000;">'f(x1,x2)'</span>)

plt.savefig(<span style="color: #008000;">'images/graphical-mulvar-1.png'</span>)

arange = np.linspace(0,5);
brange = np.linspace(0,5);

<span style="color: #BA36A5;">A</span>,<span style="color: #BA36A5;">B</span> = np.meshgrid(arange, brange)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">model</span>(X, a, b):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'Nested function for the model'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x1 = X[:, 0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x2 = X[:, 1]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   f = a * x1 + x2**b
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f

<span style="color: #6434A3;">@np.vectorize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">errfunc</span>(a, b):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">function for the summed squared error</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   fit = model(X, a, b)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sse = np.<span style="color: #006FE0;">sum</span>((fit - f)**2)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> sse

SSE = errfunc(A, B)

plt.clf()
plt.contourf(A, B, SSE, 50)
plt.plot([3.2], [2.1], <span style="color: #008000;">'ro'</span>)
plt.figtext( 3.4, 2.2, <span style="color: #008000;">'Minimum near here'</span>, color=<span style="color: #008000;">'r'</span>)

plt.savefig(<span style="color: #008000;">'images/graphical-mulvar-2.png'</span>)

guesses = [3.18, 2.02]

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> curve_fit

<span style="color: #BA36A5;">popt</span>, <span style="color: #BA36A5;">pcov</span> = curve_fit(model, X, f, guesses)
<span style="color: #0000FF;">print</span>(popt)

plt.plot([popt[0]], [popt[1]], <span style="color: #008000;">'r*'</span>)
plt.savefig(<span style="color: #008000;">'images/graphical-mulvar-3.png'</span>)

<span style="color: #0000FF;">print</span>(model(X, *popt))

fig = plt.figure()
ax = fig.gca(projection = <span style="color: #008000;">'3d'</span>)

ax.plot(x1, x2, f, <span style="color: #008000;">'ko'</span>, label=<span style="color: #008000;">'data'</span>)
ax.plot(x1, x2, model(X, *popt), <span style="color: #008000;">'r-'</span>, label=<span style="color: #008000;">'fit'</span>)
ax.set_xlabel(<span style="color: #008000;">'x1'</span>)
ax.set_ylabel(<span style="color: #008000;">'x2'</span>)
ax.set_zlabel(<span style="color: #008000;">'f(x1,x2)'</span>)

plt.savefig(<span style="color: #008000;">'images/graphical-mulvar-4.png'</span>)
</pre>
</div>


<div id="org24973fc" class="figure">
<p><img src="pycse-chapters/images/graphical-mulvar-1.png" alt="graphical-mulvar-1.png" />
</p>
</div>


<div id="orgea9d34a" class="figure">
<p><img src="pycse-chapters/images/graphical-mulvar-2.png" alt="graphical-mulvar-2.png" />
</p>
</div>


<div id="org538787c" class="figure">
<p><img src="pycse-chapters/images/graphical-mulvar-3.png" alt="graphical-mulvar-3.png" />
</p>
</div>


<div id="org3eb654f" class="figure">
<p><img src="pycse-chapters/images/graphical-mulvar-4.png" alt="graphical-mulvar-4.png" />
</p>
</div>

<p>
It can be difficult to figure out initial guesses for nonlinear fitting problems. For one and two dimensional systems, graphical techniques may be useful to visualize how the summed squared error between the model and data depends on the parameters.
</p>
</div>
</div>

<div id="outline-container-orgaefd592" class="outline-3">
<h3 id="orgaefd592"><span class="section-number-3">7.11.</span> Fitting a numerical ODE solution to data</h3>
<div class="outline-text-3" id="text-7-11">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/29/fitting-a-numerical-ode-solution-to-data/">Matlab post</a>
</p>

<p>
Suppose we know the concentration of A follows this differential equation: \(\frac{dC_A}{dt} = -k C_A\), and we have data we want to fit to it. Here is an example of doing that.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> curve_fit
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">given data we want to fit</span>
<span style="color: #BA36A5;">tspan</span> = [0, 0.1, 0.2, 0.4, 0.8, 1]
<span style="color: #BA36A5;">Ca_data</span> = [2.0081,  1.5512,  1.1903,  0.7160,  0.2562,  0.1495]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fitfunc</span>(t, k):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'Function that returns Ca computed from an ODE for a k'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">myode</span>(Ca, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -k * Ca

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ca0</span> = Ca_data[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Casol</span> = odeint(myode, Ca0, t)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Casol[:,0]

<span style="color: #BA36A5;">k_fit</span>, <span style="color: #BA36A5;">kcov</span> = curve_fit(fitfunc, tspan, Ca_data, p0=1.3)
<span style="color: #0000FF;">print</span>(k_fit)

tfit = np.linspace(0,1);
fit = fitfunc(tfit, k_fit)

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(tspan, Ca_data, <span style="color: #008000;">'ro'</span>, label=<span style="color: #008000;">'data'</span>)
plt.plot(tfit, fit, <span style="color: #008000;">'b-'</span>, label=<span style="color: #008000;">'fit'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-fit.png'</span>)
</pre>
</div>


<div id="orgce326ca" class="figure">
<p><img src="pycse-chapters/images/ode-fit.png" alt="ode-fit.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org9458f40" class="outline-3">
<h3 id="org9458f40"><span class="section-number-3">7.12.</span> Reading in delimited text files</h3>
<div class="outline-text-3" id="text-7-12">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/07/reading-in-delimited-text-files/">Matlab post</a>
</p>

<p>
sometimes you will get data in a delimited text file format, .e.g. separated by commas or tabs. Matlab can read these in easily. Suppose we have a file containing this data:
</p>

<pre class="example" id="org2e8cca0">
1   3
3   4
5   6
4   8
</pre>

<p>
It is easy to read this directly into variables like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = np.loadtxt(<span style="color: #008000;">'data/testdata.txt'</span>, unpack=<span style="color: #D0372D;">True</span>)

<span style="color: #0000FF;">print</span>(x, y)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org21b3c09" class="outline-2">
<h2 id="org21b3c09"><span class="section-number-2">8.</span> Interpolation</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org3bbb5eb" class="outline-3">
<h3 id="org3bbb5eb"><span class="section-number-3">8.1.</span> Better interpolate than never</h3>
<div class="outline-text-3" id="text-8-1">
<p>
<a href="interpolation">interpolation</a>
<a href="http://matlab.cheme.cmu.edu/2012/02/02/better-interpolate-than-never/">Matlab post</a>
</p>

<p>
We often have some data that we have obtained in the lab, and we want to solve some problem using the data. For example, suppose we have this data that describes the value of f at time t.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">t</span> = [0.5, 1, 3, 6]
<span style="color: #BA36A5;">f</span> = [0.6065,    0.3679,    0.0498,    0.0025]
plt.plot(t, f)
plt.xlabel(<span style="color: #008000;">'t'</span>)
plt.ylabel(<span style="color: #008000;">'f(t)'</span>);
</pre>
</div>


<div id="org7309912" class="figure">
<p><img src="pycse-chapters/.ob-jupyter/3e6517632283c8f7ecad3123501540ec40337b75.png" alt="3e6517632283c8f7ecad3123501540ec40337b75.png" />
</p>
</div>
</div>

<div id="outline-container-orge1fa3a4" class="outline-4">
<h4 id="orge1fa3a4"><span class="section-number-4">8.1.1.</span> Estimate the value of f at t=2.</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
This is a simple interpolation problem.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d

<span style="color: #BA36A5;">g</span> = interp1d(t, f) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">default is linear interpolation</span>

<span style="color: #0000FF;">print</span>(g(2))
<span style="color: #0000FF;">print</span>(g([2, 3, 4]))
</pre>
</div>

<pre class="example">
0.20885
[0.20885    0.0498     0.03403333]
</pre>


<p>
The function we sample above is actually f(t) = exp(-t). The linearly interpolated example is not too accurate.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.exp(-2))
</pre>
</div>

<pre class="example">
0.1353352832366127
</pre>
</div>
</div>

<div id="outline-container-orgcd7c1c9" class="outline-4">
<h4 id="orgcd7c1c9"><span class="section-number-4">8.1.2.</span> improved interpolation?</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
<a href="interpolation!cubic">interpolation!cubic</a>
</p>

<p>
We can tell <code>interp1d</code> to use a different interpolation scheme such as cubic polynomial splines like this. For nonlinear functions, this may improve the accuracy of the interpolation, as it implicitly includes information about the curvature by fitting a cubic polynomial over neighboring points.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #BA36A5;">g2</span> = interp1d(t, f, <span style="color: #008000;">'cubic'</span>)
<span style="color: #0000FF;">print</span>(g2(2))
<span style="color: #0000FF;">print</span>(g2([2, 3, 4]))
</pre>
</div>

<pre class="example">
0.1084818181818181
[0.10848182 0.0498     0.08428727]
</pre>


<p>
Interestingly, this is a different value than Matlab's cubic interpolation. Let us show the cubic spline fit.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">plt.figure()
plt.plot(t, f)
plt.xlabel(<span style="color: #008000;">'t'</span>)
plt.ylabel(<span style="color: #008000;">'f(t)'</span>)

<span style="color: #BA36A5;">x</span> = np.linspace(0.5, 6)
<span style="color: #BA36A5;">fit</span> = g2(x)
plt.plot(x, fit, label=<span style="color: #008000;">'fit'</span>);
</pre>
</div>


<div id="orgdc0132a" class="figure">
<p><img src="pycse-chapters/.ob-jupyter/01b7a855580b41b124aae324cbd5070be4cb1285.png" alt="01b7a855580b41b124aae324cbd5070be4cb1285.png" />
</p>
</div>

<p>
Wow. That is a weird looking fit. Very different from what Matlab <a href="http://matlab.cheme.cmu.edu/wp-content/uploads/2012/02/interp_methods_02.png">produces</a>. This is a good teaching moment not to rely blindly on interpolation! We will rely on the linear interpolation from here out which behaves predictably.
</p>
</div>
</div>

<div id="outline-container-orgbfa87c5" class="outline-4">
<h4 id="orgbfa87c5"><span class="section-number-4">8.1.3.</span> The inverse question</h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
It is easy to interpolate a new value of f given a value of t. What if we want to know the time that f=0.2? We can approach this a few ways.
</p>
</div>

<div id="outline-container-orgda44005" class="outline-5">
<h5 id="orgda44005"><span class="section-number-5">8.1.3.1.</span> method 1</h5>
<div class="outline-text-5" id="text-8-1-3-1">
<p>
We setup a function that we can use fsolve on. The function will be equal to zero at the time. The second function will look like 0 = 0.2 - f(t). The answer for 0.2=exp(-t) is t = 1.6094. Since we use interpolation here, we will get an approximate answer.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0.2 - g(t)

<span style="color: #BA36A5;">initial_guess</span> = 2
<span style="color: #BA36A5;">ans</span>, = fsolve(func, initial_guess)
<span style="color: #0000FF;">print</span>(ans)
</pre>
</div>

<pre class="example">
2.055642879597611
</pre>
</div>
</div>



<div id="outline-container-org5963637" class="outline-5">
<h5 id="org5963637"><span class="section-number-5">8.1.3.2.</span> method 2: switch the interpolation order</h5>
<div class="outline-text-5" id="text-8-1-3-2">
<p>
We can switch the order of the interpolation to solve this problem. An issue we have to address in this method is that the "x" values must be monotonically <i>increasing</i>. It is somewhat subtle to reverse a list in python. I will use the cryptic syntax of [::-1] instead of the list.reverse() function or reversed() function. list.reverse() actually reverses the list "in place", which changes the contents of the variable. That is not what I want. reversed() returns an iterator which is also not what I want. [::-1] is a fancy indexing trick that returns a reversed list.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #BA36A5;">g3</span> = interp1d(f[::-1], t[::-1])

<span style="color: #0000FF;">print</span>(g3(0.2))
</pre>
</div>

<pre class="example">
2.055642879597611
</pre>
</div>
</div>
</div>

<div id="outline-container-orga0096cf" class="outline-4">
<h4 id="orga0096cf"><span class="section-number-4">8.1.4.</span> A harder problem</h4>
<div class="outline-text-4" id="text-8-1-4">
<p>
Suppose we want to know at what time is 1/f = 100? Now we have to decide what do we interpolate: f(t) or 1/f(t). Let us look at both ways and decide what is best. The answer to \(1/exp(-t) = 100\) is 4.6052
</p>
</div>

<div id="outline-container-orgcad19c2" class="outline-5">
<h5 id="orgcad19c2"><span class="section-number-5">8.1.4.1.</span> interpolate on f(t) then invert the interpolated number</h5>
<div class="outline-text-5" id="text-8-1-4-1">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'objective function. we do some error bounds because we cannot interpolate out of the range.'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> t &lt; 0.5: <span style="color: #BA36A5;">t</span>=0.5
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> t &gt; 6: <span style="color: #BA36A5;">t</span> = 6
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 100 - 1.0 / g(t)

<span style="color: #BA36A5;">initial_guess</span> = 4.5
<span style="color: #BA36A5;">a1</span>, = fsolve(func, initial_guess)
<span style="color: #0000FF;">print</span>(a1)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The %error is {0:%}'</span>.<span style="color: #006FE0;">format</span>((a1 - 4.6052)/4.6052))
</pre>
</div>

<pre class="example">
5.524312896405919
The %error is 19.958154%
</pre>
</div>
</div>

<div id="outline-container-orga8c98be" class="outline-5">
<h5 id="orga8c98be"><span class="section-number-5">8.1.4.2.</span> invert f(t) then interpolate on 1/f</h5>
<div class="outline-text-5" id="text-8-1-4-2">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #BA36A5;">ig</span> = interp1d(t, 1.0 / np.array(f))

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ifunc</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> t &lt; 0.5:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">t</span>=0.5
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> t &gt; 6:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">t</span> = 6
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 100 - ig(t)

<span style="color: #BA36A5;">initial_guess</span> = 4.5
<span style="color: #BA36A5;">a2</span>, = fsolve(ifunc, initial_guess)
<span style="color: #0000FF;">print</span>(a2)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The %error is {0:%}'</span>.<span style="color: #006FE0;">format</span>((a2 - 4.6052)/4.6052))
</pre>
</div>

<pre class="example">
3.63107822410148
The %error is -21.152649%
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb03afe" class="outline-4">
<h4 id="orgfb03afe"><span class="section-number-4">8.1.5.</span> Discussion</h4>
<div class="outline-text-4" id="text-8-1-5">
<p>
In this case you get different errors, one overestimates and one underestimates the answer, and by a lot: ± 20%. Let us look at what is happening.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d

<span style="color: #BA36A5;">t</span> = [0.5, 1, 3, 6]
<span style="color: #BA36A5;">f</span> = [0.6065,    0.3679,    0.0498,    0.0025]

<span style="color: #BA36A5;">x</span> = np.linspace(0.5, 6)


<span style="color: #BA36A5;">g</span> = interp1d(t, f) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">default is linear interpolation</span>
<span style="color: #BA36A5;">ig</span> = interp1d(t, 1.0 / np.array(f))

plt.figure()
plt.plot(t, 1 / np.array(f), <span style="color: #008000;">'ko '</span>, label=<span style="color: #008000;">'data'</span>)
plt.plot(x, 1 / g(x), label=<span style="color: #008000;">'1/interpolated f(x)'</span>)
plt.plot(x, ig(x), label=<span style="color: #008000;">'interpolate on 1/f(x)'</span>)
plt.plot(x, 1 / np.exp(-x), <span style="color: #008000;">'k--'</span>, label=<span style="color: #008000;">'1/exp(-x)'</span>)
plt.xlabel(<span style="color: #008000;">'t'</span>)
plt.ylabel(<span style="color: #008000;">'1/f(t)'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>);
</pre>
</div>


<div id="org986dc2a" class="figure">
<p><img src="pycse-chapters/.ob-jupyter/dae1004a5f1072888e924d24a256c3f2ee3aaa8e.png" alt="dae1004a5f1072888e924d24a256c3f2ee3aaa8e.png" />
</p>
</div>



<p>
You can see that the 1/interpolated f(x) underestimates the value, while interpolated (1/f(x)) overestimates the value. This is an example of where you clearly need more data in that range to make good estimates. Neither interpolation method is doing a great job. The trouble in reality is that you often do not know the real function to do this analysis. Here you can say the time is probably between 3.6 and 5.5 where 1/f(t) = 100, but you can not read much more than that into it. If you need a more precise answer, you need better data, or you need to use an approach other than interpolation. For example, you could fit an exponential function to the data and use that to estimate values at other times.
</p>

<p>
So which is the best to interpolate? I think you should interpolate the quantity that is linear in the problem you want to solve, so in this case I think interpolating 1/f(x) is better. When you use an interpolated function in a nonlinear function, strange, unintuitive things can happen. That is why the blue curve looks odd. Between data points are linear segments in the original interpolation, but when you invert them, you cause the curvature to form.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb7d3981" class="outline-3">
<h3 id="orgb7d3981"><span class="section-number-3">8.2.</span> Interpolation of data</h3>
<div class="outline-text-3" id="text-8-2">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/01/interpolation-of-data/">Matlab post</a>
</p>

<p>
When we have data at two points but we need data in between them we use interpolation. Suppose we have the points (4,3) and (6,2) and we want to know the value of y at x=4.65, assuming y varies linearly between these points. we use the interp1d command to achieve this. The syntax in python is slightly different than in matlab.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d

<span style="color: #BA36A5;">x</span> = [4, 6]
<span style="color: #BA36A5;">y</span> = [3, 2]

<span style="color: #BA36A5;">ifunc</span> = interp1d(x, y)

<span style="color: #0000FF;">print</span>(ifunc(4.65))


<span style="color: #BA36A5;">ifunc</span> = interp1d(x, y, bounds_error=<span style="color: #D0372D;">False</span>) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">do not raise error on out of bounds</span>
<span style="color: #0000FF;">print</span>(ifunc([4.65, 5.01, 4.2, 9]))
</pre>
</div>

<p>
The default interpolation method is simple linear interpolation between points. Other methods exist too, such as fitting a cubic spline to the data and using the spline representation to interpolate from.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d

<span style="color: #BA36A5;">x</span> = [1, 2, 3, 4];
<span style="color: #BA36A5;">y</span> = [1, 4, 9, 16]; <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">y = x^2</span>

<span style="color: #BA36A5;">xi</span> = [ 1.5, 2.5, 3.5]; <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we want to interpolate on these values</span>
<span style="color: #BA36A5;">y1</span> = interp1d(x,y)

<span style="color: #0000FF;">print</span>(y1(xi))

<span style="color: #BA36A5;">y2</span> = interp1d(x,y,<span style="color: #008000;">'cubic'</span>)
<span style="color: #0000FF;">print</span>(y2(xi))

<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">print</span>(np.array(xi)**2)
</pre>
</div>

<p>
In this case the cubic spline interpolation is  more accurate than the linear interpolation. That is because the underlying data was polynomial in nature, and a spline is like a polynomial. That may not always be the case, and you need some engineering judgement to know which method is best.
</p>
</div>
</div>

<div id="outline-container-org3f29aac" class="outline-3">
<h3 id="org3f29aac"><span class="section-number-3">8.3.</span> Interpolation with splines</h3>
<div class="outline-text-3" id="text-8-3">
<p>
When you do not know the functional form of data to fit an equation, you can still fit/interpolate with splines.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">use splines to fit and interpolate data</span>
<span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.array([ 0,      1,      2,      3,      4    ])
<span style="color: #BA36A5;">y</span> = np.array([ 0.,     0.308,  0.55,   0.546,  0.44 ])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">create the interpolating function</span>
<span style="color: #BA36A5;">f</span> = interp1d(x, y, kind=<span style="color: #008000;">'cubic'</span>, bounds_error=<span style="color: #D0372D;">False</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">to find the maximum, we minimize the negative of the function. We</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">cannot just multiply f by -1, so we create a new function here.</span>
f2 = interp1d(x, -y, kind=<span style="color: #008000;">'cubic'</span>)
xmax = fmin(f2, 2.5)

xfit = np.linspace(0,4)

plt.plot(x,y,<span style="color: #008000;">'bo'</span>)
plt.plot(xfit, f(xfit),<span style="color: #008000;">'r-'</span>)
plt.plot(xmax, f(xmax),<span style="color: #008000;">'g*'</span>)
plt.legend([<span style="color: #008000;">'data'</span>,<span style="color: #008000;">'fit'</span>,<span style="color: #008000;">'max'</span>], loc=<span style="color: #008000;">'best'</span>, numpoints=1)
plt.xlabel(<span style="color: #008000;">'x data'</span>)
plt.ylabel(<span style="color: #008000;">'y data'</span>)
plt.title(<span style="color: #008000;">'Max point = ({0:1.2f}, {1:1.2f})'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">float</span>(xmax),
                                                    <span style="color: #006FE0;">float</span>(f(xmax))))
plt.savefig(<span style="color: #008000;">'images/splinefit.png'</span>)
</pre>
</div>


<div id="orgde814cb" class="figure">
<p><img src="pycse-chapters/images/splinefit.png" alt="splinefit.png" />
</p>
<p><span class="figure-number">Figure 4: </span>Illustration of a spline fit to data and finding the maximum point.</p>
</div>

<p>
There are other good examples at <a href="http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html">http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org0588ad1" class="outline-2">
<h2 id="org0588ad1"><span class="section-number-2">9.</span> Optimization</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orga1e4b43" class="outline-3">
<h3 id="orga1e4b43"><span class="section-number-3">9.1.</span> Constrained optimization</h3>
<div class="outline-text-3" id="text-9-1">
<p>
<a href="optimization!constrained">optimization!constrained</a>
<a href="fmin_slsqp">fmin_slsqp</a>
<a href="http://matlab.cheme.cmu.edu/2011/12/24/constrained-optimization/">Matlab post</a>
</p>

<p>
adapted from <a href="http://en.wikipedia.org/wiki/Lagrange_multipliers">http://en.wikipedia.org/wiki/Lagrange_multipliers</a>.
</p>

<p>
Suppose we seek to minimize the function \(f(x,y)=x+y\) subject to the constraint that \(x^2 + y^2 = 1\). The function we seek to maximize is an unbounded plane, while the constraint is a unit circle. We could setup a Lagrange multiplier approach to solving this problem, but we will use a constrained optimization approach instead.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_slsqp

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x + y

<span style="color: #0000FF;">def</span> <span style="color: #006699;">eqc</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'equality constraint'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x**2 + y**2 - 1.0

<span style="color: #BA36A5;">X0</span> = [-1, -1]
<span style="color: #BA36A5;">X</span> = fmin_slsqp(objective, X0, eqcons=[eqc])
<span style="color: #0000FF;">print</span>(X)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1082f6c" class="outline-3">
<h3 id="org1082f6c"><span class="section-number-3">9.2.</span> Finding the maximum power of a photovoltaic device.</h3>
<div class="outline-text-3" id="text-9-2">
<p>
A photovoltaic device is characterized by a current-voltage relationship. Let us say, for argument's sake, that the relationship is known and defined by
</p>

<p>
\(i = 0.5 - 0.5 * V^2\)
</p>

<p>
The voltage is highest when the current is equal to zero, but of course then you get no power. The current is highest when the voltage is zero, i.e. short-circuited, but there is again no power. We seek the highest power condition, which is to find the maximum of \(i V\). This is a constrained optimization. We solve it by creating an objective function that returns the negative of (\i V\), and then find the minimum.
</p>

<p>
First, let us examine the i-V relationship.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">V</span> = np.linspace(0, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">i</span>(V):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0.5 - 0.5 * V**2

plt.figure()
plt.plot(V, i(V))
plt.savefig(<span style="color: #008000;">'images/iV.png'</span>)
</pre>
</div>


<div id="org2820d4b" class="figure">
<p><img src="pycse-chapters/images/iV.png" alt="iV.png" />
</p>
</div>


<p>
Now, let us be sure there is a maximum in power.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">V</span> = np.linspace(0, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">i</span>(V):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0.5 - 0.5 * V**2

plt.plot(V, i(V) * V)
plt.savefig(<span style="color: #008000;">'images/P1.png'</span>)
</pre>
</div>


<div id="orgce5be1f" class="figure">
<p><img src="pycse-chapters/images/P1.png" alt="P1.png" />
</p>
</div>

<p>
You can see in fact there is a maximum, near V=0.6. We could solve this problem analytically by taking the appropriate derivative and solving it for zero. That still might require solving a nonlinear problem though. We will directly setup and solve the constrained optimization.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_slsqp
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">V</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> - i * V

<span style="color: #0000FF;">def</span> <span style="color: #006699;">eqc</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'equality constraint'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">V</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> (0.5 - 0.5 * V**2) - i

<span style="color: #BA36A5;">X0</span> = [0.2, 0.6]
<span style="color: #BA36A5;">X</span> = fmin_slsqp(objective, X0, eqcons=[eqc])

imax, Vmax = X


V = np.linspace(0, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">i</span>(V):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0.5 - 0.5 * V**2

plt.plot(V, i(V), Vmax, imax, <span style="color: #008000;">'ro'</span>)
plt.savefig(<span style="color: #008000;">'images/P2.png'</span>)
</pre>
</div>


<div id="org2c04bf7" class="figure">
<p><img src="pycse-chapters/images/P2.png" alt="P2.png" />
</p>
</div>

<p>
You can see the maximum power is approximately 0.2 (unspecified units), at the conditions indicated by the red dot in the figure above.
</p>
</div>
</div>

<div id="outline-container-orgeae6f44" class="outline-3">
<h3 id="orgeae6f44"><span class="section-number-3">9.3.</span> Using Lagrange multipliers in optimization</h3>
<div class="outline-text-3" id="text-9-3">
<p>
<a href="optimization!Lagrange multipliers">optimization!Lagrange multipliers</a>
<a href="fsolve">fsolve</a>
<a href="http://matlab.cheme.cmu.edu/2011/12/24/using-lagrange-multipliers-in-optimization/">Matlab post</a>  (adapted from <a href="http://en.wikipedia.org/wiki/Lagrange_multipliers">http://en.wikipedia.org/wiki/Lagrange_multipliers</a>.)
</p>

<p>
Suppose we seek to maximize the function \(f(x,y)=x+y\) subject to the constraint that \(x^2 + y^2 = 1\). The function we seek to maximize is an unbounded plane, while the constraint is a unit circle. We want the maximum value of the circle, on the plane. We plot these two functions here.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x</span> = np.linspace(-1.5, 1.5)

[<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>] = np.meshgrid(x, x)

<span style="color: #0000FF;">import</span> matplotlib <span style="color: #0000FF;">as</span> mpl
<span style="color: #0000FF;">from</span> mpl_toolkits.mplot3d <span style="color: #0000FF;">import</span> Axes3D
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">fig</span> = plt.figure()
<span style="color: #BA36A5;">ax</span> = fig.gca(projection=<span style="color: #008000;">'3d'</span>)

ax.plot_surface(X, Y, X + Y)

theta = np.linspace(0,2*np.pi);
R = 1.0
x1 = R * np.cos(theta)
y1 = R * np.sin(theta)

ax.plot(x1, y1, x1 + y1, <span style="color: #008000;">'r-'</span>)
plt.savefig(<span style="color: #008000;">'images/lagrange-1.png'</span>)
</pre>
</div>


<div id="org1c940cd" class="figure">
<p><img src="pycse-chapters/images/lagrange-1.png" alt="lagrange-1.png" />
</p>
</div>
</div>

<div id="outline-container-orgafdd05b" class="outline-4">
<h4 id="orgafdd05b"><span class="section-number-4">9.3.1.</span> Construct the Lagrange multiplier augmented function</h4>
<div class="outline-text-4" id="text-9-3-1">
<p>
To find the maximum, we construct the following function: \(\Lambda(x,y; \lambda) = f(x,y)+\lambda g(x,y)\) where \(g(x,y) = x^2 + y^2 - 1 = 0\), which is the constraint function. Since \(g(x,y)=0\), we are not really changing the original function, provided that the constraint is met!
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = X[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = X[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">L</span> = X[2] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the multiplier. lambda is a reserved keyword in python</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x + y + L * (x**2 + y**2 - 1)
</pre>
</div>
</div>
</div>

<div id="outline-container-org588d175" class="outline-4">
<h4 id="org588d175"><span class="section-number-4">9.3.2.</span> Finding the partial derivatives</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
The minima/maxima of the augmented function are located where all of the partial derivatives of the augmented function are equal to zero, i.e. \(\partial \Lambda/\partial x = 0\), \(\partial \Lambda/\partial y = 0\), and \(\partial \Lambda/\partial \lambda = 0\). the process for solving this is usually to analytically evaluate the partial derivatives, and then solve the unconstrained resulting equations, which may be nonlinear.
</p>

<p>
Rather than perform the analytical differentiation, here we develop a way to numerically approximate the partial derivatives.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">dfunc</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dLambda</span> = np.zeros(<span style="color: #006FE0;">len</span>(X))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">h</span> = 1e-3 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the step size used in the finite difference.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(X)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dX</span> = np.zeros(<span style="color: #006FE0;">len</span>(X))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dX</span>[<span style="color: #BA36A5;">i</span>] = h
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dLambda</span>[<span style="color: #BA36A5;">i</span>] = (func(X+dX)-func(X-dX))/(2*h);
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> dLambda
</pre>
</div>
</div>
</div>

<div id="outline-container-orgccf3280" class="outline-4">
<h4 id="orgccf3280"><span class="section-number-4">9.3.3.</span> Now we solve for the zeros in the partial derivatives</h4>
<div class="outline-text-4" id="text-9-3-3">
<p>
The function we defined above (dfunc) will equal zero at a maximum or minimum. It turns out there are two solutions to this problem, but only one of them is the maximum value. Which solution you get depends on the initial guess provided to the solver. Here we have to use some judgement to identify the maximum.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the max</span>
<span style="color: #BA36A5;">X1</span> = fsolve(dfunc, [1, 1, 0])
<span style="color: #0000FF;">print</span>(X1, func(X1))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the min</span>
<span style="color: #BA36A5;">X2</span> = fsolve(dfunc, [-1, -1, 0])
<span style="color: #0000FF;">print</span>(X2, func(X2))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d166ea" class="outline-4">
<h4 id="org0d166ea"><span class="section-number-4">9.3.4.</span> Summary</h4>
<div class="outline-text-4" id="text-9-3-4">
<p>
Three dimensional plots in matplotlib are a little more difficult than in Matlab (where the code is almost the same as 2D plots, just different commands, e.g. plot vs plot3). In Matplotlib you have to import additional modules in the right order, and use the object oriented approach to plotting as shown here.
</p>
</div>
</div>
</div>

<div id="outline-container-org0c19395" class="outline-3">
<h3 id="org0c19395"><span class="section-number-3">9.4.</span> Linear programming example with inequality constraints</h3>
<div class="outline-text-3" id="text-9-4">
<p>
<a href="optimization!linear programming">optimization!linear programming</a>
<a href="http://matlab.cheme.cmu.edu/2011/10/21/linear-programming-example-with-inequality-constraints/">Matlab post</a>
</p>

<p>
adapted from <a href="http://www.matrixlab-examples.com/linear-programming.html">http://www.matrixlab-examples.com/linear-programming.html</a> which solves this problem with fminsearch.
</p>

<p>
Let us suppose that a merry farmer has 75 roods (4 roods = 1 acre) on which to plant two crops: wheat and corn. To produce these crops, it costs the farmer (for seed, water, fertilizer, etc. ) $120 per rood for the wheat, and $210 per rood for the corn. The farmer has $15,000 available for expenses, but after the harvest the farmer must store the crops while awaiting favorable or good market conditions. The farmer has storage space for 4,000 bushels. Each rood yields an average of 110 bushels of wheat or 30 bushels of corn. If the net profit per bushel of wheat (after all the expenses) is $1.30 and for corn is $2.00, how should the merry farmer plant the 75 roods to maximize profit?
</p>

<p>
Let \(x\) be the number of roods of wheat planted, and \(y\) be the number of roods of corn planted. The profit function is: \( P = (110)($1.3)x + (30)($2)y = 143x + 60y \)
</p>

<p>
There are some constraint inequalities, specified by the limits on expenses, storage and roodage. They are:
</p>

<p>
\(\$120x + \$210y <= \$15000\) (The total amount spent cannot exceed the amount the farm has)
</p>

<p>
\(110x + 30y <= 4000\) (The amount generated should not exceed storage space.)
</p>

<p>
\(x + y <= 75\) (We cannot plant more space than we have.)
</p>

<p>
\(0 <= x and 0 <= y \) (all amounts of planted land must be positive.)
</p>

<p>
To solve this problem, we cast it as a linear programming problem, which minimizes a function f(X) subject to some constraints. We create a proxy function for the negative of profit, which we seek to minimize.
</p>

<p>
f = -(143*x + 60*y)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_cobyla

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''objective function to minimize. It is the negative of profit,</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   which we seek to maximize.'''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -(143*x + 60*y)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">c1</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'Ensure 120x + 210y &lt;= 15000'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 15000 - 120 * x - 210*y

<span style="color: #0000FF;">def</span> <span style="color: #006699;">c2</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'ensure 110x + 30y &lt;= 4000'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 4000 - 110*x - 30 * y

<span style="color: #0000FF;">def</span> <span style="color: #006699;">c3</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'Ensure x + y is less than or equal to 75'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 75 - x - y

<span style="color: #0000FF;">def</span> <span style="color: #006699;">c4</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'Ensure x &gt;= 0'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> X[0]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">c5</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'Ensure y &gt;= 0'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> X[1]

<span style="color: #BA36A5;">X</span> = fmin_cobyla(objective, x0=[20, 30], cons=[c1, c2, c3, c4, c5])

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'We should plant {0:1.2f} roods of wheat.'</span>.<span style="color: #006FE0;">format</span>(X[0]))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'We should plant {0:1.2f} roods of corn'</span>.<span style="color: #006FE0;">format</span>(X[1]))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The maximum profit we can earn is ${0:1.2f}.'</span>.<span style="color: #006FE0;">format</span>(-objective(X)))
</pre>
</div>

<p>
This code is not exactly the same as the original <a href="http://matlab.cheme.cmu.edu/2011/10/21/linear-programming-example-with-inequality-constraints/">post</a>, but we get to the same answer. The linear programming capability in scipy is currently somewhat limited in 0.10. It is a little better in 0.11, but probably not as advanced as Matlab. There are some external libraries available:
</p>

<ol class="org-ol">
<li><a href="http://abel.ee.ucla.edu/cvxopt/">http://abel.ee.ucla.edu/cvxopt/</a></li>
<li><a href="http://openopt.org/LP">http://openopt.org/LP</a></li>
</ol>
</div>
</div>

<div id="outline-container-org0774576" class="outline-3">
<h3 id="org0774576"><span class="section-number-3">9.5.</span> Find the minimum distance from a point to a curve.</h3>
<div class="outline-text-3" id="text-9-5">
<p>
<a href="optimization!constrained">optimization!constrained</a>
A problem that can be cast as a constrained minimization problem is to find the minimum distance from a point to a curve. Suppose we have \(f(x) = x^2\), and the point (0.5, 2). what is the minimum distance from that point to \(f(x)\)?
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_cobyla

<span style="color: #BA36A5;">P</span> = (0.5, 2)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x**2

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.sqrt((x - P[0])**2 + (y - P[1])**2)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">c1</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f(x) - y

<span style="color: #BA36A5;">X</span> = fmin_cobyla(objective, x0=[0.5,0.5], cons=[c1])

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The minimum distance is {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(objective(X)))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Verify the vector to this point is normal to the tangent of the curve</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">position vector from curve to point</span>
v1 = np.array(P) - np.array(X)
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">position vector</span>
v2 = np.array([1, 2.0 * X[0]])
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'dot(v1, v2) = '</span>,np.dot(v1, v2))

x = np.linspace(-2, 2, 100)

plt.plot(x, f(x), <span style="color: #008000;">'r-'</span>, label=<span style="color: #008000;">'f(x)'</span>)
plt.plot(P[0], P[1], <span style="color: #008000;">'bo'</span>, label=<span style="color: #008000;">'point'</span>)
plt.plot([P[0], X[0]], [P[1], X[1]], <span style="color: #008000;">'b-'</span>, label=<span style="color: #008000;">'shortest distance'</span>)
plt.plot([X[0], X[0] + 1], [X[1], X[1] + 2.0 * X[0]], <span style="color: #008000;">'g-'</span>, label=<span style="color: #008000;">'tangent'</span>)
plt.axis(<span style="color: #008000;">'equal'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/min-dist-p-func.png'</span>)
</pre>
</div>


<div id="org2b9fcb5" class="figure">
<p><img src="pycse-chapters/images/min-dist-p-func.png" alt="min-dist-p-func.png" />
</p>
</div>

<p>
In the code above, we demonstrate that the point we find on the curve that minimizes the distance satisfies the property that a vector from that point to our other point is normal to the tangent of the curve at that point. This is shown by the fact that the dot product of the two vectors is very close to zero. It is not zero because of the accuracy criteria that is used to stop the minimization is not high enough.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc6b6323" class="outline-2">
<h2 id="orgc6b6323"><span class="section-number-2">10.</span> Differential equations</h2>
<div class="outline-text-2" id="text-10">
<p>
The key to successfully solving many differential equations is correctly classifying the equations, putting them into a standard form and then picking the appropriate solver. You must be able to determine if an equation is:
</p>

<ul class="org-ul">
<li>An ordinary differential equation \(Y' = f(x, Y)\) with
<ul class="org-ul">
<li>initial values (good support in python/numpy/scipy)</li>
<li>boundary values (not difficult to write code for simple cases)</li>
</ul></li>
<li>Delay differential equation</li>
<li>Differential algebraic equations</li>
<li>A partial differential equation</li>
</ul>

<p>
The following sections will illustrate the methods for solving these kinds of equations.
</p>
</div>
<div id="outline-container-org5362cc8" class="outline-3">
<h3 id="org5362cc8"><span class="section-number-3">10.1.</span> Ordinary differential equations</h3>
<div class="outline-text-3" id="text-10-1">
</div>
<div id="outline-container-org718eeb6" class="outline-4">
<h4 id="org718eeb6"><span class="section-number-4">10.1.1.</span> Numerical solution to a simple ode</h4>
<div class="outline-text-4" id="text-10-1-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/03/numerical-solution-to-a-simple-ode/">Matlab post</a>
</p>

<p>
Integrate this ordinary differential equation (ode):
</p>

<p>
\[\frac{dy}{dt} = y(t)\]
</p>

<p>
over the time span of 0 to 2. The initial condition is y(0) = 1.
</p>

<p>
to solve this equation, you need to create a function of the form: dydt = f(y, t) and then use one of the odesolvers, e.g. odeint.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fprime</span>(y,t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 25)
<span style="color: #BA36A5;">y0</span> = 1
<span style="color: #BA36A5;">ysol</span> = odeint(fprime, y0, tspan)
plt.figure(figsize=(4,3))
plt.plot(tspan, ysol, label=<span style="color: #008000;">'numerical solution'</span>)
plt.plot(tspan, np.exp(tspan), <span style="color: #008000;">'r--'</span>, label=<span style="color: #008000;">'analytical solution'</span>)
plt.xlabel(<span style="color: #008000;">'time'</span>)
plt.ylabel(<span style="color: #008000;">'y(t)'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/simple-ode.png'</span>)
plt.show()
</pre>
</div>

<p>
<img src="pycse-chapters/images/simple-ode.png" alt="simple-ode.png" />
.-p
The numerical and analytical solutions agree.
</p>

<p>
Now, suppose you want to know at what time is the solution equal to 3? There are several approaches to this, including setting up a solver, or using an event like approach to stop integration at y=3. A simple approach is to use reverse interpolation. We simply reverse the x and y vectors so that y is the independent variable, and we interpolate the corresponding x-value.
<a href="interpolation!reverse">interpolation!reverse</a>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fprime</span>(y,t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 2)
<span style="color: #BA36A5;">y0</span> = 1
<span style="color: #BA36A5;">ysol</span> = odeint(fprime, y0, tspan)

<span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d

<span style="color: #BA36A5;">ip</span> = interp1d(ysol[:,0], tspan) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reverse interpolation</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'y = 3 at x = {0}'</span>.<span style="color: #006FE0;">format</span>(ip(3)))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgdf351e4" class="outline-4">
<h4 id="orgdf351e4"><span class="section-number-4">10.1.2.</span> Plotting ODE solutions in cylindrical coordinates</h4>
<div class="outline-text-4" id="text-10-1-2">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/08/plot-the-solution-to-an-ode-in-cylindrical-coordinates-2/">Matlab post</a>
</p>

<p>
It is straightforward to plot functions in Cartesian coordinates. It is less convenient to plot them in cylindrical coordinates. Here we solve an ODE in cylindrical coordinates, and then convert the solution to Cartesian coordinates for simple plotting.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dfdt</span>(F, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">rho</span>, <span style="color: #BA36A5;">theta</span>, <span style="color: #BA36A5;">z</span> = F
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">drhodt</span> = 0   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">constant radius</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dthetadt</span> = 1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">constant angular velocity</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dzdt</span> = -1    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">constant dropping velocity</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [drhodt, dthetadt, dzdt]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial conditions</span>
<span style="color: #BA36A5;">rho0</span> = 1
<span style="color: #BA36A5;">theta0</span> = 0
<span style="color: #BA36A5;">z0</span> = 100

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 50, 500)
<span style="color: #BA36A5;">sol</span> = odeint(dfdt, [rho0, theta0, z0], tspan)

<span style="color: #BA36A5;">rho</span> = sol[:,0]
<span style="color: #BA36A5;">theta</span> = sol[:,1]
<span style="color: #BA36A5;">z</span> = sol[:,2]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">convert cylindrical coords to cartesian for plotting.</span>
<span style="color: #BA36A5;">X</span> = rho * np.cos(theta)
<span style="color: #BA36A5;">Y</span> = rho * np.sin(theta)

<span style="color: #0000FF;">from</span> mpl_toolkits.mplot3d <span style="color: #0000FF;">import</span> Axes3D
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #BA36A5;">fig</span> = plt.figure()
<span style="color: #BA36A5;">ax</span> = fig.gca(projection=<span style="color: #008000;">'3d'</span>)
ax.plot(X, Y, z)
plt.savefig(<span style="color: #008000;">'images/ode-cylindrical.png'</span>)
</pre>
</div>


<div id="org3edfaa6" class="figure">
<p><img src="pycse-chapters/images/ode-cylindrical.png" alt="ode-cylindrical.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orga0ca3e6" class="outline-4">
<h4 id="orga0ca3e6"><span class="section-number-4">10.1.3.</span> ODEs with discontinuous forcing functions</h4>
<div class="outline-text-4" id="text-10-1-3">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/01/odes-with-discontinuous-forcing-functions/">Matlab post</a>
</p>

<p>
Adapted from <a href="http://archives.math.utk.edu/ICTCM/VOL18/S046/paper.pdf">http://archives.math.utk.edu/ICTCM/VOL18/S046/paper.pdf</a>
</p>

<p>
A mixing tank initially contains 300 g of salt mixed into 1000 L of water. At t=0 min, a solution of 4 g/L salt enters the tank at 6 L/min. At t=10 min, the solution is changed to 2 g/L salt, still entering at 6 L/min. The tank is well stirred, and the tank solution leaves at a rate of 6 L/min. Plot the concentration of salt (g/L) in the tank as a function of time.
</p>

<p>
A mass balance on the salt in the tank leads to this differential equation: \(\frac{dM_S}{dt} = \nu C_{S,in}(t) - \nu M_S/V\) with the initial condition that \(M_S(t=0)=300\). The wrinkle is that the inlet conditions are not constant.
</p>

<p>
\[C_{S,in}(t) = \begin{array}{ll} 0 & t \le 0, \\ 4 & 0 < t \le 10, \\ 2 & t > 10. \end{array}\]
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">V</span> = 1000.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">L</span>
<span style="color: #BA36A5;">nu</span> = 6.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">L/min</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Cs_in</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'inlet concentration'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> t &lt; 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Cs</span> = 0.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">g/L</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> (t &gt; 0) <span style="color: #0000FF;">and</span> (t &lt;= 10):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Cs</span> = 4.0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   Cs = 2.0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Cs

<span style="color: #0000FF;">def</span> <span style="color: #006699;">mass_balance</span>(Ms, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'$\frac{dM_S}{dt} = \nu C_{S,in}(t) - \nu M_S/V$'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dMsdt</span> = nu * Cs_in(t) - nu * Ms / V
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> dMsdt

<span style="color: #BA36A5;">tspan</span> = np.linspace(0.0, 15.0, 50)

<span style="color: #BA36A5;">M0</span> = 300.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">gm salt</span>
<span style="color: #BA36A5;">Ms</span> = odeint(mass_balance, M0, tspan)

plt.plot(tspan, Ms/V, <span style="color: #008000;">'b.-'</span>)
plt.xlabel(<span style="color: #008000;">'Time (min)'</span>)
plt.ylabel(<span style="color: #008000;">'Salt concentration (g/L)'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-discont.png'</span>)
</pre>
</div>


<div id="org6e6c4e6" class="figure">
<p><img src="pycse-chapters/images/ode-discont.png" alt="ode-discont.png" />
</p>
</div>

<p>
You can see the discontinuity in the salt concentration at 10 minutes due to the discontinous change in the entering salt concentration.
</p>
</div>
</div>

<div id="outline-container-org9ced25d" class="outline-4">
<h4 id="org9ced25d"><span class="section-number-4">10.1.4.</span> Simulating the events feature of Matlab's ode solvers</h4>
<div class="outline-text-4" id="text-10-1-4">
<p>
The ode solvers in Matlab allow you create functions that define events that can stop the integration, detect roots, etc&#x2026; We will explore how to get a similar effect in python. Here is an example that somewhat does this, but it is only an approximation. We will manually integrate the ODE, adjusting the time step in each iteration to zero in on the solution. When the desired accuracy is reached, we stop the integration.
</p>

<p>
It does not appear that events are supported in scipy. A solution is at <a href="http://mail.scipy.org/pipermail/scipy-dev/2005-July/003078.html">http://mail.scipy.org/pipermail/scipy-dev/2005-July/003078.html</a>, but it does not appear integrated into scipy yet (8 years later ;).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dCadt</span>(Ca, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"the ode function"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">k</span> = 0.23
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -k * Ca**2

<span style="color: #BA36A5;">Ca0</span> = 2.3

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">create lists to store time span and solution</span>
<span style="color: #BA36A5;">tspan</span> = [0, ]
<span style="color: #BA36A5;">sol</span> = [Ca0,]
<span style="color: #BA36A5;">i</span> = 0

<span style="color: #0000FF;">while</span> i &lt; 100:   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">take max of 100 steps</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">t1</span> = tspan[i]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ca</span> = sol[i]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">pick the next time using a Newton-Raphson method</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we want f(t, Ca) = (Ca(t) - 1)**2 = 0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">df/dt = df/dCa dCa/dt</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#       </span><span style="color: #8D8D84; font-style: italic;">= 2*(Ca - 1) * dCadt</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">t2</span> = t1 - (Ca - 1.0)**2 / (2 * (Ca - 1) *dCadt(Ca, t1))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f</span> = odeint(dCadt, Ca, [t1, t2])

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> np.<span style="color: #006FE0;">abs</span>(Ca - 1.0) &lt;= 1e-4:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Solution reached at i = {0}'</span>.<span style="color: #006FE0;">format</span>(i))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">break</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   tspan += [t2]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sol.append(f[-1][0])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   i += 1

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'At t={0:1.2f}  Ca = {1:1.3f}'</span>.<span style="color: #006FE0;">format</span>(tspan[-1], sol[-1]))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(tspan, sol, <span style="color: #008000;">'bo'</span>)
plt.savefig(<span style="color: #008000;">'images/event-i.png'</span>)
</pre>
</div>


<div id="org2ad076a" class="figure">
<p><img src="pycse-chapters/images/event-i.png" alt="event-i.png" />
</p>
</div>

<p>
This particular solution works for this example, probably because it is well behaved. It is "downhill" to the desired solution. It is not obvious this would work for every example, and it is certainly possible the algorithm could go "backward" in time. A better approach might be to integrate forward until you detect a sign change in your event function, and then refine it in a separate loop.
</p>

<p>
I like the events integration in Matlab better, but this is actually pretty functional. It should not be too hard to use this for root counting, e.g. by counting sign changes. It would be considerably harder to get the actual roots. It might also be hard to get the positions of events that include the sign or value of the derivatives at the event points.
</p>

<p>
ODE solving in Matlab is considerably more advanced in functionality than in scipy. There do seem to be some extra packages, e.g. pydstools, scikits.odes that add extra ode functionality.
</p>
</div>
</div>

<div id="outline-container-org8fd94e6" class="outline-4">
<h4 id="org8fd94e6"><span class="section-number-4">10.1.5.</span> Mimicking ode events in python</h4>
<div class="outline-text-4" id="text-10-1-5">
<p>
The ODE functions in scipy.integrate do not directly support events like the functions in Matlab do. We can achieve something like it though, by digging into the guts of the solver, and writing a little code. In  previous <a href="http://matlab.cheme.cmu.edu/2011/09/10/counting-roots/">example</a> I used an event to count the number of roots in a function by integrating the derivative of the function.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #0000FF;">def</span> <span style="color: #006699;">myode</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 3*x**2 + 12*x -4

<span style="color: #0000FF;">def</span> <span style="color: #006699;">event</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'an event is when f = 0'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial conditions</span>
<span style="color: #BA36A5;">x0</span> = -8
<span style="color: #BA36A5;">f0</span> = -120

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">final x-range and step to integrate over.</span>
<span style="color: #BA36A5;">xf</span> = 4   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">final x value</span>
<span style="color: #BA36A5;">deltax</span> = 0.45 <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">xstep</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">lists to store the results in</span>
<span style="color: #BA36A5;">X</span> = [x0]
<span style="color: #BA36A5;">sol</span> = [f0]
<span style="color: #BA36A5;">e</span> = [event(f0, x0)]
<span style="color: #BA36A5;">events</span> = []
<span style="color: #BA36A5;">x2</span> = x0
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">manually integrate at each time step, and check for event sign changes at each step</span>
<span style="color: #0000FF;">while</span> x2 &lt;= <span style="color: #BA36A5;">xf</span>: <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">stop integrating when we get to xf</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x1 = X[-1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x2</span> = x1 + deltax
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f1</span> = sol[-1]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f2</span> = odeint(myode, f1, [x1, x2]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">integrate from x1,f1 to x2,f2</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">X</span> += [x2]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sol</span> += [f2[-1][0]]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now evaluate the event at the last position</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e</span> += [event(sol[-1], X[-1])]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> e[-1] * e[-2] &lt; 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Event detected where the sign of the event has changed. The</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">event is between xPt = X[-2] and xLt = X[-1]. run a modified bisect</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">function to narrow down to find where event = 0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">xLt</span> = X[-1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">fLt</span> = sol[-1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">eLt</span> = e[-1]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">xPt</span> = X[-2]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">fPt</span> = sol[-2]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ePt</span> = e[-2]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">j</span> = 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">while</span> j &lt; 100:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> np.<span style="color: #006FE0;">abs</span>(xLt - xPt) &lt; 1e-6:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we know the interval to a prescribed precision now.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'x = {0}, event = {1}, f = {2}'</span>.<span style="color: #006FE0;">format</span>(xLt, eLt, fLt))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   events += [(xLt, fLt)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">break</span> <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">and return to integrating</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   m = (ePt - eLt)/(xPt - xLt) <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">slope of line connecting points</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">bracketing zero</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">estimated x where the zero is</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   new_x = -ePt / m + xPt

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now get the new value of the integrated solution at that new x</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   f  = odeint(myode, fPt, [xPt, new_x])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   new_f = f[-1][-1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   new_e = event(new_f, new_x)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now check event sign change</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> eLt * new_e &gt; 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xPt = new_x
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   fPt = new_f
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ePt = new_e
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xLt = new_x
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   fLt = new_f
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   eLt = new_e

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   j += 1


<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(X, sol)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">add event points to the graph</span>
<span style="color: #0000FF;">for</span> x,e <span style="color: #0000FF;">in</span> events:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(x,e,<span style="color: #008000;">'bo '</span>)
plt.savefig(<span style="color: #008000;">'images/event-ode-1.png'</span>)
</pre>
</div>


<div id="orgb03e239" class="figure">
<p><img src="pycse-chapters/images/event-ode-1.png" alt="event-ode-1.png" />
</p>
</div>

<p>
That was a lot of programming to do something like find the roots of the function! Below is an example of using a function coded into pycse to solve the same problem. It is a bit more sophisticated because you can define whether an event is terminal, and the direction of the approach to zero for each event.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> *
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">myode</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 3*x**2 + 12*x -4

<span style="color: #0000FF;">def</span> <span style="color: #006699;">event1</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'an event is when f = 0 and event is decreasing'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">isterminal</span> = <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">direction</span> = -1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f, isterminal, direction

<span style="color: #0000FF;">def</span> <span style="color: #006699;">event2</span>(f, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'an event is when f = 0 and increasing'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">isterminal</span> = <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">direction</span> = 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f, isterminal, direction

<span style="color: #BA36A5;">f0</span> = -120

<span style="color: #BA36A5;">xspan</span> = np.linspace(-8, 4)
<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">F</span>, <span style="color: #BA36A5;">TE</span>, <span style="color: #BA36A5;">YE</span>, <span style="color: #BA36A5;">IE</span> = odelay(myode, f0, xspan, events=[event1, event2])

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(X, F, <span style="color: #008000;">'.-'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plot the event locations.use a different color for each event</span>
colors = <span style="color: #008000;">'rg'</span>

<span style="color: #0000FF;">for</span> x,y,i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(TE, YE, IE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot([x], [y], <span style="color: #008000;">'o'</span>, color=colors[i])

plt.savefig(<span style="color: #008000;">'images/event-ode-2.png'</span>)
<span style="color: #0000FF;">print</span>(TE, YE, IE)
</pre>
</div>


<div id="org79353b1" class="figure">
<p><img src="pycse-chapters/images/event-ode-2.png" alt="event-ode-2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org44413f2" class="outline-4">
<h4 id="org44413f2"><span class="section-number-4">10.1.6.</span> Solving an ode for a specific solution value</h4>
<div class="outline-text-4" id="text-10-1-6">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/31/solving-an-ode-for-a-specific-solution-value/">Matlab post</a>
The analytical solution to an ODE is a function, which can be solved to get a particular value, e.g. if the solution to an ODE is y(x) = exp(x), you can solve the solution to find the value of x that makes \(y(x)=2\). In a numerical solution to an ODE we get a vector of independent variable values, and the corresponding function values at those values. To solve for a particular function value we need a different approach. This post will show one way to do that in python.
</p>

<p>
Given that the concentration of a species A in a constant volume, batch reactor obeys this differential equation \(\frac{dC_A}{dt}=- k C_A^2\) with the initial condition \(C_A(t=0) = 2.3\) mol/L and \(k = 0.23\) L/mol/s, compute the time it takes for \(C_A\) to be reduced to 1 mol/L.
</p>

<p>
We will get a solution, then create an interpolating function and use fsolve to get the answer. <a href="interpolation!ODE">interpolation!ODE</a>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">k</span> = 0.23
<span style="color: #BA36A5;">Ca0</span> = 2.3

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dCadt</span>(Ca, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -k * Ca**2

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 10)

<span style="color: #BA36A5;">sol</span> = odeint(dCadt, Ca0, tspan)
<span style="color: #BA36A5;">Ca</span> = sol[:,0]

plt.plot(tspan, Ca)
plt.xlabel(<span style="color: #008000;">'Time (s)'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$ (mol/L)'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-specific-1.png'</span>)
</pre>
</div>


<div id="orgb568037" class="figure">
<p><img src="pycse-chapters/images/ode-specific-1.png" alt="ode-specific-1.png" />
</p>
</div>

<p>
You can see the solution is near two seconds. Now we create an interpolating function to evaluate the solution. We will plot the interpolating function on a finer grid to make sure it seems reasonable.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">ca_func</span> = interp1d(tspan, Ca, <span style="color: #008000;">'cubic'</span>)

<span style="color: #BA36A5;">itime</span> = np.linspace(0, 10, 200)

plt.figure()
plt.plot(tspan, Ca, <span style="color: #008000;">'.'</span>)
plt.plot(itime, ca_func(itime), <span style="color: #008000;">'b-'</span>)

plt.xlabel(<span style="color: #008000;">'Time (s)'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$ (mol/L)'</span>)
plt.legend([<span style="color: #008000;">'solution'</span>,<span style="color: #008000;">'interpolated'</span>])
plt.savefig(<span style="color: #008000;">'images/ode-specific-2.png'</span>)
</pre>
</div>


<div id="org8213f8c" class="figure">
<p><img src="pycse-chapters/images/ode-specific-2.png" alt="ode-specific-2.png" />
</p>
</div>

<p>
that loos pretty reasonable. Now we solve the problem.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">tguess</span> = 2.0
<span style="color: #BA36A5;">tsol</span>, = fsolve(<span style="color: #0000FF;">lambda</span> t: 1.0 - ca_func(t), tguess)
<span style="color: #0000FF;">print</span>(tsol)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">you might prefer an explicit function</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1.0 - ca_func(t)

<span style="color: #BA36A5;">tsol2</span>, = fsolve(func, tguess)
<span style="color: #0000FF;">print</span>(tsol2)
</pre>
</div>

<p>
That is it. Interpolation can provide a simple way to evaluate the numerical solution of an ODE at other values.
</p>

<p>
For completeness we examine a final way to construct the function. We can actually integrate the ODE in the function to evaluate the solution at the point of interest. If it is not computationally expensive to evaluate the ODE solution this works fine. Note, however, that the ODE will get integrated from 0 to the value t for each iteration of fsolve.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">tspan</span> = [0, t]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sol</span> = odeint(dCadt, Ca0, tspan)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1.0 - sol[-1]

<span style="color: #BA36A5;">tsol3</span>, = fsolve(func, tguess)
<span style="color: #0000FF;">print</span>(tsol3)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1db0277" class="outline-4">
<h4 id="org1db0277"><span class="section-number-4">10.1.7.</span> A simple first order ode evaluated at specific points</h4>
<div class="outline-text-4" id="text-10-1-7">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/05/a-simple-first-order-ode-evaluated-at-specific-points/">Matlab post</a>
</p>

<p>
We have integrated an ODE over a specific time span. Sometimes it is desirable to get the solution at specific points, e.g. at t = [0 0.2 0.4 0.8]; This could be desirable to compare with experimental measurements at those time points. This example demonstrates how to do that.
</p>

<p>
\[\frac{dy}{dt} = y(t)\]
</p>

<p>
The initial condition is y(0) = 1.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #BA36A5;">y0</span> = 1
<span style="color: #BA36A5;">tspan</span> = [0, 0.2, 0.4, 0.8]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dydt</span>(y, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y

<span style="color: #BA36A5;">Y</span> = odeint(dydt, y0, tspan)
<span style="color: #0000FF;">print</span>(Y[:,0])
</pre>
</div>
</div>
</div>

<div id="outline-container-org0cf4794" class="outline-4">
<h4 id="org0cf4794"><span class="section-number-4">10.1.8.</span> Stopping the integration of an ODE at some condition</h4>
<div class="outline-text-4" id="text-10-1-8">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/02/stopping-the-integration-of-an-ode-at-some-condition/">Matlab post</a>
<a href="ODE!event">ODE!event</a>
In Post 968 we learned how to get the numerical solution to an ODE, and then to use the deval function to solve the solution for a particular value. The deval function uses interpolation to evaluate the solution at other valuse. An alternative approach would be to stop the ODE integration when the solution has the value you want. That can be done in Matlab by using an "event" function. You setup an event function and tell the ode solver to use it by setting an option.
</p>

<p>
Given that the concentration of a species A in a constant volume, batch reactor obeys this differential equation \(\frac{dC_A}{dt}=- k C_A^2\) with the initial condition \(C_A(t=0) = 2.3\) mol/L and \(k = 0.23\) L/mol/s, compute the time it takes for \(C_A\) to be reduced to 1 mol/L.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> *
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">k</span> = 0.23
<span style="color: #BA36A5;">Ca0</span> = 2.3

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dCadt</span>(Ca, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -k * Ca**2

<span style="color: #0000FF;">def</span> <span style="color: #006699;">stop</span>(Ca, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">isterminal</span> = <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">direction</span> = 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">value</span> = 1.0 - Ca
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> value, isterminal, direction

<span style="color: #BA36A5;">tspan</span> = np.linspace(0.0, 10.0)

<span style="color: #BA36A5;">t</span>, <span style="color: #BA36A5;">CA</span>, <span style="color: #BA36A5;">TE</span>, <span style="color: #BA36A5;">YE</span>, <span style="color: #BA36A5;">IE</span> = odelay(dCadt, Ca0, tspan, events=[stop])

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'At t = {0:1.2f} seconds the concentration of A is {1:1.2f} mol/L.'</span>.<span style="color: #006FE0;">format</span>(t[-1], <span style="color: #006FE0;">float</span>(CA[-1])))
</pre>
</div>
</div>
</div>

<div id="outline-container-org818d186" class="outline-4">
<h4 id="org818d186"><span class="section-number-4">10.1.9.</span> Finding minima and maxima in ODE solutions with events</h4>
<div class="outline-text-4" id="text-10-1-9">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/17/finding-minima-and-maxima-in-ode-solutions-with-events">Matlab post</a>
<a href="ODE!event">ODE!event</a>
Today we look at another way to use events in an ode solver. We use an events function to find minima and maxima, by evaluating the ODE in the event function to find conditions where the first derivative is zero, and approached from the right direction. A maximum is when the fisrt derivative is zero and increasing, and a minimum is when the first derivative is zero and decreasing.
</p>

<p>
We use a simple ODE, \(y' = sin(x)*e^{-0.05x}\), which has minima and maxima.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> *
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ode</span>(y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.sin(x) * np.exp(-0.05 * x)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">minima</span>(y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''Approaching a minimum, dydx is negatime and going to zero. our event function is increasing'''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">value</span> = ode(y, x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">direction</span> = 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">isterminal</span> = <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> value,  isterminal, direction

<span style="color: #0000FF;">def</span> <span style="color: #006699;">maxima</span>(y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''Approaching a maximum, dydx is positive and going to zero. our event function is decreasing'''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">value</span> = ode(y, x)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">direction</span> = -1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">isterminal</span> = <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> value,  isterminal, direction

<span style="color: #BA36A5;">xspan</span> = np.linspace(0, 20, 100)

<span style="color: #BA36A5;">y0</span> = 0

<span style="color: #BA36A5;">X</span>, <span style="color: #BA36A5;">Y</span>, <span style="color: #BA36A5;">XE</span>, <span style="color: #BA36A5;">YE</span>, <span style="color: #BA36A5;">IE</span> = odelay(ode, y0, xspan, events=[minima, maxima])
<span style="color: #0000FF;">print</span>(IE)
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(X, Y)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">blue is maximum, red is minimum</span>
colors = <span style="color: #008000;">'rb'</span>
<span style="color: #0000FF;">for</span> xe, ye, ie <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(XE, YE, IE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot([xe], [ye], <span style="color: #008000;">'o'</span>, color=colors[ie])

plt.savefig(<span style="color: #008000;">'./images/ode-events-min-max.png'</span>)
</pre>
</div>


<div id="org1b692ad" class="figure">
<p><img src="pycse-chapters/images/ode-events-min-max.png" alt="ode-events-min-max.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org95658ea" class="outline-4">
<h4 id="org95658ea"><span class="section-number-4">10.1.10.</span> Error tolerance in numerical solutions to ODEs</h4>
<div class="outline-text-4" id="text-10-1-10">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/18/error-tolerance-in-numerical-solutions-to-odes/">Matlab post</a>
<a href="ODE!tolerance">ODE!tolerance</a>
Usually, the numerical ODE solvers in python work well with the standard settings. Sometimes they do not, and it is not always obvious they have not worked! Part of using a tool like python is checking how well your solution really worked. We use an example of integrating an ODE that defines the van der Waal equation of an ideal gas here.
</p>

<p>
we plot the analytical solution to the van der waal equation in reduced form here.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">Tr</span> = 0.9
<span style="color: #BA36A5;">Vr</span> = np.linspace(0.34,4,1000)

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">analytical equation for Pr</span>
<span style="color: #BA36A5;">Prfh</span> = <span style="color: #0000FF;">lambda</span> Vr: 8.0 / 3.0 * Tr / (Vr - 1.0 / 3.0) - 3.0 / (Vr**2)
<span style="color: #BA36A5;">Pr</span> = Prfh(Vr) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">evaluated on our reduced volume vector.</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Plot the EOS</span>
plt.clf()
plt.plot(Vr,Pr)
plt.ylim([0, 2])
plt.xlabel(<span style="color: #008000;">'$V_R$'</span>)
plt.ylabel(<span style="color: #008000;">'$P_R$'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-vw-1.png'</span>)
</pre>
</div>


<div id="org9e7912c" class="figure">
<p><img src="pycse-chapters/images/ode-vw-1.png" alt="ode-vw-1.png" />
</p>
</div>

<p>
we want an equation for dPdV, which we will integrate we use symbolic math to do the derivative for us.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> diff, Symbol
<span style="color: #BA36A5;">Vrs</span> = Symbol(<span style="color: #008000;">'Vrs'</span>)

<span style="color: #BA36A5;">Prs</span> = 8.0 / 3.0 * Tr / (Vrs - 1.0/3.0) - 3.0/(Vrs**2)
<span style="color: #0000FF;">print</span>(diff(Prs,Vrs))
</pre>
</div>

<p>
Now, we solve the ODE. We will specify a large relative tolerance criteria (Note the default is much smaller than what we show here).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #0000FF;">def</span> <span style="color: #006699;">myode</span>(Pr, Vr):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dPrdVr</span> = -2.4/(Vr - 0.333333333333333)**2 + 6.0/Vr**3
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> dPrdVr

<span style="color: #BA36A5;">Vspan</span> = np.linspace(0.334, 4)
<span style="color: #BA36A5;">Po</span> = Prfh(Vspan[0])
<span style="color: #BA36A5;">P</span> = odeint(myode, Po, Vspan, rtol=1e-4)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Plot the EOS</span>
plt.plot(Vr,Pr) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">analytical solution</span>
plt.plot(Vspan, P[:,0], <span style="color: #008000;">'r.'</span>)
plt.ylim([0, 2])
plt.xlabel(<span style="color: #008000;">'$V_R$'</span>)
plt.ylabel(<span style="color: #008000;">'$P_R$'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-vw-2.png'</span>)
</pre>
</div>


<div id="orge9238f0" class="figure">
<p><img src="pycse-chapters/images/ode-vw-2.png" alt="ode-vw-2.png" />
</p>
</div>

<p>
You can see there is disagreement between the analytical solution and numerical solution. The origin of this problem is accuracy at the initial condition, where the derivative is extremely large.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(myode(Po, 0.34))
</pre>
</div>

<p>
We can increase the tolerance criteria to get a better answer. The defaults in odeint are actually set to 1.49012e-8.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Vspan</span> = np.linspace(0.334, 4)
<span style="color: #BA36A5;">Po</span> = Prfh(Vspan[0])
<span style="color: #BA36A5;">P</span> = odeint(myode, Po, Vspan)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Plot the EOS</span>
plt.clf()
plt.plot(Vr,Pr) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">analytical solution</span>
plt.plot(Vspan, P[:,0], <span style="color: #008000;">'r.'</span>)
plt.ylim([0, 2])
plt.xlabel(<span style="color: #008000;">'$V_R$'</span>)
plt.ylabel(<span style="color: #008000;">'$P_R$'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-vw-3.png'</span>)
</pre>
</div>


<div id="orga570144" class="figure">
<p><img src="pycse-chapters/images/ode-vw-3.png" alt="ode-vw-3.png" />
</p>
</div>

<p>
The problem here was the derivative value varied by four orders of magnitude over the integration range, so the default tolerances were insufficient to accurately estimate the numerical derivatives over that range. Tightening the tolerances helped resolve that problem. Another approach might be to split the integration up into different regions. For instance, if instead of starting at Vr = 0.34, which is very close to a sigularity in the van der waal equation at Vr = 1/3, if you start at Vr = 0.5, the solution integrates just fine with the standard tolerances.
</p>
</div>
</div>

<div id="outline-container-org21de141" class="outline-4">
<h4 id="org21de141"><span class="section-number-4">10.1.11.</span> Solving parameterized ODEs over and over conveniently</h4>
<div class="outline-text-4" id="text-10-1-11">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/16/parameterized-odes/">Matlab post</a>
<a href="ODE!parameterized">ODE!parameterized</a>
Sometimes we have an ODE that depends on a parameter, and we want to solve the ODE for several parameter values. It is inconvenient to write an ode function for each parameter case. Here we examine a convenient way to solve this problem; we pass the parameter to the ODE at runtime. We consider the following ODE:
</p>

<p>
\[\frac{dCa}{dt} = -k Ca(t)\]
</p>

<p>
where \(k\) is a parameter, and we want to solve the equation for a couple of values of \(k\) to test the sensitivity of the solution on the parameter. Our question is, given \(Ca(t=0)=2\), how long does it take to get \(Ca = 1\), and how sensitive is the answer to small variations in \(k\)?
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">myode</span>(Ca, t, k):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'ODE definition'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dCadt</span> = -k * Ca
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> dCadt

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 0.5)
<span style="color: #BA36A5;">k0</span> = 2
<span style="color: #BA36A5;">Ca0</span> = 2

plt.figure(); plt.clf()

<span style="color: #0000FF;">for</span> k <span style="color: #0000FF;">in</span> [0.95 * k0, k0, 1.05 * k0]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sol</span> = odeint(myode, Ca0, tspan, args=(k,))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(tspan, sol, label=<span style="color: #008000;">'k={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(k))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'At t=0.5 Ca = {0:1.2f} mol/L'</span>.<span style="color: #006FE0;">format</span>(sol[-1][0]))

plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.xlabel(<span style="color: #008000;">'Time'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$ (mol/L)'</span>)
plt.savefig(<span style="color: #008000;">'images/parameterized-ode1.png'</span>)
</pre>
</div>


<div id="org6bf645e" class="figure">
<p><img src="pycse-chapters/images/parameterized-ode1.png" alt="parameterized-ode1.png" />
</p>
</div>

<p>
You can see there are some variations in the concentration at t = 0.5. You could over or underestimate the concentration if you have the wrong estimate of \(k\)! You have to use some judgement here to decide how long to run the reaction to ensure a target goal is met.
</p>
</div>
</div>
<div id="outline-container-orgc56812a" class="outline-4">
<h4 id="orgc56812a"><span class="section-number-4">10.1.12.</span> Yet another way to parameterize an ODE</h4>
<div class="outline-text-4" id="text-10-1-12">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/06/yet-another-way-to-parameterize-an-ode/">Matlab post</a>
<a href="ODE!parameterized">ODE!parameterized</a>
We previously examined a way to parameterize an ODE. In those methods, we either used an anonymous function to parameterize an ode function, or we used a nested function that used variables from the shared workspace.
</p>

<p>
We want a convenient way to solve \(dCa/dt = -k Ca\) for multiple values of \(k\). Here we use a trick to pass a parameter to an ODE through the initial conditions. We expand the ode function definition to include this parameter, and set its derivative to zero, effectively making it a constant.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ode</span>(F, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ca</span>, <span style="color: #BA36A5;">k</span> = F
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dCadt</span> = -k * Ca
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dkdt</span> = 0.0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [dCadt, dkdt]

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 4)

<span style="color: #BA36A5;">Ca0</span> = 1;
<span style="color: #BA36A5;">K</span> = [2.0, 3.0]
<span style="color: #0000FF;">for</span> k <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">K</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   F = odeint(ode, [Ca0, k], tspan)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ca</span> = F[:,0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(tspan, Ca, label=<span style="color: #008000;">'k={0}'</span>.<span style="color: #006FE0;">format</span>(k))
plt.xlabel(<span style="color: #008000;">'time'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-parameterized-1.png'</span>)
</pre>
</div>


<div id="org6cb1aa6" class="figure">
<p><img src="pycse-chapters/images/ode-parameterized-1.png" alt="ode-parameterized-1.png" />
</p>
</div>

<p>
I do not think this is a very elegant way to pass parameters around compared to the previous methods, but it nicely illustrates that there is more than one way to do it. And who knows, maybe it will be useful in some other context one day!
</p>
</div>
</div>

<div id="outline-container-org5943626" class="outline-4">
<h4 id="org5943626"><span class="section-number-4">10.1.13.</span> Another way to parameterize an ODE - nested function</h4>
<div class="outline-text-4" id="text-10-1-13">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/18/another-way-to-parameterize-an-ode-nested-function/">Matlab post</a>
<a href="ODE!parameterized">ODE!parameterized</a>
We saw one method to parameterize an ODE, by creating an ode function that takes an extra parameter argument, and then making a function handle that has the syntax required for the solver, and passes the parameter the ode function.
</p>

<p>
Here we define the ODE function in a loop. Since the nested function is in the namespace of the main function, it can "see" the values of the variables in the main function. We will use this method to look at the solution to the van der Pol equation for several different values of mu.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">MU</span> = [0.1, 1, 2, 5]
<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 100, 5000)
<span style="color: #BA36A5;">Y0</span> = [0, 3]

<span style="color: #0000FF;">for</span> mu <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">MU</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">define the ODE</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">vdpol</span>(Y, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = Y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dxdt</span> = y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dydt</span> = -x + mu * (1 - x**2) * y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span>  [dxdt, dydt]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Y</span> = odeint(vdpol, Y0, tspan)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = Y[:,0]; <span style="color: #BA36A5;">y</span> = Y[:,1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(x, y, label=<span style="color: #008000;">'mu={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(mu))

plt.axis(<span style="color: #008000;">'equal'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-nested-parameterization.png'</span>)
plt.savefig(<span style="color: #008000;">'images/ode-nested-parameterization.svg'</span>)
</pre>
</div>


<div id="orgb26db95" class="figure">
<p><img src="pycse-chapters/images/ode-nested-parameterization.png" alt="ode-nested-parameterization.png" />
</p>
</div>

<p>
You can see the solution changes dramatically for different values of mu. The point here is not to understand why, but to show an easy way to study a parameterize ode with a nested function. Nested functions can be a great way to "share" variables between functions especially for ODE solving, and nonlinear algebra solving, or any other application where you need a lot of parameters defined in one function in another function.
</p>
</div>
</div>

<div id="outline-container-org690d413" class="outline-4">
<h4 id="org690d413"><span class="section-number-4">10.1.14.</span> Solving a second order ode</h4>
<div class="outline-text-4" id="text-10-1-14">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/26/solving-a-second-order-ode/">Matlab post</a>
<a href="ODE!second order">ODE!second order</a>
</p>

<p>
The odesolvers in scipy can only solve first order ODEs, or systems of first order ODES. To solve a second order ODE, we must convert it by changes of variables to a system of first order ODES. We consider the Van der Pol oscillator here:
</p>

<p>
\[\frac{d^2x}{dt^2} - \mu(1-x^2)\frac{dx}{dt} + x = 0\]
</p>

<p>
\(\mu\) is a constant. If we let \(y=x - x^3/3\) <a href="http://en.wikipedia.org/wiki/Van_der_Pol_oscillator">http://en.wikipedia.org/wiki/Van_der_Pol_oscillator</a>, then we arrive at this set of equations:
</p>

<p>
\[\frac{dx}{dt} = \mu(x-1/3x^3-y)\]
</p>

<p>
\[\frac{dy}{dt} = \mu/x\]
</p>

<p>
here is how we solve this set of equations. Let \(\mu=1\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">mu</span> = 1.0

<span style="color: #0000FF;">def</span> <span style="color: #006699;">vanderpol</span>(X, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = X[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = X[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dxdt</span> = mu * (x - 1./3.*x**3 - y)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dydt</span> = x / mu
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [dxdt, dydt]

<span style="color: #BA36A5;">X0</span> = [1, 2]
<span style="color: #BA36A5;">t</span> = np.linspace(0, 40, 250)

<span style="color: #BA36A5;">sol</span> = odeint(vanderpol, X0, t)

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #BA36A5;">x</span> = sol[:, 0]
<span style="color: #BA36A5;">y</span> = sol[:, 1]

plt.plot(t,x, t, y)
plt.xlabel(<span style="color: #008000;">'t'</span>)
plt.legend((<span style="color: #008000;">'x'</span>, <span style="color: #008000;">'y'</span>))
plt.savefig(<span style="color: #008000;">'images/vanderpol-1.png'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">phase portrait</span>
plt.figure()
plt.plot(x,y)
plt.plot(x[0], y[0], <span style="color: #008000;">'ro'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.savefig(<span style="color: #008000;">'images/vanderpol-2.png'</span>)
</pre>
</div>


<div id="org2fbbe74" class="figure">
<p><img src="pycse-chapters/images/vanderpol-1.png" alt="vanderpol-1.png" />
</p>
</div>

<p>
Here is the phase portrait. You can see that a limit cycle is approached, indicating periodicity in the solution.
</p>


<div id="orgb2b868c" class="figure">
<p><img src="pycse-chapters/images/vanderpol-2.png" alt="vanderpol-2.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org6ed0352" class="outline-4">
<h4 id="org6ed0352"><span class="section-number-4">10.1.15.</span> Solving Bessel's Equation numerically</h4>
<div class="outline-text-4" id="text-10-1-15">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/08/solving-bessels-equation-numerically/">Matlab post</a>
</p>

<p>
Reference Ch 5.5 Kreysig, Advanced Engineering Mathematics, 9th ed.
</p>

<p>
Bessel's equation \(x^2 y'' + x y' + (x^2 - \nu^2)y=0\) comes up often in engineering problems such as heat transfer. The solutions to this equation are the Bessel functions. To solve this equation numerically, we must convert it to a system of first order ODEs. This can be done by letting \(z = y'\) and \(z' = y''\) and performing the change of variables:
</p>

<p>
\[ y' = z\]
</p>

<p>
\[ z' = \frac{1}{x^2}(-x z - (x^2 - \nu^2) y\]
</p>

<p>
if we take the case where \(\nu = 0\), the solution is known to be the Bessel function \(J_0(x)\), which is represented in Matlab as besselj(0,x). The initial conditions for this problem are: \(y(0) = 1\) and \(y'(0)=0\).
</p>

<p>
There is a problem with our system of ODEs at x=0. Because of the \(1/x^2\) term, the ODEs are not defined at x=0. If we start very close to zero instead, we avoid the problem.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">from</span> scipy.special <span style="color: #0000FF;">import</span> jn <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">bessel function</span>
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fbessel</span>(Y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">nu</span> = 0.0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = Y[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">z</span> = Y[1]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dydx</span> = z
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dzdx</span> = 1.0 / x**2 * (-x * z - (x**2 - nu**2) * y)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [dydx, dzdx]

<span style="color: #BA36A5;">x0</span> = 1e-15
<span style="color: #BA36A5;">y0</span> = 1
<span style="color: #BA36A5;">z0</span> = 0
<span style="color: #BA36A5;">Y0</span> = [y0, z0]

<span style="color: #BA36A5;">xspan</span> = np.linspace(1e-15, 10)
<span style="color: #BA36A5;">sol</span> = odeint(fbessel, Y0, xspan)

plt.plot(xspan, sol[:,0], label=<span style="color: #008000;">'numerical soln'</span>)
plt.plot(xspan, jn(0, xspan), <span style="color: #008000;">'r--'</span>, label=<span style="color: #008000;">'Bessel'</span>)
plt.legend()
plt.savefig(<span style="color: #008000;">'images/bessel.png'</span>)
</pre>
</div>


<div id="org6bae53d" class="figure">
<p><img src="pycse-chapters/images/bessel.png" alt="bessel.png" />
</p>
</div>

<p>
You can see the numerical and analytical solutions overlap, indicating they are at least visually the same.
</p>
</div>
</div>

<div id="outline-container-org6ad325b" class="outline-4">
<h4 id="org6ad325b"><span class="section-number-4">10.1.16.</span> Phase portraits of a system of ODEs</h4>
<div class="outline-text-4" id="text-10-1-16">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/09/phase-portraits-of-a-system-of-odes/">Matlab post</a>
An undamped pendulum with no driving force is described by
</p>

<p>
\[ y'' + sin(y) = 0\]
</p>

<p>
We reduce this to standard matlab form of a system of first order ODEs by letting \(y_1 = y\) and \(y_2=y_1'\). This leads to:
</p>

<p>
\(y_1' = y_2\)
</p>

<p>
\(y_2' = -sin(y_1)\)
</p>

<p>
The phase portrait is a plot of a vector field which qualitatively shows how the solutions to these equations will go from a given starting point. here is our definition of the differential equations:
</p>

<p>
To generate the phase portrait, we need to compute the derivatives \(y_1'\) and \(y_2'\) at \(t=0\) on a grid over the range of values for \(y_1\) and \(y_2\) we are interested in. We will plot the derivatives as a vector at each (y1, y2) which will show us the initial direction from each point. We will examine the solutions over the range -2 &lt; y1 &lt; 8, and -2 &lt; y2 &lt; 2 for y2, and create a grid of 20 x 20 points.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(Y, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y1</span>, <span style="color: #BA36A5;">y2</span> = Y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [y2, -np.sin(y1)]

<span style="color: #BA36A5;">y1</span> = np.linspace(-2.0, 8.0, 20)
<span style="color: #BA36A5;">y2</span> = np.linspace(-2.0, 2.0, 20)

<span style="color: #BA36A5;">Y1</span>, <span style="color: #BA36A5;">Y2</span> = np.meshgrid(y1, y2)

<span style="color: #BA36A5;">t</span> = 0

<span style="color: #BA36A5;">u</span>, <span style="color: #BA36A5;">v</span> = np.zeros(Y1.shape), np.zeros(Y2.shape)

<span style="color: #BA36A5;">NI</span>, <span style="color: #BA36A5;">NJ</span> = Y1.shape

<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(NI):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(NJ):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = Y1[i, j]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = Y2[i, j]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yprime</span> = f([x, y], t)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">u</span>[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = yprime[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">v</span>[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = yprime[1]


<span style="color: #BA36A5;">Q</span> = plt.quiver(Y1, Y2, u, v, color=<span style="color: #008000;">'r'</span>)

plt.xlabel(<span style="color: #008000;">'$y_1$'</span>)
plt.ylabel(<span style="color: #008000;">'$y_2$'</span>)
plt.xlim([-2, 8])
plt.ylim([-4, 4])
plt.savefig(<span style="color: #008000;">'images/phase-portrait.png'</span>)
</pre>
</div>


<div id="orga2ebb0e" class="figure">
<p><img src="pycse-chapters/images/phase-portrait.png" alt="phase-portrait.png" />
</p>
</div>

<p>
Let us plot a few solutions on the vector field. We will consider the solutions where y1(0)=0, and values of y2(0) = [0 0.5 1 1.5 2 2.5], in otherwords we start the pendulum at an angle of zero, with some angular velocity.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

plt.clf()
<span style="color: #0000FF;">for</span> y20 <span style="color: #0000FF;">in</span> [0, 0.5, 1, 1.5, 2, 2.5]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">tspan</span> = np.linspace(0, 50, 200)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y0</span> = [0.0, y20]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ys</span> = odeint(f, y0, tspan)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(ys[:,0], ys[:,1], <span style="color: #008000;">'b-'</span>) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">path</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot([ys[0,0]], [ys[0,1]], <span style="color: #008000;">'o'</span>) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">start</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot([ys[-1,0]], [ys[-1,1]], <span style="color: #008000;">'s'</span>) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">end</span>


plt.xlim([-2, 8])
plt.savefig(<span style="color: #008000;">'images/phase-portrait-2.png'</span>)
plt.savefig(<span style="color: #008000;">'images/phase-portrait-2.svg'</span>)
</pre>
</div>


<div id="orgbe001e0" class="figure">
<p><img src="pycse-chapters/images/phase-portrait-2.png" alt="phase-portrait-2.png" />
</p>
</div>

<p>
What do these figures mean? For starting points near the origin, and small velocities, the pendulum goes into a stable limit cycle. For others, the trajectory appears to fly off into y1 space. Recall that y1 is an angle that has values from \(-\pi\) to \(\pi\). The y1 data in this case is not wrapped around to be in this range.
</p>
</div>
</div>

<div id="outline-container-org780f11c" class="outline-4">
<h4 id="org780f11c"><span class="section-number-4">10.1.17.</span> Linear algebra approaches to solving systems of constant coefficient ODEs</h4>
<div class="outline-text-4" id="text-10-1-17">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/20/linear-algebra-approaches-to-solving-systems-of-constant-coefficient-odes">Matlab post</a>
<a href="ODE!coupled">ODE!coupled</a>
Today we consider how to solve a system of first order, constant coefficient ordinary differential equations using linear algebra. These equations could be solved numerically, but in this case there are analytical solutions that can be derived. The equations we will solve are:
</p>

<p>
\(y'_1 = -0.02 y_1 + 0.02 y_2\)
</p>

<p>
\(y'_2 = 0.02 y_1 - 0.02 y_2\)
</p>

<p>
We can express this set of equations in matrix form as: \(\left[\begin{array}{c}y'_1\\y'_2\end{array}\right] = \left[\begin{array}{cc} -0.02 & 0.02 \\ 0.02 & -0.02\end{array}\right] \left[\begin{array}{c}y_1\\y_2\end{array}\right]\)
</p>

<p>
The general solution to this set of equations is
</p>

<p>
\(\left[\begin{array}{c}y_1\\y_2\end{array}\right] = \left[\begin{array}{cc}v_1 & v_2\end{array}\right] \left[\begin{array}{cc} c_1 & 0 \\ 0 & c_2\end{array}\right] \exp\left(\left[\begin{array}{cc} \lambda_1 & 0 \\ 0 & \lambda_2\end{array}\right] \left[\begin{array}{c}t\\t\end{array}\right]\right)\)
</p>

<p>
where \(\left[\begin{array}{cc} \lambda_1 & 0 \\ 0 & \lambda_2\end{array}\right]\) is a diagonal matrix of the eigenvalues of the constant coefficient matrix, \(\left[\begin{array}{cc}v_1 & v_2\end{array}\right]\) is a matrix of eigenvectors where the \(i^{th}\) column corresponds to the eigenvector of the \(i^{th}\) eigenvalue, and \(\left[\begin{array}{cc} c_1 & 0 \\ 0 & c_2\end{array}\right]\) is a matrix determined by the initial conditions.
</p>

<p>
In this example, we evaluate the solution using linear algebra. The initial conditions we will consider are \(y_1(0)=0\) and \(y_2(0)=150\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[-0.02,  0.02],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [ 0.02, -0.02]])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.</span>
<span style="color: #BA36A5;">evals</span>, <span style="color: #BA36A5;">evecs</span> = np.linalg.eigh(A)
<span style="color: #0000FF;">print</span>(evals)
<span style="color: #0000FF;">print</span>(evecs)
</pre>
</div>

<p>
The eigenvectors are the <i>columns</i> of evecs.
</p>

<p>
Compute the \(c\) matrix
</p>

<p>
V*c = Y0
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Y0</span> = [0, 150]

<span style="color: #BA36A5;">c</span> = np.diag(np.linalg.solve(evecs, Y0))
<span style="color: #0000FF;">print</span>(c)
</pre>
</div>

<p>
Constructing the solution
</p>

<p>
We will create a vector of time values, and stack them for each solution, \(y_1(t)\) and \(Y_2(t)\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">t</span> = np.linspace(0, 100)
<span style="color: #BA36A5;">T</span> = np.row_stack([t, t])

<span style="color: #BA36A5;">D</span> = np.diag(evals)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">y = V*c*exp(D*T);</span>
<span style="color: #BA36A5;">y</span> = np.dot(np.dot(evecs, c), np.exp(np.dot(D, T)))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">y has a shape of (2, 50) so we have to transpose it</span>
plt.plot(t, y.T)
plt.xlabel(<span style="color: #008000;">'t'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
plt.legend([<span style="color: #008000;">'$y_1$'</span>, <span style="color: #008000;">'$y_2$'</span>])
plt.savefig(<span style="color: #008000;">'images/ode-la.png'</span>)
</pre>
</div>


<div id="org0bc46e7" class="figure">
<p><img src="pycse-chapters/images/ode-la.png" alt="ode-la.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org63be892" class="outline-3">
<h3 id="org63be892"><span class="section-number-3">10.2.</span> Delay Differential Equations</h3>
<div class="outline-text-3" id="text-10-2">
<p>
In Matlab you can solve Delay Differential equations (DDE) (<a href="http://matlab.cheme.cmu.edu/2011/09/28/delay-differential-equations/">Matlab post</a>). I do not know of a solver in scipy at this time that can do this.
</p>
</div>
</div>
<div id="outline-container-org776e843" class="outline-3">
<h3 id="org776e843"><span class="section-number-3">10.3.</span> Differential algebraic systems of equations</h3>
<div class="outline-text-3" id="text-10-3">
<p>
There is not a builtin solver for DAE systems in scipy. It looks like <a href="http://pysundials.sourceforge.net/">pysundials</a> may do it, but it must be compiled and installed.
</p>
</div>
</div>

<div id="outline-container-org2d00a5c" class="outline-3">
<h3 id="org2d00a5c"><span class="section-number-3">10.4.</span> Boundary value equations</h3>
<div class="outline-text-3" id="text-10-4">
<p>
I am unaware of dedicated BVP solvers in scipy. In the following examples we implement some approaches to solving certain types of linear BVPs.
</p>
</div>

<div id="outline-container-org86255e1" class="outline-4">
<h4 id="org86255e1"><span class="section-number-4">10.4.1.</span> Plane Poiseuille flow - BVP solve by shooting method</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/08/plane-poiseuille-flow-bvp-solve-by-shooting-method/">Matlab post</a>
</p>

<p>
One approach to solving BVPs is to use the shooting method. The reason we cannot use an initial value solver for a BVP is that there is not enough information at the initial value to start. In the shooting method, we take the function value at the initial point, and guess what the function derivatives are so that we can do an integration. If our guess was good, then the solution will go through the known second boundary point. If not, we guess again, until we get the answer we need. In this example we repeat the pressure driven flow example, but illustrate the shooting method.
</p>

<p>
In the pressure driven flow of a fluid with viscosity \(\mu\) between two stationary plates separated by distance \(d\) and driven by a pressure drop \(\Delta P/\Delta x\), the governing equations on the velocity \(u\) of the fluid are (assuming flow in the x-direction with the velocity varying only in the y-direction):
</p>

<p>
\[\frac{\Delta P}{\Delta x} = \mu \frac{d^2u}{dy^2}\]
</p>

<p>
with boundary conditions \(u(y=0) = 0\) and \(u(y=d) = 0\), i.e. the no-slip condition at the edges of the plate.
</p>

<p>
we convert this second order BVP to a system of ODEs by letting \(u_1 = u\), \(u_2 = u_1'\) and then \(u_2' = u_1''\). This leads to:
</p>

<p>
\(\frac{d u_1}{dy} = u_2\)
</p>

<p>
\(\frac{d u_2}{dy} = \frac{1}{\mu}\frac{\Delta P}{\Delta x}\)
</p>

<p>
with boundary conditions \(u_1(y=0) = 0\) and \(u_1(y=d) = 0\).
</p>

<p>
for this problem we let the plate separation be d=0.1, the viscosity \(\mu = 1\), and \(\frac{\Delta P}{\Delta x} = -100\).
</p>
</div>

<div id="outline-container-org18ae349" class="outline-5">
<h5 id="org18ae349"><span class="section-number-5">10.4.1.1.</span> First guess</h5>
<div class="outline-text-5" id="text-10-4-1-1">
<p>
We need u_1(0) and u_2(0), but we only have u_1(0). We need to guess a value for u_2(0) and see if the solution goes through the u_2(d)=0 boundary value.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">d</span> = 0.1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plate thickness</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefun</span>(U, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">u1</span>, <span style="color: #BA36A5;">u2</span> = U
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">mu</span> = 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Pdrop</span> = -100
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du1dy</span> = u2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du2dy</span> = 1.0 / mu * Pdrop
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [du1dy, du2dy]

<span style="color: #BA36A5;">u1_0</span> = 0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">known</span>
<span style="color: #BA36A5;">u2_0</span> = 1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">guessed</span>

<span style="color: #BA36A5;">dspan</span> = np.linspace(0, d)

<span style="color: #BA36A5;">U</span> = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0])
plt.plot([d],[0], <span style="color: #008000;">'ro'</span>)
plt.xlabel(<span style="color: #008000;">'d'</span>)
plt.ylabel(<span style="color: #008000;">'$u_1$'</span>)
plt.savefig(<span style="color: #008000;">'images/bvp-shooting-1.png'</span>)
</pre>
</div>


<div id="org59097bd" class="figure">
<p><img src="pycse-chapters/images/bvp-shooting-1.png" alt="bvp-shooting-1.png" />
</p>
</div>

<p>
Here we have undershot the boundary condition. Let us try a larger guess.
</p>
</div>
</div>

<div id="outline-container-org945f6ce" class="outline-5">
<h5 id="org945f6ce"><span class="section-number-5">10.4.1.2.</span> Second guess</h5>
<div class="outline-text-5" id="text-10-4-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">d</span> = 0.1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plate thickness</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefun</span>(U, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">u1</span>, <span style="color: #BA36A5;">u2</span> = U
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">mu</span> = 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Pdrop</span> = -100
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du1dy</span> = u2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du2dy</span> = 1.0 / mu * Pdrop
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [du1dy, du2dy]

<span style="color: #BA36A5;">u1_0</span> = 0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">known</span>
<span style="color: #BA36A5;">u2_0</span> = 10 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">guessed</span>

<span style="color: #BA36A5;">dspan</span> = np.linspace(0, d)

<span style="color: #BA36A5;">U</span> = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0])
plt.plot([d],[0], <span style="color: #008000;">'ro'</span>)
plt.xlabel(<span style="color: #008000;">'d'</span>)
plt.ylabel(<span style="color: #008000;">'$u_1$'</span>)
plt.savefig(<span style="color: #008000;">'images/bvp-shooting-2.png'</span>)
</pre>
</div>


<div id="orge48e943" class="figure">
<p><img src="pycse-chapters/images/bvp-shooting-2.png" alt="bvp-shooting-2.png" />
</p>
</div>

<p>
Now we have clearly overshot. Let us now make a function that will iterate for us to find the right value.
</p>
</div>
</div>

<div id="outline-container-org8084ffa" class="outline-5">
<h5 id="org8084ffa"><span class="section-number-5">10.4.1.3.</span> Let fsolve do the work</h5>
<div class="outline-text-5" id="text-10-4-1-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">d</span> = 0.1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plate thickness</span>
<span style="color: #BA36A5;">Pdrop</span> = -100
<span style="color: #BA36A5;">mu</span> = 1

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefun</span>(U, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">u1</span>, <span style="color: #BA36A5;">u2</span> = U
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du1dy</span> = u2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du2dy</span> = 1.0 / mu * Pdrop
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [du1dy, du2dy]

<span style="color: #BA36A5;">u1_0</span> = 0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">known</span>
<span style="color: #BA36A5;">dspan</span> = np.linspace(0, d)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(u2_0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dspan</span> = np.linspace(0, d)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">U</span> = odeint(odefun, [u1_0, u2_0], dspan)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">u1</span> = U[:,0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> u1[-1]

<span style="color: #BA36A5;">u2_0</span>, = fsolve(objective, 1.0)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now solve with optimal u2_0</span>
<span style="color: #BA36A5;">U</span> = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0], label=<span style="color: #008000;">'Numerical solution'</span>)
plt.plot([d],[0], <span style="color: #008000;">'ro'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plot an analytical solution</span>
u = -(Pdrop) * d**2 / 2 / mu * (dspan / d - (dspan / d)**2)
plt.plot(dspan, u, <span style="color: #008000;">'r--'</span>, label=<span style="color: #008000;">'Analytical solution'</span>)


plt.xlabel(<span style="color: #008000;">'d'</span>)
plt.ylabel(<span style="color: #008000;">'$u_1$'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/bvp-shooting-3.png'</span>)
</pre>
</div>


<div id="orga5a531c" class="figure">
<p><img src="pycse-chapters/images/bvp-shooting-3.png" alt="bvp-shooting-3.png" />
</p>
</div>

<p>
You can see the agreement is excellent!
</p>

<p>
This also seems like a useful bit of code to not have to reinvent regularly, so it has been added to pycse as BVP_sh. Here is an example usage.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> BVP_sh
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">d</span> = 0.1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plate thickness</span>
<span style="color: #BA36A5;">Pdrop</span> = -100
<span style="color: #BA36A5;">mu</span> = 1

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefun</span>(U, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">u1</span>, <span style="color: #BA36A5;">u2</span> = U
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du1dy</span> = u2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">du2dy</span> = 1.0 / mu * Pdrop
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [du1dy, du2dy]

<span style="color: #BA36A5;">x1</span> = 0.0; <span style="color: #BA36A5;">alpha</span> = 0.0
<span style="color: #BA36A5;">x2</span> = 0.1; <span style="color: #BA36A5;">beta</span> = 0.0
<span style="color: #BA36A5;">init</span> = 2.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial guess of slope at x=0</span>

<span style="color: #BA36A5;">X</span>,<span style="color: #BA36A5;">Y</span> = BVP_sh(odefun, x1, x2, alpha, beta, init)
plt.plot(X, Y[:,0])
plt.ylim([0, 0.14])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plot an analytical solution</span>
<span style="color: #BA36A5;">u</span> = -(Pdrop) * d**2 / 2 / mu * (X / d - (X / d)**2)
plt.plot(X, u, <span style="color: #008000;">'r--'</span>, label=<span style="color: #008000;">'Analytical solution'</span>)
plt.savefig(<span style="color: #008000;">'images/bvp-shooting-4.png'</span>)
</pre>
</div>


<div id="orgb170cce" class="figure">
<p><img src="pycse-chapters/images/bvp-shooting-4.png" alt="bvp-shooting-4.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2a2d6ac" class="outline-4">
<h4 id="org2a2d6ac"><span class="section-number-4">10.4.2.</span> Plane poiseuelle flow solved by finite difference</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/30/plane-poiseuelle-flow-solved-by-finite-difference/">Matlab post</a>
</p>

<p>
Adapted from <a href="http://www.physics.arizona.edu/~restrepo/475B/Notes/sourcehtml/node24.html">http://www.physics.arizona.edu/~restrepo/475B/Notes/sourcehtml/node24.html</a>
</p>

<p>
We want to solve a linear boundary value problem of the form: y'' = p(x)y' + q(x)y + r(x) with boundary conditions y(x1) = alpha and y(x2) = beta.
</p>

<p>
For this example, we solve the plane poiseuille flow problem using a finite difference approach. An advantage of the approach we use here is we do not have to rewrite the second order ODE as a set of coupled first order ODEs, nor do we have to provide guesses for the solution. We do, however, have to discretize the derivatives and formulate a linear algebra problem.
</p>

<p>
we want to solve u'' = 1/mu*DPDX with u(0)=0 and u(0.1)=0. for this problem we let the plate separation be d=0.1, the viscosity \(\mu = 1\), and \(\frac{\Delta P}{\Delta x} = -100\).
</p>

<p>
The idea behind the finite difference method is to approximate the derivatives by finite differences on a grid. See here for details. By discretizing the ODE, we arrive at a set of linear algebra equations of the form \(A y = b\), where \(A\) and \(b\) are defined as follows.
</p>

<p>
\[A = \left [ \begin{array}{ccccc} %
 2 + h^2 q_1         & -1 + \frac{h}{2} p_1 & 0                    & 0 & 0 \\
-1 - \frac{h}{2} p_2 & 2 + h^2 q_2          & -1 + \frac{h}{2} p_2 & 0 & 0 \\
0                    & \ddots               & \ddots               & \ddots & 0 \\
0                    & 0                    & -1 - \frac{h}{2} p_{N-1} & 2 + h^2 q_{N-1} & -1 + \frac{h}{2} p_{N-1} \\
0                    & 0                    & 0  & -1 - \frac{h}{2} p_N & 2 + h^2 q_N \end{array} \right ] \]
</p>

<p>
\[ y = \left [ \begin{array}{c} y_i \\ \vdots \\ y_N \end{array} \right ] \]
</p>

<p>
\[ b = \left [ \begin{array}{c} -h^2 r_1 + ( 1 + \frac{h}{2} p_1) \alpha \\
-h^2 r_2 \\
\vdots \\
-h^2 r_{N-1} \\
-h^2 r_N + (1 - \frac{h}{2} p_N) \beta \end{array} \right] \]
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we use the notation for y'' = p(x)y' + q(x)y + r(x)</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">p</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0

<span style="color: #0000FF;">def</span> <span style="color: #006699;">q</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0

<span style="color: #0000FF;">def</span> <span style="color: #006699;">r</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -100

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we use the notation y(x1) = alpha and y(x2) = beta</span>

<span style="color: #BA36A5;">x1</span> = 0; <span style="color: #BA36A5;">alpha</span> = 0.0
<span style="color: #BA36A5;">x2</span> = 0.1; <span style="color: #BA36A5;">beta</span> = 0.0

<span style="color: #BA36A5;">npoints</span> = 100

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">compute interval width</span>
<span style="color: #BA36A5;">h</span> = (x2-x1)/npoints;

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">preallocate and shape the b vector and A-matrix</span>
<span style="color: #BA36A5;">b</span> = np.zeros((npoints - 1, 1));
<span style="color: #BA36A5;">A</span> = np.zeros((npoints - 1, npoints - 1));
<span style="color: #BA36A5;">X</span> = np.zeros((npoints - 1, 1));

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">now we populate the A-matrix and b vector elements</span>
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(npoints - 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">X</span>[i,0] = x1 + (i + 1) * h

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">get the value of the BVP Odes at this x</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">pi</span> = p(X[i])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">qi</span> = q(X[i])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ri</span> = r(X[i])

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> i == 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">first boundary condition</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   b[<span style="color: #BA36A5;">i</span>] = -h**2 * ri + (1 + h / 2 * pi)*alpha;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> i == npoints - 1:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">second boundary condition</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   b[<span style="color: #BA36A5;">i</span>] = -h**2 * ri + (1 - h / 2 * pi)*beta;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   b[<span style="color: #BA36A5;">i</span>] = -h**2 * ri <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">intermediate points</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(npoints - 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> j == i: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the diagonal</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   A[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = 2 + h**2 * qi
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> j == i - 1: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">left of the diagonal</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   A[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = -1 - h / 2 * pi
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> j == i + 1: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">right of the diagonal</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   A[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = -1 + h / 2 * pi
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   A[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = 0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">off the tri-diagonal</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">solve the equations A*y = b for Y</span>
Y = np.linalg.solve(A,b)

x = np.hstack([x1, X[:,0], x2])
y = np.hstack([alpha, Y[:,0], beta])

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.plot(x, y)

mu = 1
d = 0.1
x = np.linspace(0,0.1);
Pdrop = -100 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is DeltaP/Deltax</span>
u = -(Pdrop) * d**2 / 2.0 / mu * (x / d - (x / d)**2)
plt.plot(x,u,<span style="color: #008000;">'r--'</span>)

plt.xlabel(<span style="color: #008000;">'distance between plates'</span>)
plt.ylabel(<span style="color: #008000;">'fluid velocity'</span>)
plt.legend((<span style="color: #008000;">'finite difference'</span>, <span style="color: #008000;">'analytical soln'</span>))
plt.savefig(<span style="color: #008000;">'images/pp-bvp-fd.png'</span>)
</pre>
</div>


<div id="org282ae58" class="figure">
<p><img src="pycse-chapters/images/pp-bvp-fd.png" alt="pp-bvp-fd.png" />
</p>
</div>

<p>
You can see excellent agreement here between the numerical and analytical solution.
</p>
</div>
</div>

<div id="outline-container-orgf20b895" class="outline-4">
<h4 id="orgf20b895"><span class="section-number-4">10.4.3.</span> Boundary value problem in heat conduction</h4>
<div class="outline-text-4" id="text-10-4-3">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/11/boundary-value-problem-in-heat-conduction/">Matlab post</a>
</p>

<p>
For steady state heat conduction the temperature distribution in one-dimension is governed by the Laplace equation:
</p>

<p>
\[ \nabla^2 T = 0\]
</p>

<p>
with boundary conditions that at \(T(x=a) = T_A\) and \(T(x=L) = T_B\).
</p>

<p>
The analytical solution is not difficult here: \(T = T_A-\frac{T_A-T_B}{L}x\), but we will solve this by finite differences.
</p>

<p>
For this problem, lets consider a slab that is defined by x=0 to x=L, with \(T(x=0) = 100\), and \(T(x=L) = 200\). We want to find the function T(x) inside the slab.
</p>

<p>
We approximate the second derivative by finite differences as
</p>

<p>
\( f''(x) \approx \frac{f(x-h) - 2 f(x) + f(x+h)}{h^2} \)
</p>

<p>
Since the second derivative in this case is equal to zero, we have at each discretized node \(0 = T_{i-1} - 2 T_i + T_{i+1}\). We know the values of \(T_{x=0} = \alpha\) and \(T_{x=L} = \beta\).
</p>

<p>
\[A = \left [ \begin{array}{ccccc} %
 -2         & 1 & 0                    & 0 & 0 \\
1           & -2& 1 & 0 & 0 \\
0                    & \ddots               & \ddots               & \ddots & 0 \\
0                    & 0                    & 1 & -2 & 1 \\
0                    & 0                    & 0  & 1  & -2  \end{array} \right ] \]
</p>

<p>
\[ x = \left [ \begin{array}{c} T_1 \\ \vdots \\ T_N \end{array} \right ] \]
</p>

<p>
\[ b = \left [ \begin{array}{c} -T(x=0) \\
0 \\
\vdots \\
0 \\
-T(x=L) \end{array} \right] \]
</p>

<p>
These are linear equations in the unknowns \(x\) that we can easily solve. Here, we evaluate the solution.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we use the notation T(x1) = alpha and T(x2) = beta</span>
<span style="color: #BA36A5;">x1</span> = 0; <span style="color: #BA36A5;">alpha</span> = 100
<span style="color: #BA36A5;">x2</span> = 5; <span style="color: #BA36A5;">beta</span> = 200

<span style="color: #BA36A5;">npoints</span> = 100

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">preallocate and shape the b vector and A-matrix</span>
<span style="color: #BA36A5;">b</span> = np.zeros((npoints, 1));
<span style="color: #BA36A5;">b</span>[0] = -alpha
<span style="color: #BA36A5;">b</span>[-1] = -beta

<span style="color: #BA36A5;">A</span> = np.zeros((npoints, npoints));

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">now we populate the A-matrix and b vector elements</span>
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(npoints ):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(npoints):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> j == i: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the diagonal</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   A[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = -2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> j == i - 1: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">left of the diagonal</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   A[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> j == i + 1: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">right of the diagonal</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   A[<span style="color: #BA36A5;">i</span>,<span style="color: #BA36A5;">j</span>] = 1

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">solve the equations A*y = b for Y</span>
Y = np.linalg.solve(A,b)

x = np.linspace(x1, x2, npoints + 2)
y = np.hstack([alpha, Y[:,0], beta])

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.plot(x, y)

plt.plot(x, alpha + (beta - alpha)/(x2 - x1) * x, <span style="color: #008000;">'r--'</span>)

plt.xlabel(<span style="color: #008000;">'X'</span>)
plt.ylabel(<span style="color: #008000;">'T(X)'</span>)
plt.legend((<span style="color: #008000;">'finite difference'</span>, <span style="color: #008000;">'analytical soln'</span>), loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/bvp-heat-conduction-1d.png'</span>)
</pre>
</div>


<div id="org83dd80c" class="figure">
<p><img src="pycse-chapters/images/bvp-heat-conduction-1d.png" alt="bvp-heat-conduction-1d.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org7627c5d" class="outline-4">
<h4 id="org7627c5d"><span class="section-number-4">10.4.4.</span> BVP in pycse</h4>
<div class="outline-text-4" id="text-10-4-4">
<p>
I thought it was worthwhile coding a BVP solver into pycse. This function (bvp_L0) solves \(y''(x) + p(x) y'(x) + q(x) y(x) = r(x)\) with constant value boundary conditions \(y(x_0) = \alpha\) and \(y(x_L) = \beta\).
</p>

<p>
Fluids example for Plane poiseuelle flow (\(y''(x) = constant\), \(y(0) = 0\) and \(y(L) = 0\):
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> bvp_L0

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we use the notation for y'' = p(x)y' + q(x)y + r(x)</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">p</span>(x): <span style="color: #0000FF;">return</span> 0
<span style="color: #0000FF;">def</span> <span style="color: #006699;">q</span>(x): <span style="color: #0000FF;">return</span> 0
<span style="color: #0000FF;">def</span> <span style="color: #006699;">r</span>(x): <span style="color: #0000FF;">return</span> -100

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we use the notation y(x1) = alpha and y(x2) = beta</span>

<span style="color: #BA36A5;">x1</span> = 0; <span style="color: #BA36A5;">alpha</span> = 0.0
<span style="color: #BA36A5;">x2</span> = 0.1; <span style="color: #BA36A5;">beta</span> = 0.0

<span style="color: #BA36A5;">npoints</span> = 100

<span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = bvp_L0(p, q, r, x1, x2, alpha, beta, npoints=100)
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">len</span>(x))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(x, y)
plt.savefig(<span style="color: #008000;">'images/bvp-pycse.png'</span>)
</pre>
</div>


<div id="orgfb13528" class="figure">
<p><img src="pycse-chapters/images/bvp-pycse.png" alt="bvp-pycse.png" />
</p>
</div>

<p>
Heat transfer example \(y''(x) = 0\), \(y(0) = 100\) and \(y(L) = 200\).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> bvp_L0

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we use the notation for y'' = p(x)y' + q(x)y + r(x)</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">p</span>(x): <span style="color: #0000FF;">return</span> 0
<span style="color: #0000FF;">def</span> <span style="color: #006699;">q</span>(x): <span style="color: #0000FF;">return</span> 0
<span style="color: #0000FF;">def</span> <span style="color: #006699;">r</span>(x): <span style="color: #0000FF;">return</span> 0

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">we use the notation y(x1) = alpha and y(x2) = beta</span>

<span style="color: #BA36A5;">x1</span> = 0; <span style="color: #BA36A5;">alpha</span> = 100
<span style="color: #BA36A5;">x2</span> = 1; <span style="color: #BA36A5;">beta</span> = 200

<span style="color: #BA36A5;">npoints</span> = 100

<span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = bvp_L0(p, q, r, x1, x2, alpha, beta, npoints=100)
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">len</span>(x))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(x, y)
plt.xlabel(<span style="color: #008000;">'X'</span>)
plt.ylabel(<span style="color: #008000;">'T'</span>)
plt.savefig(<span style="color: #008000;">'images/ht-example.png'</span>)
</pre>
</div>


<div id="orgffd2d82" class="figure">
<p><img src="pycse-chapters/images/ht-example.png" alt="ht-example.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org631d211" class="outline-4">
<h4 id="org631d211"><span class="section-number-4">10.4.5.</span> A nonlinear BVP</h4>
<div class="outline-text-4" id="text-10-4-5">
<p>
<a href="PDE!nonlinear">PDE!nonlinear</a>
Adapted from Example 8.7 in <span class="underline">Numerical Methods in Engineering with Python</span> by Jaan Kiusalaas.
</p>

<p>
We want to solve \(y''(x) = -3 y(x) y'(x)\) with $y(0) = 0 and \(y(2) = 1\) using a finite difference method. We discretize the region and approximate the derivatives as:
</p>

<p>
\(y''(x) \approx \frac{y_{i-1} - 2 y_i + y_{i+1}}{h^2} \)
</p>

<p>
\(y'(x) \approx \frac{y_{i+1} - y_{i-1}}{2 h} \)
</p>

<p>
We define a function \(y''(x) = F(x, y, y')\). At each node in our discretized region, we will have an equation that looks like \(y''(x) - F(x, y, y') = 0\), which will be nonlinear in the unknown solution \(y\). The set of equations to solve is:
</p>

\begin{eqnarray}
y_0 - \alpha &=& 0 \\
\frac{y_{i-1} - 2 y_i + y_{i+1}}{h^2} + (3 y_i) (\frac{y_{i+1} - y_{i-1}}{2 h}) &=& 0 \\
y_L - \beta &=&0
\end{eqnarray}

<p>
Since we use a nonlinear solver, we will have to provide an initial guess to the solution. We will in this case assume a line. In other cases, a bad initial guess may lead to no solution.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x1</span> = 0.0
<span style="color: #BA36A5;">x2</span> = 2.0

<span style="color: #BA36A5;">alpha</span> = 0.0
<span style="color: #BA36A5;">beta</span> = 1.0

<span style="color: #BA36A5;">N</span> = 11
<span style="color: #BA36A5;">X</span> = np.linspace(x1, x2, N)
<span style="color: #BA36A5;">h</span> = (x2 - x1) / (N - 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Ypp</span>(x, y, yprime):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''define y'' = 3*y*y' '''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -3.0 * y * yprime

<span style="color: #0000FF;">def</span> <span style="color: #006699;">residuals</span>(y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''When we have the right values of y, this function will be zero.'''</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">res</span> = np.zeros(y.shape)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">res</span>[0] = y[0] - alpha

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, N - 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span> = X[i]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">YPP</span> = (y[i - 1] - 2 * y[i] + y[i + 1]) / h**2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">YP</span> = (y[i + 1] - y[i - 1]) / (2 * h)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">res</span>[<span style="color: #BA36A5;">i</span>] = YPP - Ypp(x, y[i], YP)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">res</span>[-1] = y[-1] - beta
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> res

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we need an initial guess</span>
<span style="color: #BA36A5;">init</span> = alpha + (beta - alpha) / (x2 - x1) * X

<span style="color: #BA36A5;">Y</span> = fsolve(residuals, init)

plt.plot(X, Y)
plt.savefig(<span style="color: #008000;">'images/bvp-nonlinear-1.png'</span>)
</pre>
</div>


<div id="org5baeaf7" class="figure">
<p><img src="pycse-chapters/images/bvp-nonlinear-1.png" alt="bvp-nonlinear-1.png" />
</p>
</div>

<p>
That code looks useful, so I put it in the pycse module in the function BVP_nl. Here is an example usage. We have to create two functions, one for the differential equation, and one for the initial guess.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span>  BVP_nl
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x1</span> = 0.0
<span style="color: #BA36A5;">x2</span> = 2.0

<span style="color: #BA36A5;">alpha</span> = 0.0
<span style="color: #BA36A5;">beta</span> = 1.0

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Ypp</span>(x, y, yprime):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''define y'' = 3*y*y' '''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -3.0 * y * yprime

<span style="color: #0000FF;">def</span> <span style="color: #006699;">BC</span>(X, Y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [alpha - Y[0], beta - Y[-1]]

<span style="color: #BA36A5;">X</span> = np.linspace(x1, x2)
<span style="color: #BA36A5;">init</span> = alpha + (beta - alpha) / (x2 - x1) * X

<span style="color: #BA36A5;">y</span> = BVP_nl(Ypp, X, BC, init)

plt.plot(X, y)
plt.savefig(<span style="color: #008000;">'images/bvp-nonlinear-2.png'</span>)
</pre>
</div>


<div id="org9c7cd34" class="figure">
<p><img src="pycse-chapters/images/bvp-nonlinear-2.png" alt="bvp-nonlinear-2.png" />
</p>
</div>

<p>
The results are the same.
</p>
</div>
</div>

<div id="outline-container-orgdfd84fa" class="outline-4">
<h4 id="orgdfd84fa"><span class="section-number-4">10.4.6.</span> Another look at nonlinear BVPs</h4>
<div class="outline-text-4" id="text-10-4-6">
<p>
Adapted from <a href="http://www.mathworks.com/help/matlab/ref/bvp4c.html">http://www.mathworks.com/help/matlab/ref/bvp4c.html</a>
<a href="BVP">BVP</a>
</p>

<p>
Boundary value problems may have more than one solution. Let us consider the BVP:
</p>

\begin{eqnarray}
y'' + |y| &=& 0 \\
y(0) &=& 0 \\
y(4) &=& -2
\end{eqnarray}

<p>
We will see this equation has two answers, depending on your initial guess. We convert this to the following set of coupled equations:
</p>

\begin{eqnarray}
y_1' &=& y_2 \\
y_2' &=& -|y_1| \\
y_1(0)&=& 0\\
y_1(4) &=& -2
\end{eqnarray}

<p>
This BVP is nonlinear because of the absolute value. We will have to guess solutions to get started. We will guess two different solutions, both of which will be constant values.  We will use pycse.bvp to solve the equation.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> bvp
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefun</span>(Y, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y1</span>, <span style="color: #BA36A5;">y2</span> = Y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dy1dx</span> = y2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dy2dx</span> = -np.<span style="color: #006FE0;">abs</span>(y1)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [dy1dx, dy2dx]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">bcfun</span>(Y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y1a</span>, <span style="color: #BA36A5;">y2a</span> = Y[0][0], Y[1][0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y1b</span>, <span style="color: #BA36A5;">y2b</span> = Y[0][-1], Y[1][-1]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [y1a, -2 - y1b]

<span style="color: #BA36A5;">x</span> = np.linspace(0, 4, 100)

<span style="color: #BA36A5;">y1</span> = 1.0 * np.ones(x.shape)
<span style="color: #BA36A5;">y2</span> = 0.0 * np.ones(x.shape)

<span style="color: #BA36A5;">Yinit</span> = np.vstack([y1, y2])

<span style="color: #BA36A5;">sol</span> = bvp(odefun, bcfun, x, Yinit)

plt.plot(x, sol[0])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">another initial guess</span>
<span style="color: #BA36A5;">y1</span> = -1.0 * np.ones(x.shape)
<span style="color: #BA36A5;">y2</span> = 0.0 * np.ones(x.shape)

<span style="color: #BA36A5;">Yinit</span> = np.vstack([y1, y2])

<span style="color: #BA36A5;">sol</span> = bvp(odefun, bcfun, x, Yinit)

plt.plot(x, sol[0])
plt.legend([<span style="color: #008000;">'guess 1'</span>, <span style="color: #008000;">'guess 2'</span>])
plt.savefig(<span style="color: #008000;">'images/bvp-another-nonlin-1.png'</span>)
</pre>
</div>



<div id="org9ac72f5" class="figure">
<p><img src="pycse-chapters/images/bvp-another-nonlin-1.png" alt="bvp-another-nonlin-1.png" />
</p>
</div>

<p>
This example shows that a nonlinear BVP may have different solutions, and which one you get depends on the guess you make for the solution. This is analogous to solving nonlinear algebraic equations (which is what is done in solving this problem!).
</p>
</div>
</div>

<div id="outline-container-org369b280" class="outline-4">
<h4 id="org369b280"><span class="section-number-4">10.4.7.</span> Solving the Blasius equation</h4>
<div class="outline-text-4" id="text-10-4-7">
<p>
In fluid mechanics the Blasius equation comes up (<a href="http://en.wikipedia.org/wiki/Blasius_boundary_layer">http://en.wikipedia.org/wiki/Blasius_boundary_layer</a>) to describe the boundary layer that forms near a flat plate with fluid moving by it. The nonlinear differential equation is:
</p>

\begin{eqnarray}
f''' + \frac{1}{2} f f'' &=& 0 \\
f(0) &=& 0 \\
f'(0) &=& 0 \\
f'(\infty) &=& 1
\end{eqnarray}

<p>
This is a nonlinear, boundary value problem. The point of solving this equation is to get the value of \(f''(0)\) to evaluate the shear stress at the plate.
</p>

<p>
We have to convert this to a system of first-order differential equations. Let \(f_1 = f\), \(f_2 = f_1'\) and \(f_3 = f_2'\). This leads to:
</p>

\begin{eqnarray}
f_1' = f_2 \\
f_2' = f_3 \\
f_3' = -\frac{1}{2} f_1 f_3 \\
f_1(0) = 0 \\
f_2(0) = 0 \\
f_2(\infty) = 1
\end{eqnarray}

<p>
It is not possible to specify a boundary condition at \(\infty\) numerically, so we will have to use a large number, and verify it is "large enough". From the solution, we evaluate the derivatives at \(\eta=0\), and we have \(f''(0) = f_3(0)\).
</p>

<p>
We have to provide initial guesses for f_1, f_2 and f_3. This is the hardest part about this problem. We know that f_1 starts at zero, and is flat there (f'(0)=0), but at large eta, it has a constant slope of one. We will guess a simple line of slope = 1 for f_1. That is correct at large eta, and is zero at &eta;=0. If the slope of the function is constant at large \(\eta\), then the values of higher derivatives must tend to zero. We choose an exponential decay as a guess.
</p>

<p>
Finally, we let a solver iteratively find a solution for us, and find the answer we want. The solver is in the pycse module.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> bvp

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefun</span>(F, x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f1</span>, <span style="color: #BA36A5;">f2</span>, <span style="color: #BA36A5;">f3</span> = F.T
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.column_stack([f2,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   f3,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -0.5 * f1 * f3])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">bcfun</span>(Y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">fa</span>, <span style="color: #BA36A5;">fb</span> = Y[0, :], Y[-1, :]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [fa[0],        <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f1(0) =  0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   fa[1],        <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f2(0) = 0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   1.0 - fb[1]]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f2(inf) = 1</span>

<span style="color: #BA36A5;">eta</span> = np.linspace(0, 6, 100)
<span style="color: #BA36A5;">f1init</span> = eta
<span style="color: #BA36A5;">f2init</span> = np.exp(-eta)
<span style="color: #BA36A5;">f3init</span> = np.exp(-eta)

<span style="color: #BA36A5;">Finit</span> = np.column_stack([f1init, f2init, f3init])

<span style="color: #BA36A5;">sol</span> = bvp(odefun, bcfun, eta, Finit)
<span style="color: #BA36A5;">f1</span>, <span style="color: #BA36A5;">f2</span>, <span style="color: #BA36A5;">f3</span> = sol.T

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">"f''(0) = f_3(0) = {0}"</span>.<span style="color: #006FE0;">format</span>(f3[0]))

%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(eta, f1)
plt.xlabel(<span style="color: #008000;">'$\eta$'</span>)
plt.ylabel(<span style="color: #008000;">'$f(\eta)$'</span>)
</pre>
</div>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2017-05-17 Wed&gt; </span></span> You need pycse 1.6.4 for this example.
</p>
</div>
</div>
</div>


<div id="outline-container-org8e07a18" class="outline-3">
<h3 id="org8e07a18"><span class="section-number-3">10.5.</span> Partial differential equations</h3>
<div class="outline-text-3" id="text-10-5">
</div>
<div id="outline-container-org6572a54" class="outline-4">
<h4 id="org6572a54"><span class="section-number-4">10.5.1.</span> Modeling a transient plug flow reactor</h4>
<div class="outline-text-4" id="text-10-5-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/17/modeling-a-transient-plug-flow-reactor">Matlab post</a>
<a href="PDE!method of lines">PDE!method of lines</a>
<a href="plotting!animation">plotting!animation</a>
<a href="animation">animation</a>
</p>

<p>
The PDE that describes the transient behavior of a plug flow reactor with constant volumetric flow rate is:
</p>

<p>
\( \frac{\partial C_A}{\partial dt} = -\nu_0 \frac{\partial C_A}{\partial dV} + r_A \).
</p>

<p>
To solve this numerically in python, we will utilize the method of lines. The idea is to discretize the reactor in volume, and approximate the spatial derivatives by finite differences. Then we will have a set of coupled ordinary differential equations that can be solved in the usual way. Let us simplify the notation with \(C = C_A\), and let \(r_A = -k C^2\). Graphically this looks like this:
</p>


<div id="org352ebb1" class="figure">
<p><img src="pycse-chapters/images/pde-method-of-lines.png" alt="pde-method-of-lines.png" />
</p>
</div>

<p>
This leads to the following set of equations:
</p>

\begin{eqnarray}
\frac{dC_0}{dt} &=& 0 \text{ (entrance concentration never changes)} \\
\frac{dC_1}{dt} &=& -\nu_0 \frac{C_1 - C_0}{V_1 - V_0} - k C_1^2 \\
\frac{dC_2}{dt} &=& -\nu_0 \frac{C_2 - C_1}{V_2 - V_1} - k C_2^2 \\
\vdots \\
\frac{dC_4}{dt} &=& -\nu_0 \frac{C_4 - C_3}{V_4 - V_3} - k C_4^2
\end{eqnarray}

<p>
Last, we need initial conditions for all the nodes in the discretization. Let us assume the reactor was full of empty solvent, so that \(C_i = 0\) at \(t=0\). In the next block of code, we get the transient solutions, and the steady state solution.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #BA36A5;">Ca0</span> = 2     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Entering concentration</span>
<span style="color: #BA36A5;">vo</span> = 2      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">volumetric flow rate</span>
<span style="color: #BA36A5;">volume</span> = 20 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">total volume of reactor, spacetime = 10</span>
<span style="color: #BA36A5;">k</span> = 1       <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reaction rate constant</span>

<span style="color: #BA36A5;">N</span> = 100     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of points to discretize the reactor volume on</span>

<span style="color: #BA36A5;">init</span> = np.zeros(N)    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Concentration in reactor at t = 0</span>
<span style="color: #BA36A5;">init</span>[0] = Ca0         <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">concentration at entrance</span>

<span style="color: #BA36A5;">V</span> = np.linspace(0, volume, N) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">discretized volume elements</span>
<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 25)    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">time span to integrate over</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">method_of_lines</span>(C, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'coupled ODES at each node point'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">D</span> = -vo * np.diff(C) / np.diff(V) - k * C[1:]**2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.concatenate([[0], <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">C0 is constant at entrance</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   D])

<span style="color: #BA36A5;">sol</span> = odeint(method_of_lines, init, tspan)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">steady state solution</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">pfr</span>(C, V):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1.0 / vo * (-k * C**2)

<span style="color: #BA36A5;">ssol</span> = odeint(pfr, Ca0, V)
</pre>
</div>

<p>
The transient solution contains the time dependent behavior of each node in the discretized reactor. Each row contains the concentration as a function of volume at a specific time point. For example, we can plot the concentration of A at the exit vs. time (that is, the last entry of each row) as:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(tspan, sol[:, -1])
plt.xlabel(<span style="color: #008000;">'time'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$ at exit'</span>)
plt.savefig(<span style="color: #008000;">'images/transient-pfr-1.png'</span>)
</pre>
</div>



<div id="orgf5412e5" class="figure">
<p><img src="pycse-chapters/images/transient-pfr-1.png" alt="transient-pfr-1.png" />
</p>
</div>

<p>
After approximately one space time, the steady state solution is reached at the exit. For completeness, we also examine the steady state solution.
</p>
<div class="org-src-container">
<pre class="src src-python">plt.figure()
plt.plot(V, ssol, label=<span style="color: #008000;">'Steady state'</span>)
plt.plot(V, sol[-1], label=<span style="color: #008000;">'t = {}'</span>.<span style="color: #006FE0;">format</span>(tspan[-1]))
plt.xlabel(<span style="color: #008000;">'Volume'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/transient-pfr-2.png'</span>)
</pre>
</div>


<div id="orge846238" class="figure">
<p><img src="pycse-chapters/images/transient-pfr-2.png" alt="transient-pfr-2.png" />
</p>
</div>

<p>
There is some minor disagreement between the final transient solution and the steady state solution. That is due to the approximation in discretizing the reactor volume. In this example we used 100 nodes. You get better agreement with a larger number of nodes, say 200 or more. Of course, it takes slightly longer to compute then, since the number of coupled odes is equal to the number of nodes.
</p>

<p>
We can also create an animated gif to show how the concentration of A throughout the reactor varies with time. Note, I had to install ffmpeg (<a href="http://ffmpeg.org/">http://ffmpeg.org/</a>) to save the animation.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> matplotlib <span style="color: #0000FF;">import</span> animation

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">make empty figure</span>
<span style="color: #BA36A5;">fig</span> = plt.figure()
<span style="color: #BA36A5;">ax</span> = plt.axes(xlim=(0, 20), ylim=(0, 2))
<span style="color: #BA36A5;">line</span>, = ax.plot(V, init, lw=2)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">animate</span>(i):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   line.set_xdata(V)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   line.set_ydata(sol[i])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.set_title(<span style="color: #008000;">'t = {0}'</span>.<span style="color: #006FE0;">format</span>(tspan[i]))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> line,


anim = animation.FuncAnimation(fig, animate, frames=50,  blit=<span style="color: #D0372D;">True</span>)

anim.save(<span style="color: #008000;">'images/transient_pfr.mp4'</span>, fps=10)
</pre>
</div>

<p>
<a href="http://kitchingroup.cheme.cmu.edu/media/transient_pfr.mp4">http://kitchingroup.cheme.cmu.edu/media/transient_pfr.mp4</a>
</p>

<p>
You can see from the animation that after about 10 time units, the solution is not changing further, suggesting steady state has been reached.
</p>
</div>
</div>

<div id="outline-container-org0ac5fb2" class="outline-4">
<h4 id="org0ac5fb2"><span class="section-number-4">10.5.2.</span> Transient heat conduction - partial differential equations</h4>
<div class="outline-text-4" id="text-10-5-2">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/21/transient-heat-conduction-partial-differential-equations/">Matlab post</a>
adapated from <a href="http://msemac.redwoods.edu/~darnold/math55/DEproj/sp02/AbeRichards/slideshowdefinal.pdf">http://msemac.redwoods.edu/~darnold/math55/DEproj/sp02/AbeRichards/slideshowdefinal.pdf</a>
<a href="PDE!method of lines">PDE!method of lines</a>
</p>

<p>
We solved a steady state BVP modeling heat conduction. Today we examine the transient behavior of a rod at constant T put between two heat reservoirs at different temperatures, again T1 = 100, and T2 = 200. The rod will start at 150. Over time, we should expect a solution that approaches the steady state solution: a linear temperature profile from one side of the rod to the other.
</p>

<p>
\(\frac{\partial u}{\partial t} = k \frac{\partial^2 u}{\partial x^2}\)
</p>

<p>
at \(t=0\), in this example we have \(u_0(x) = 150\) as an initial condition. with boundary conditions \(u(0,t)=100\) and \(u(L,t)=200\).
</p>

<p>
In Matlab there is the pdepe command. There is not yet a PDE solver in scipy. Instead, we will utilze the method of lines to solve this problem. We discretize the rod into segments, and approximate the second derivative in the spatial dimension as \(\frac{\partial^2 u}{\partial x^2} = (u(x + h) - 2 u(x) + u(x-h))/ h^2\) at each node. This leads to a set of coupled ordinary differential equations that is easy to solve.
</p>

<p>
Let us say the rod has a length of 1, \(k=0.02\), and solve for the time-dependent temperature profiles.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">N</span> = 100  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of points to discretize</span>
<span style="color: #BA36A5;">L</span> = 1.0
<span style="color: #BA36A5;">X</span> = np.linspace(0, L, N) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">position along the rod</span>
<span style="color: #BA36A5;">h</span> = L / (N - 1)

<span style="color: #BA36A5;">k</span> = 0.02

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefunc</span>(u, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dudt</span> = np.zeros(X.shape)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dudt</span>[0] = 0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">constant at boundary condition</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dudt</span>[-1] = 0

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now for the internal nodes</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, N-1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dudt</span>[<span style="color: #BA36A5;">i</span>] = k * (u[i + 1] - 2*u[i] + u[i - 1]) / h**2

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> dudt

<span style="color: #BA36A5;">init</span> = 150.0 * np.ones(X.shape) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial temperature</span>
<span style="color: #BA36A5;">init</span>[0] = 100.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">one boundary condition</span>
<span style="color: #BA36A5;">init</span>[-1] = 200.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the other boundary condition</span>

<span style="color: #BA36A5;">tspan</span> = np.linspace(0.0, 5.0, 100)
<span style="color: #BA36A5;">sol</span> = odeint(odefunc, init, tspan)


<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(0, <span style="color: #006FE0;">len</span>(tspan), 5):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(X, sol[i], label=<span style="color: #008000;">'t={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(tspan[i]))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">put legend outside the figure</span>
plt.legend(loc=<span style="color: #008000;">'center left'</span>, bbox_to_anchor=(1, 0.5))
plt.xlabel(<span style="color: #008000;">'X position'</span>)
plt.ylabel(<span style="color: #008000;">'Temperature'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">adjust figure edges so the legend is in the figure</span>
plt.subplots_adjust(top=0.89, right=0.77)
plt.savefig(<span style="color: #008000;">'images/pde-transient-heat-1.png'</span>)


<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Make a 3d figure</span>
<span style="color: #0000FF;">from</span> mpl_toolkits.mplot3d <span style="color: #0000FF;">import</span> Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection=<span style="color: #008000;">'3d'</span>)

SX, ST = np.meshgrid(X, tspan)
ax.plot_surface(SX, ST, sol, cmap=<span style="color: #008000;">'jet'</span>)
ax.set_xlabel(<span style="color: #008000;">'X'</span>)
ax.set_ylabel(<span style="color: #008000;">'time'</span>)
ax.set_zlabel(<span style="color: #008000;">'T'</span>)
ax.view_init(elev=15, azim=-124) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">adjust view so it is easy to see</span>
plt.savefig(<span style="color: #008000;">'images/pde-transient-heat-3d.png'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">animated solution. We will use imagemagick for this</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we save each frame as an image, and use the imagemagick convert command to</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">make an animated gif</span>
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(tspan)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.clf()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(X, sol[i])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.xlabel(<span style="color: #008000;">'X'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.ylabel(<span style="color: #008000;">'T(X)'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.title(<span style="color: #008000;">'t = {0}'</span>.<span style="color: #006FE0;">format</span>(tspan[i]))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.savefig(<span style="color: #008000;">'___t{0:03d}.png'</span>.<span style="color: #006FE0;">format</span>(i))

<span style="color: #0000FF;">import</span> subprocess
<span style="color: #0000FF;">print</span>(subprocess.call([<span style="color: #008000;">'convert'</span>, <span style="color: #008000;">'-quality'</span>, <span style="color: #008000;">'100'</span>, <span style="color: #008000;">'___t*.png'</span> <span style="color: #008000;">'images/transient_heat.gif'</span>]))
<span style="color: #0000FF;">print</span>(subprocess.call([<span style="color: #008000;">'rm'</span>, <span style="color: #008000;">'___t*.png'</span>]))  <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">remove temp files</span>
</pre>
</div>

<p>
This version of the graphical solution is not that easy to read, although with some study you can see the solution evolves from the initial condition which is flat, to the steady state solution which is a linear temperature ramp.
<img src="pycse-chapters/images/pde-transient-heat-1.png" alt="pde-transient-heat-1.png" />
</p>

<p>
The 3d version may be easier to interpret. The temperature profile starts out flat, and gradually changes to the linear ramp.
<img src="pycse-chapters/images/pde-transient-heat-3d.png" alt="pde-transient-heat-3d.png" />
</p>

<p>
Finally, the animated solution.
</p>


<div id="org89be245" class="figure">
<p><img src="pycse-chapters/images/transient_heat.gif" alt="transient_heat.gif" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgeb7f3db" class="outline-4">
<h4 id="orgeb7f3db"><span class="section-number-4">10.5.3.</span> Transient diffusion - partial differential equations</h4>
<div class="outline-text-4" id="text-10-5-3">
<p>
<a href="pde">pde</a>
We want to solve for the concentration profile of  component that diffuses into a 1D rod, with an impermeable barrier at the end. The PDE governing this situation is:
</p>

<p>
\(\frac{\partial C}{\partial t} = D \frac{\partial^2 C}{\partial x^2}\)
</p>

<p>
at \(t=0\), in this example we have \(C_0(x) = 0\) as an initial condition, with boundary conditions \(C(0,t)=0.1\) and \(\partial C/ \partial x(L,t)=0\).
</p>

<p>
We are going to discretize this equation in both time and space to arrive at the solution. We will let \(i\) be the index for the spatial discretization, and \(j\) be the index for the temporal discretization. The discretization looks like this.
</p>


<div id="org8d736b1" class="figure">
<p><img src="pycse-chapters/images/pde-diffusion-discretization-scheme.png" alt="pde-diffusion-discretization-scheme.png" />
</p>
</div>

<p>
Note that we cannot use the method of lines as we did before because we have the derivative-based boundary condition at one of the boundaries.
</p>

<p>
We approximate the time derivative as:
</p>

<p>
\(\frac{\partial C}{\partial t} \bigg| _{i,j} \approx \frac{C_{i,j+1} - C_{i,j}}{\Delta t} \)
</p>

<p>
\(\frac{\partial^2 C}{\partial  x^2} \bigg| _{i,j} \approx \frac{C_{i+1,j} - 2 C_{i,j} + C_{i-1,j}}{h^2} \)
</p>

<p>
We define \(\alpha = \frac{D \Delta t}{h^2}\), and from these two approximations and the PDE, we solve for the unknown solution at a later time step as:
</p>

<p>
\(C_{i, j+1} = \alpha C_{i+1,j} + (1 - 2 \alpha) C_{i,j}  + \alpha C_{i-1,j} \)
</p>

<p>
We know \(C_{i,j=0}\) from the initial conditions, so we simply need to iterate to evaluate \(C_{i,j}\), which is the solution at each time step.
</p>

<p>
See also: <a href="http://www3.nd.edu/~jjwteach/441/PdfNotes/lecture16.pdf">http://www3.nd.edu/~jjwteach/441/PdfNotes/lecture16.pdf</a>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">N</span> = 20  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">number of points to discretize</span>
<span style="color: #BA36A5;">L</span> = 1.0
<span style="color: #BA36A5;">X</span> = np.linspace(0, L, N) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">position along the rod</span>
<span style="color: #BA36A5;">h</span> = L / (N - 1)          <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">discretization spacing</span>

<span style="color: #BA36A5;">C0t</span> = 0.1  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">concentration at x = 0</span>
<span style="color: #BA36A5;">D</span> = 0.02

<span style="color: #BA36A5;">tfinal</span> = 50.0
<span style="color: #BA36A5;">Ntsteps</span> = 1000
<span style="color: #BA36A5;">dt</span> = tfinal / (Ntsteps - 1)
<span style="color: #BA36A5;">t</span> = np.linspace(0, tfinal, Ntsteps)

<span style="color: #BA36A5;">alpha</span> = D * dt / h**2
<span style="color: #0000FF;">print</span>(alpha)

<span style="color: #BA36A5;">C_xt</span> = [] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">container for all the time steps</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial condition at t = 0</span>
<span style="color: #BA36A5;">C</span> = np.zeros(X.shape)
<span style="color: #BA36A5;">C</span>[0] = C0t

<span style="color: #BA36A5;">C_xt</span> += [C]

<span style="color: #0000FF;">for</span> j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, Ntsteps):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">N</span> = np.zeros(C.shape)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">N</span>[0] =  C0t
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">N</span>[1:-1] = alpha*C[2:] + (1 - 2 * alpha) * C[1:-1] + alpha * C[0:-2]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">N</span>[-1] = N[-2]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">derivative boundary condition flux = 0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">C</span>[:] = N
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">C_xt</span> += [N]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plot selective solutions</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> j <span style="color: #0000FF;">in</span> [1,2,5,10,20,50,100,200,500]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(X, N, label=<span style="color: #008000;">'t={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(t[j]))

plt.xlabel(<span style="color: #008000;">'Position in rod'</span>)
plt.ylabel(<span style="color: #008000;">'Concentration'</span>)
plt.title(<span style="color: #008000;">'Concentration at different times'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/transient-diffusion-temporal-dependence.png'</span>)

C_xt = np.array(C_xt)
plt.figure()
plt.plot(t, C_xt[:,5], label=<span style="color: #008000;">'x={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(X[5]))
plt.plot(t, C_xt[:,10], label=<span style="color: #008000;">'x={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(X[10]))
plt.plot(t, C_xt[:,15], label=<span style="color: #008000;">'x={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(X[15]))
plt.plot(t, C_xt[:,19], label=<span style="color: #008000;">'x={0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(X[19]))
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.xlabel(<span style="color: #008000;">'Time'</span>)
plt.ylabel(<span style="color: #008000;">'Concentration'</span>)
plt.savefig(<span style="color: #008000;">'images/transient-diffusion-position-dependence.png'</span>)
</pre>
</div>


<div id="org29f559d" class="figure">
<p><img src="pycse-chapters/images/transient-diffusion-temporal-dependence.png" alt="transient-diffusion-temporal-dependence.png" />
</p>
</div>


<div id="orgaedf955" class="figure">
<p><img src="pycse-chapters/images/transient-diffusion-position-dependence.png" alt="transient-diffusion-position-dependence.png" />
</p>
</div>

<p>
The solution is somewhat sensitive to the choices of time step and spatial discretization. If you make the time step too big, the method is not stable, and large oscillations may occur.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org5205123" class="outline-2">
<h2 id="org5205123"><span class="section-number-2">11.</span> Plotting</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-orgbdf602c" class="outline-3">
<h3 id="orgbdf602c"><span class="section-number-3">11.1.</span> Plot customizations - Modifying line, text and figure properties</h3>
<div class="outline-text-3" id="text-11-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/01/plot-customizations-modifying-line-text-and-figure-properties/">Matlab post</a>
</p>

<p>
Here is a vanilla plot.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2 * np.pi)
plt.plot(x, np.sin(x))
plt.savefig(<span style="color: #008000;">'images/plot-customization-1.png'</span>)
</pre>
</div>


<div id="orgf39b292" class="figure">
<p><img src="pycse-chapters/images/plot-customization-1.png" alt="plot-customization-1.png" />
</p>
</div>

<p>
Lets increase the line thickness, change the line color to red, and make the markers red circles with black outlines. I also like figures in presentations to be 6 inches high, and 4 inches wide.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2 * np.pi)

plt.figure(figsize=(4, 6))
plt.plot(x, np.sin(x), lw=2, color=<span style="color: #008000;">'r'</span>, marker=<span style="color: #008000;">'o'</span>, mec=<span style="color: #008000;">'k'</span>, mfc=<span style="color: #008000;">'b'</span>)

plt.xlabel(<span style="color: #008000;">'x data'</span>, fontsize=12, fontweight=<span style="color: #008000;">'bold'</span>)
plt.ylabel(<span style="color: #008000;">'y data'</span>, fontsize=12, fontstyle=<span style="color: #008000;">'italic'</span>, color=<span style="color: #008000;">'b'</span>)
plt.tight_layout() <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">auto-adjust position of axes to fit figure.</span>
plt.savefig(<span style="color: #008000;">'images/plot-customization-2.png'</span>)
</pre>
</div>


<div id="orgc705caa" class="figure">
<p><img src="pycse-chapters/images/plot-customization-2.png" alt="plot-customization-2.png" />
</p>
</div>
</div>

<div id="outline-container-org382bb74" class="outline-4">
<h4 id="org382bb74"><span class="section-number-4">11.1.1.</span> setting all the text properties in a figure.</h4>
<div class="outline-text-4" id="text-11-1-1">
<p>
You may notice the axis tick labels are not consistent with the labels now. If you have many plots it can be tedious to try setting each text property. Python to the rescue! With these commands you can find all the text instances, and change them all at one time! Likewise, you can change all the lines, and all the axes.
</p>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2 * np.pi)

plt.figure(figsize=(4, 6))
plt.plot(x, np.sin(x), lw=2, color=<span style="color: #008000;">'r'</span>, marker=<span style="color: #008000;">'o'</span>, mec=<span style="color: #008000;">'k'</span>, mfc=<span style="color: #008000;">'b'</span>)

plt.xlabel(<span style="color: #008000;">'x data'</span>, fontsize=12, fontweight=<span style="color: #008000;">'bold'</span>)
plt.ylabel(<span style="color: #008000;">'y data'</span>, fontsize=12, fontstyle=<span style="color: #008000;">'italic'</span>, color=<span style="color: #008000;">'b'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">set all font properties</span>
fig = plt.gcf()
<span style="color: #0000FF;">for</span> o <span style="color: #0000FF;">in</span>  fig.findobj(<span style="color: #0000FF;">lambda</span> x:<span style="color: #006FE0;">hasattr</span>(x, <span style="color: #008000;">'set_fontname'</span>)
                      <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">hasattr</span>(x, <span style="color: #008000;">'set_fontweight'</span>)
                      <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">hasattr</span>(x, <span style="color: #008000;">'set_fontsize'</span>)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   o.set_fontname(<span style="color: #008000;">'Arial'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   o.set_fontweight(<span style="color: #008000;">'bold'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   o.set_fontsize(14)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">make anything you can set linewidth to be lw=2</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">myfunc</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #006FE0;">hasattr</span>(x, <span style="color: #008000;">'set_linewidth'</span>)

<span style="color: #0000FF;">for</span> o <span style="color: #0000FF;">in</span>  fig.findobj(myfunc):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   o.set_linewidth(2)

plt.tight_layout() <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">auto-adjust position of axes to fit figure.</span>
plt.savefig(<span style="color: #008000;">'images/plot-customization-3.png'</span>)
</pre>
</div>


<div id="orgfb83290" class="figure">
<p><img src="pycse-chapters/images/plot-customization-3.png" alt="plot-customization-3.png" />
</p>
</div>

<p>
There are many other things you can do!
</p>
</div>
</div>
</div>
<div id="outline-container-orgfb0a3dc" class="outline-3">
<h3 id="orgfb0a3dc"><span class="section-number-3">11.2.</span> Plotting two datasets with very different scales</h3>
<div class="outline-text-3" id="text-11-2">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/25/plotting-two-datasets-with-very-different-scales/">Matlab plot</a>
</p>

<p>
Sometimes you will have two datasets you want to plot together, but the scales will be so different it is hard to seem them both in the same plot. Here we examine a few strategies to plotting this kind of data.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2*np.pi)
<span style="color: #BA36A5;">y1</span> = np.sin(x);
<span style="color: #BA36A5;">y2</span> = 0.01 * np.cos(x);

plt.plot(x, y1, x, y2)
plt.legend([<span style="color: #008000;">'y1'</span>, <span style="color: #008000;">'y2'</span>])
plt.savefig(<span style="color: #008000;">'images/two-scales-1.png'</span>)
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">in this plot y2 looks almost flat!</span>
</pre>
</div>


<div id="orgc5eac7d" class="figure">
<p><img src="pycse-chapters/images/two-scales-1.png" alt="two-scales-1.png" />
</p>
</div>
</div>

<div id="outline-container-org96845dd" class="outline-4">
<h4 id="org96845dd"><span class="section-number-4">11.2.1.</span> Make two plots!</h4>
<div class="outline-text-4" id="text-11-2-1">
<p>
this certainly solves the problem, but you have two full size plots, which can take up a lot of space in a presentation and report. Often your goal in plotting both data sets is to compare them, and it is easiest to compare plots when they are perfectly lined up. Doing that manually can be tedious.
</p>

<div class="org-src-container">
<pre class="src src-python">plt.figure()
plt.plot(x,y1)
plt.legend([<span style="color: #008000;">'y1'</span>])
plt.savefig(<span style="color: #008000;">'images/two-scales-2.png'</span>)

plt.figure()
plt.plot(x,y2)
plt.legend([<span style="color: #008000;">'y2'</span>])
plt.savefig(<span style="color: #008000;">'images/two-scales-3.png'</span>)
</pre>
</div>


<div id="org99e6031" class="figure">
<p><img src="pycse-chapters/images/two-scales-2.png" alt="two-scales-2.png" />
</p>
</div>


<div id="org5a28415" class="figure">
<p><img src="pycse-chapters/images/two-scales-3.png" alt="two-scales-3.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org905db56" class="outline-4">
<h4 id="org905db56"><span class="section-number-4">11.2.2.</span> Scaling the results</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
Sometimes you can scale one dataset so it has a similar magnitude as the other data set. Here we could multiply y2 by 100, and then it will be similar in size to y1. Of course, you need to indicate that y2 has been scaled in the graph somehow. Here we use the legend.
</p>

<div class="org-src-container">
<pre class="src src-python">plt.figure()
plt.plot(x, y1, x, 100 * y2)
plt.legend([<span style="color: #008000;">'y1'</span>, <span style="color: #008000;">'100*y2'</span>])
plt.savefig(<span style="color: #008000;">'images/two-scales-4.png'</span>)
</pre>
</div>


<div id="orgeaec4eb" class="figure">
<p><img src="pycse-chapters/images/two-scales-4.png" alt="two-scales-4.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org0432302" class="outline-4">
<h4 id="org0432302"><span class="section-number-4">11.2.3.</span> Double-y axis plot</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
<a href="plot!double y-axis">plot!double y-axis</a>
</p>

<p>
Using two separate y-axes can solve your scaling problem. Note that each y-axis is color coded to the data. It can be difficult to read these graphs when printed in black and white
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">fig</span> = plt.figure()
<span style="color: #BA36A5;">ax1</span> = fig.add_subplot(111)
ax1.plot(x, y1)
ax1.set_ylabel(<span style="color: #008000;">'y1'</span>)

<span style="color: #BA36A5;">ax2</span> = ax1.twinx()
ax2.plot(x, y2, <span style="color: #008000;">'r-'</span>)
ax2.set_ylabel(<span style="color: #008000;">'y2'</span>, color=<span style="color: #008000;">'r'</span>)
<span style="color: #0000FF;">for</span> tl <span style="color: #0000FF;">in</span> ax2.get_yticklabels():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   tl.set_color(<span style="color: #008000;">'r'</span>)

plt.savefig(<span style="color: #008000;">'images/two-scales-5.png'</span>)
</pre>
</div>



<div id="org5fab4cd" class="figure">
<p><img src="pycse-chapters/images/two-scales-5.png" alt="two-scales-5.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org43991a2" class="outline-4">
<h4 id="org43991a2"><span class="section-number-4">11.2.4.</span> Subplots</h4>
<div class="outline-text-4" id="text-11-2-4">
<p>
<a href="plot!subplot">plot!subplot</a>
An alternative approach to double y axes is to use subplots.
</p>

<div class="org-src-container">
<pre class="src src-python">plt.figure()
<span style="color: #BA36A5;">f</span>, <span style="color: #BA36A5;">axes</span> = plt.subplots(2, 1)
axes[0].plot(x, y1)
axes[0].set_ylabel(<span style="color: #008000;">'y1'</span>)

axes[1].plot(x, y2)
axes[1].set_ylabel(<span style="color: #008000;">'y2'</span>)
plt.savefig(<span style="color: #008000;">'images/two-scales-6.png'</span>)
</pre>
</div>


<div id="orgf9cbfca" class="figure">
<p><img src="pycse-chapters/images/two-scales-6.png" alt="two-scales-6.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgff2aa55" class="outline-3">
<h3 id="orgff2aa55"><span class="section-number-3">11.3.</span> Customizing plots after the fact</h3>
<div class="outline-text-3" id="text-11-3">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/16/customizing-plots-after-the-fact/">Matlab post</a>
Sometimes it is desirable to make a plot that shows the data you want to present, and to customize the details, e.g. font size/type and line thicknesses afterwards. It can be tedious to try to add the customization code to the existing code that makes the plot. Today, we look at a way to do the customization after the plot is created.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x</span> = np.linspace(0,2)
<span style="color: #BA36A5;">y1</span> = x
<span style="color: #BA36A5;">y2</span> = x**2
<span style="color: #BA36A5;">y3</span> = x**3

plt.plot(x, y1, x, y2, x, y3)
<span style="color: #BA36A5;">xL</span> = plt.xlabel(<span style="color: #008000;">'x'</span>)
<span style="color: #BA36A5;">yL</span> = plt.ylabel(<span style="color: #008000;">'f(x)'</span>)
plt.title(<span style="color: #008000;">'plots of y = x^n'</span>)
plt.legend([<span style="color: #008000;">'x'</span>, <span style="color: #008000;">'x^2'</span>, <span style="color: #008000;">'x^3'</span>], loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/after-customization-1.png'</span>)

fig = plt.gcf()

plt.setp(fig, <span style="color: #008000;">'size_inches'</span>, (4, 6))
plt.savefig(<span style="color: #008000;">'images/after-customization-2.png'</span>)


<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">set lines to dashed</span>
<span style="color: #0000FF;">from</span> matplotlib.lines <span style="color: #0000FF;">import</span> Line2D
<span style="color: #0000FF;">for</span> o <span style="color: #0000FF;">in</span> fig.findobj(Line2D):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   o.set_linestyle(<span style="color: #008000;">'--'</span>)

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">set(allaxes,'FontName','Arial','FontWeight','Bold','LineWidth',2,'FontSize',14);</span>

<span style="color: #0000FF;">import</span> matplotlib.text <span style="color: #0000FF;">as</span> text
<span style="color: #0000FF;">for</span> o <span style="color: #0000FF;">in</span> fig.findobj(text.Text):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.setp(o, <span style="color: #008000;">'fontname'</span>,<span style="color: #008000;">'Arial'</span>, <span style="color: #008000;">'fontweight'</span>,<span style="color: #008000;">'bold'</span>, <span style="color: #008000;">'fontsize'</span>, 14)

plt.setp(xL, <span style="color: #008000;">'fontstyle'</span>, <span style="color: #008000;">'italic'</span>)
plt.setp(yL, <span style="color: #008000;">'fontstyle'</span>, <span style="color: #008000;">'italic'</span>)
plt.savefig(<span style="color: #008000;">'images/after-customization-3.png'</span>)
</pre>
</div>


<div id="orgef1e787" class="figure">
<p><img src="pycse-chapters/images/after-customization-1.png" alt="after-customization-1.png" />
</p>
</div>


<div id="org3ee9d50" class="figure">
<p><img src="pycse-chapters/images/after-customization-2.png" alt="after-customization-2.png" />
</p>
</div>


<div id="org1bc655d" class="figure">
<p><img src="pycse-chapters/images/after-customization-3.png" alt="after-customization-3.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb0f808e" class="outline-3">
<h3 id="orgb0f808e"><span class="section-number-3">11.4.</span> Fancy, built-in colors in Python</h3>
<div class="outline-text-3" id="text-11-4">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/13/check-out-the-new-fall-colors/">Matlab post</a>
</p>

<p>
Matplotlib has a lot of built-in colors. Here is a list of them, and an example of using them.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">from</span> matplotlib.colors <span style="color: #0000FF;">import</span> cnames
<span style="color: #0000FF;">print</span>(cnames.keys())

plt.plot([1, 2, 3, 4], lw=2, color=<span style="color: #008000;">'moccasin'</span>, marker=<span style="color: #008000;">'o'</span>, mfc=<span style="color: #008000;">'lightblue'</span>, mec=<span style="color: #008000;">'seagreen'</span>)
plt.savefig(<span style="color: #008000;">'images/fall-colors.png'</span>)
</pre>
</div>


<div id="orgf7c45e4" class="figure">
<p><img src="pycse-chapters/images/fall-colors.png" alt="fall-colors.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgfc444bb" class="outline-3">
<h3 id="orgfc444bb"><span class="section-number-3">11.5.</span> Picasso's short lived blue period with Python</h3>
<div class="outline-text-3" id="text-11-5">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/14/picassos-short-lived-blue-period-with-matlab/">Matlab post</a>
</p>

<p>
It is an unknown fact that Picasso had a brief blue plotting period with Matlab before moving on to his more famous paintings. It started from irritation with the default colors available in Matlab for plotting. After watching his friend van Gogh cut off his own ear out of frustration with the ugly default colors, Picasso had to do something different.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">this plots horizontal lines for each y value of m.</span>
<span style="color: #0000FF;">for</span> m <span style="color: #0000FF;">in</span> np.linspace(1, 50, 100):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot([0, 50], [m, m])

plt.savefig(<span style="color: #008000;">'images/blues-1.png'</span>)
</pre>
</div>


<div id="orgdfa0fe8" class="figure">
<p><img src="pycse-chapters/images/blues-1.png" alt="blues-1.png" />
</p>
</div>

<p>
Picasso copied the table available at <a href="http://en.wikipedia.org/wiki/List_of_colors">http://en.wikipedia.org/wiki/List_of_colors</a> and parsed it into a dictionary of hex codes for new colors. That allowed him to specify a list of beautiful blues for his graph. Picasso eventually gave up on python as an artform, and moved on to painting.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">c</span> = {}
<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'color.table'</span>) <span style="color: #0000FF;">as</span> <span style="color: #BA36A5;">f</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> line <span style="color: #0000FF;">in</span> f:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   fields = line.split(<span style="color: #008000;">'\t'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">colorname</span> = fields[0].lower()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">hexcode</span> = fields[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">c</span>[<span style="color: #BA36A5;">colorname</span>] = hexcode

<span style="color: #BA36A5;">names</span> = c.keys()
<span style="color: #BA36A5;">names</span> = <span style="color: #006FE0;">sorted</span>(names)

<span style="color: #0000FF;">print</span>(names)

<span style="color: #BA36A5;">blues</span> = [c[<span style="color: #008000;">'alice blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'light blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'baby blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'light sky blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'maya blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'cornflower blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'bleu de france'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'azure'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'blue sapphire'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'cobalt'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'egyptian blue'</span>],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>c[<span style="color: #008000;">'duke blue'</span>]]

<span style="color: #BA36A5;">ax</span> = plt.gca()
ax.set_color_cycle(blues)

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">this plots horizontal lines for each y value of m.</span>
<span style="color: #0000FF;">for</span> i, m <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(np.linspace(1, 50, 100)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot([0, 50], [m, m])

plt.savefig(<span style="color: #008000;">'images/blues-2.png'</span>)
</pre>
</div>


<div id="org60453e0" class="figure">
<p><img src="pycse-chapters/images/blues-2.png" alt="blues-2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orge5a9438" class="outline-3">
<h3 id="orge5a9438"><span class="section-number-3">11.6.</span> Interactive plotting</h3>
<div class="outline-text-3" id="text-11-6">
</div>
<div id="outline-container-org1684882" class="outline-4">
<h4 id="org1684882"><span class="section-number-4">11.6.1.</span> Basic mouse clicks</h4>
<div class="outline-text-4" id="text-11-6-1">
<p>
<a href="plotting!interactive mouse click">plotting!interactive mouse click</a>
<a href="plotting!interactive key press">plotting!interactive key press</a>
One basic event a figure can react to is a mouse click. Let us make a graph with a parabola in it, and draw the shortest line from a point clicked on to the graph. Here is an example of doing that.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_cobyla

<span style="color: #BA36A5;">fig</span> = plt.figure()

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x**2

<span style="color: #BA36A5;">x</span> = np.linspace(-2, 2)
<span style="color: #BA36A5;">y</span> = f(x)

<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)
ax.plot(x, y)
ax.set_title(<span style="color: #008000;">'Click somewhere'</span>)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">onclick</span>(event):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ax</span> = plt.gca()

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">P</span> = (event.xdata, event.ydata)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.sqrt((x - P[0])**2 + (y - P[1])**2)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">c1</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x</span>,<span style="color: #BA36A5;">y</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f(x) - y

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">X</span> = fmin_cobyla(objective, x0=[P[0], f(P[0])], cons=[c1])

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.set_title(<span style="color: #008000;">'x={0:1.2f} y={1:1.2f}'</span>.<span style="color: #006FE0;">format</span>(event.xdata, event.ydata))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.plot([event.xdata, X[0]], [event.ydata, X[1]], <span style="color: #008000;">'ro-'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is critical to change the title</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.savefig(<span style="color: #008000;">'images/interactive-basic-click.png'</span>)

cid = fig.canvas.mpl_connect(<span style="color: #008000;">'button_press_event'</span>, onclick)
plt.show()
</pre>
</div>


<p>
Here is the result from two clicks. For some reason, this only works when you click inside the parabola. It does not work outside the parabola.
</p>


<div id="org064943c" class="figure">
<p><img src="pycse-chapters/images/interactive-basic-click.png" alt="interactive-basic-click.png" />
</p>
</div>

<p>
We can even do different things with different mouse clicks. A left click corresponds to event.button = 1, a middle click is event.button = 2, and a right click is event.button = 3. You can detect if a double click occurs too. Here is an example of these different options.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">fig</span> = plt.figure()

<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)
ax.plot(np.random.rand(10))
ax.set_title(<span style="color: #008000;">'Click somewhere'</span>)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">onclick</span>(event):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.set_title(<span style="color: #008000;">'x={0:1.2f} y={1:1.2f} button={2}'</span>.<span style="color: #006FE0;">format</span>(event.xdata, event.ydata, event.button))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   colors = <span style="color: #008000;">' rbg'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'button={0} (dblclick={2}). making a {1} dot'</span>.<span style="color: #006FE0;">format</span>(event.button,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  colors[event.button],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  event.dblclick))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ms=5 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">marker size</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> event.dblclick: <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">make marker bigger</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ms = 10

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.plot([event.xdata], [event.ydata], <span style="color: #008000;">'o'</span>, color=colors[event.button], ms=ms)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is critical to change the title</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.savefig(<span style="color: #008000;">'images/interactive-button-click.png'</span>)

cid = fig.canvas.mpl_connect(<span style="color: #008000;">'button_press_event'</span>, onclick)
plt.show()
</pre>
</div>


<div id="orgcfd7148" class="figure">
<p><img src="pycse-chapters/images/interactive-button-click.png" alt="interactive-button-click.png" />
</p>
</div>

<p>
Finally, you may want to have key modifiers for your clicks, e.g. Ctrl-click is different than a click.
</p>
</div>
</div>
</div>

<div id="outline-container-org6c05113" class="outline-3">
<h3 id="org6c05113"><span class="section-number-3">11.7.</span> key events not working on Mac/org-mode</h3>
<div class="outline-text-3" id="text-11-7">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> __future__ <span style="color: #0000FF;">import</span> print_function
<span style="color: #0000FF;">import</span> sys
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt


<span style="color: #0000FF;">def</span> <span style="color: #006699;">press</span>(event):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'press'</span>, event.key)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sys.stdout.flush()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> event.key == <span style="color: #008000;">'x'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   visible = xl.get_visible()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xl.set_visible(<span style="color: #0000FF;">not</span> visible)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   fig.canvas.draw()

<span style="color: #BA36A5;">fig</span>, <span style="color: #BA36A5;">ax</span> = plt.subplots()

fig.canvas.mpl_connect(<span style="color: #008000;">'key_press_event'</span>, press)

ax.plot(np.random.rand(12), np.random.rand(12), <span style="color: #008000;">'go'</span>)
xl = ax.set_xlabel(<span style="color: #008000;">'easy come, easy go'</span>)

plt.show()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">fig</span> = plt.figure()

<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)
ax.plot(np.random.rand(10))
ax.set_title(<span style="color: #008000;">'Click somewhere'</span>)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">onclick</span>(event):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(event)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ax</span> = plt.gca()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.set_title(<span style="color: #008000;">'x={0:1.2f} y={1:1.2f}'</span>.<span style="color: #006FE0;">format</span>(event.xdata, event.ydata))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> event.key == <span style="color: #008000;">'shift+control'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   color = <span style="color: #008000;">'red'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> event.key == <span style="color: #008000;">'shift'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   color = <span style="color: #008000;">'yellow'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   color = <span style="color: #008000;">'blue'</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.plot([event.xdata], [event.ydata], <span style="color: #008000;">'o'</span>, color=color)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is critical to change the title</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.savefig(<span style="color: #008000;">'images/interactive-button-key-click.png'</span>)

cid = fig.canvas.mpl_connect(<span style="color: #008000;">'button_press_event'</span>, onclick)
plt.show()
</pre>
</div>


<div id="org8495a52" class="figure">
<p><img src="pycse-chapters/images/interactive-button-key-click.png" alt="interactive-button-key-click.png" />
</p>
</div>

<p>
You can have almost every key-click combination imaginable. This allows you to have many different things that can happen when you click on a graph. With this method, you can get the coordinates close to a data point, but you do not get the properties of the point. For that, we need another mechanism.
</p>
</div>

<div id="outline-container-org5300ae0" class="outline-4">
<h4 id="org5300ae0"><span class="section-number-4">11.7.1.</span> Mouse movement</h4>
<div class="outline-text-4" id="text-11-7-1">
<p>
In this example, we will let the mouse motion move a point up and down a curve. This might be helpful to explore a function graph, for example. We use interpolation to estimate the curve between data points.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the "data"</span>
<span style="color: #BA36A5;">x</span> = np.linspace(0, np.pi)
<span style="color: #BA36A5;">y</span> = np.sin(x)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">interpolating function between points</span>
<span style="color: #BA36A5;">p</span> = interp1d(x, y, <span style="color: #008000;">'cubic'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">make the figure</span>
<span style="color: #BA36A5;">fig</span> = plt.figure()

<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)
<span style="color: #BA36A5;">line</span>, = ax.plot(x, y, <span style="color: #008000;">'ro-'</span>)
<span style="color: #BA36A5;">marker</span>, = ax.plot([0.5], [0.5],<span style="color: #008000;">'go'</span>,  ms=15)

ax.set_title(<span style="color: #008000;">'Move the mouse around'</span>)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">onmove</span>(event):

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xe = event.xdata
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ye = event.ydata

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.set_title(<span style="color: #008000;">'at x={0}  y={1}'</span>.<span style="color: #006FE0;">format</span>(xe, p(xe)))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   marker.set_xdata(xe)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   marker.set_ydata(p(xe))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is critical to change the title</span>

cid = fig.canvas.mpl_connect(<span style="color: #008000;">'motion_notify_event'</span>, onmove)
plt.show()
</pre>
</div>
</div>
</div>

<div id="outline-container-org54e2bdf" class="outline-4">
<h4 id="org54e2bdf"><span class="section-number-4">11.7.2.</span> key press events</h4>
<div class="outline-text-4" id="text-11-7-2">
<p>
Pressing a key is different than pressing a mouse button. We can do different things with different key presses. You can access the coordinates of the mouse when you press a key.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">fig</span> = plt.figure()

<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)
ax.plot(np.random.rand(10))
ax.set_title(<span style="color: #008000;">'Move the mouse somewhere and press a key'</span>)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">onpress</span>(event):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(event.key)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ax</span> = plt.gca()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.set_title(<span style="color: #008000;">'key={2} at x={0:1.2f} y={1:1.2f}'</span>.<span style="color: #006FE0;">format</span>(event.xdata, event.ydata, event.key))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> event.key == <span style="color: #008000;">'r'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   color = <span style="color: #008000;">'red'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> event.key == <span style="color: #008000;">'y'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   color = <span style="color: #008000;">'yellow'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   color = <span style="color: #008000;">'blue'</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.plot([event.xdata], [event.ydata], <span style="color: #008000;">'o'</span>, color=color)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is critical to change the title</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.savefig(<span style="color: #008000;">'images/interactive-key-press.png'</span>)

cid = fig.canvas.mpl_connect(<span style="color: #008000;">'key_press_event'</span>, onpress)
plt.show()
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee5d892" class="outline-4">
<h4 id="orgee5d892"><span class="section-number-4">11.7.3.</span> Picking lines</h4>
<div class="outline-text-4" id="text-11-7-3">
<p>
Instead of just getting the points in a figure, let us interact with lines on the graph. We want to make the line we click on thicker. We use a "pick_event" event and bind a function to that event that does something.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">fig</span> = plt.figure()
<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)
ax.set_title(<span style="color: #008000;">'click on a line'</span>)

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2*np.pi)

<span style="color: #BA36A5;">L1</span>, = ax.plot(x, np.sin(x), picker=5)
<span style="color: #BA36A5;">L2</span>, = ax.plot(x, np.cos(x), picker=5)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">onpick</span>(event):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   thisline = event.artist

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reset all lines to thin</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> line <span style="color: #0000FF;">in</span> [L1, L2]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   line.set_lw(1)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   thisline.set_lw(5) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">make selected line thick</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is critical to change the linewidth</span>

fig.canvas.mpl_connect(<span style="color: #008000;">'pick_event'</span>, onpick)

plt.show()
</pre>
</div>
</div>
</div>

<div id="outline-container-org3be2a7f" class="outline-4">
<h4 id="org3be2a7f"><span class="section-number-4">11.7.4.</span> Picking data points</h4>
<div class="outline-text-4" id="text-11-7-4">
<p>
In this example we show how to click on a data point, and show which point was selected with a transparent marker, and show a label which refers to the point.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">fig</span> = plt.figure()
<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)
ax.set_title(<span style="color: #008000;">'click on a point'</span>)

<span style="color: #BA36A5;">x</span> = [0, 1, 2, 3, 4, 5]
<span style="color: #BA36A5;">labels</span> = [<span style="color: #008000;">'a'</span>, <span style="color: #008000;">'b'</span>, <span style="color: #008000;">'c'</span>, <span style="color: #008000;">'d'</span>, <span style="color: #008000;">'e'</span>, <span style="color: #008000;">'f'</span>]
ax.plot(x, <span style="color: #008000;">'bo'</span>, picker=5)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the transparent marker for the selected data point</span>
<span style="color: #BA36A5;">marker</span>, = ax.plot([0], [0], <span style="color: #008000;">'yo'</span>, visible=<span style="color: #D0372D;">False</span>, alpha=0.8, ms=15)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">onpick</span>(event):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ind = event.ind
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.set_title(<span style="color: #008000;">'Data point {0} is labeled "{1}"'</span>.<span style="color: #006FE0;">format</span>(ind, labels[ind]))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   marker.set_visible(<span style="color: #D0372D;">True</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   marker.set_xdata(x[ind])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   marker.set_ydata(x[ind])

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ax.figure.canvas.draw()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this line is critical to change the linewidth</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.savefig(<span style="color: #008000;">'images/interactive-labeled-points.png'</span>)

fig.canvas.mpl_connect(<span style="color: #008000;">'pick_event'</span>, onpick)

plt.show()
</pre>
</div>


<div id="orgf6780d9" class="figure">
<p><img src="pycse-chapters/images/interactive-labeled-points.png" alt="interactive-labeled-points.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb3a562f" class="outline-3">
<h3 id="orgb3a562f"><span class="section-number-3">11.8.</span> Peak annotation in matplotlib</h3>
<div class="outline-text-3" id="text-11-8">
<p>
This post is just some examples of annotating features in a plot in matplotlib. We illustrate finding peak maxima in a range, shading a region, shading peaks, and labeling a region of peaks. I find it difficult to remember the detailed syntax for these, so here are examples I could refer to later.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">w</span>, <span style="color: #BA36A5;">i</span> = np.loadtxt(<span style="color: #008000;">'data/raman.txt'</span>, usecols=(0, 1), unpack=<span style="color: #D0372D;">True</span>)

plt.plot(w, i)
plt.xlabel(<span style="color: #008000;">'Raman shift (cm$^{-1}$)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (counts)'</span>)

ax = plt.gca()

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">put a shaded rectangle over a region</span>
ax.annotate(<span style="color: #008000;">'Some typical region'</span>, xy=(550, 15500), xycoords=<span style="color: #008000;">'data'</span>)
ax.fill_between([700, 800], 0, [16000, 16000], facecolor=<span style="color: #008000;">'red'</span>, alpha=0.25)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">shade the region in the spectrum</span>
ind = (w&gt;1019) &amp; (w&lt;1054)
ax.fill_between(w[ind], 0, i[ind], facecolor=<span style="color: #008000;">'gray'</span>, alpha=0.5)
area = np.trapz(i[ind], w[ind])
x, y = w[ind][np.argmax(i[ind])], i[ind][np.argmax(i[ind])]
ax.annotate(<span style="color: #008000;">'Area = {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(area), xy=(x, y),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xycoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xytext=(x + 50, y + 5000),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   textcoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   arrowprops=<span style="color: #006FE0;">dict</span>(arrowstyle=<span style="color: #008000;">"-&gt;"</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   connectionstyle=<span style="color: #008000;">"angle,angleA=0,angleB=90,rad=10"</span>))


<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">find a max in this region, and annotate it</span>
ind = (w&gt;1250) &amp; (w&lt;1252)
x,y = w[ind][np.argmax(i[ind])], i[ind][np.argmax(i[ind])]
ax.annotate(<span style="color: #008000;">'A peak'</span>, xy=(x, y),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xycoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xytext=(x + 350, y + 2000),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   textcoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   arrowprops=<span style="color: #006FE0;">dict</span>(arrowstyle=<span style="color: #008000;">"-&gt;"</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   connectionstyle=<span style="color: #008000;">"angle,angleA=0,angleB=90,rad=10"</span>))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">find max in this region, and annotate it</span>
ind = (w&gt;1380) &amp; (w&lt;1400)
x,y = w[ind][np.argmax(i[ind])], i[ind][np.argmax(i[ind])]
ax.annotate(<span style="color: #008000;">'Another peak'</span>, xy=(x, y),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xycoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xytext=(x + 50, y + 2000),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   textcoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   arrowprops=<span style="color: #006FE0;">dict</span>(arrowstyle=<span style="color: #008000;">"-&gt;"</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   connectionstyle=<span style="color: #008000;">"angle,angleA=0,angleB=90,rad=10"</span>))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">indicate a region with connected arrows</span>
ax.annotate(<span style="color: #008000;">'CH bonds'</span>, xy=(2780, 6000), xycoords=<span style="color: #008000;">'data'</span>)
ax.annotate(<span style="color: #008000;">''</span>, xy=(2800., 5000.),  xycoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   xytext=(3050, 5000), textcoords=<span style="color: #008000;">'data'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the arrows connect the xy to xytext coondinates</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   arrowprops=<span style="color: #006FE0;">dict</span>(arrowstyle=<span style="color: #008000;">"&lt;-&gt;"</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   connectionstyle=<span style="color: #008000;">"bar"</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ec=<span style="color: #008000;">"k"</span>,  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">edge color</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   shrinkA=0.1, shrinkB=0.1))

plt.savefig(<span style="color: #008000;">'images/plot-annotes.png'</span>)
plt.show()
</pre>
</div>


<div id="org53a5761" class="figure">
<p><img src="pycse-chapters/images/plot-annotes.png" alt="plot-annotes.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org23cbd1d" class="outline-2">
<h2 id="org23cbd1d"><span class="section-number-2">12.</span> Programming</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org2e9a6d2" class="outline-3">
<h3 id="org2e9a6d2"><span class="section-number-3">12.1.</span> Some of this, sum of that</h3>
<div class="outline-text-3" id="text-12-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2012/05/29/some-of-this-sum-of-that/">Matlab plot</a>
</p>

<p>
Python provides a sum function to compute the sum of a list. However, the sum function does not work on every arrangement of numbers, and it certainly does not work on nested lists. We will solve this problem with recursion.
</p>

<p>
Here is a simple example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">v</span> = [1, 2, 3, 4, 5, 6, 7, 8, 9] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">a list</span>
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sum</span>(v))

<span style="color: #BA36A5;">v</span> = (1, 2, 3, 4, 5, 6, 7, 8, 9)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">a tuple</span>
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sum</span>(v))
</pre>
</div>

<p>
If you have data in a dictionary, sum works by default on the keys. You can give the sum function the values like this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">v</span> = {<span style="color: #008000;">'a'</span>:1, <span style="color: #008000;">'b'</span>:3, <span style="color: #008000;">'c'</span>:4}
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sum</span>(v.values()))
</pre>
</div>
</div>

<div id="outline-container-org4558360" class="outline-4">
<h4 id="org4558360"><span class="section-number-4">12.1.1.</span> Nested lists</h4>
<div class="outline-text-4" id="text-12-1-1">
<p>
Suppose now we have nested lists. This kind of structured data might come up if you had grouped several things together. For example, suppose we have 5 departments, with 1, 5, 15, 7 and 17 people in them, and in each department they are divided into groups.
</p>

<p>
Department 1: 1 person
Department 2: group of 2 and group of 3
Department 3: group of 4 and 11, with a subgroups of 5 and 6 making
              up the group of 11.
Department 4: 7 people
Department 5: one group of 8 and one group of 9.
</p>

<p>
We might represent the data like this nested list. Now, if we want to compute the total number of people, we need to add up each group. We cannot simply sum the list, because some elements are single numbers, and others are lists, or lists of lists. We need to recurse through each entry until we get down to a number, which we can add to the running sum.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">v</span> = [1,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [2, 3],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [4, [5, 6]],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   7,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [8,9]]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">recursive_sum</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'compute sum of arbitrarily nested lists'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">s</span> = 0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial value of the sum</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(X)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">import</span> types  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we use this to test if we got a number</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #006FE0;">isinstance</span>(X[i], (<span style="color: #006FE0;">int</span>, <span style="color: #006FE0;">float</span>, <span style="color: #006FE0;">complex</span>)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the terminal step</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">s</span> += X[i]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we did not get a number, so we recurse</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   s += recursive_sum(X[i])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> s

<span style="color: #0000FF;">print</span>(recursive_sum(v))
<span style="color: #0000FF;">print</span>(recursive_sum([1, 2, 3, 4, 5, 6, 7, 8, 9])) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">test on non-nested list</span>
</pre>
</div>

<p>
In <a href="http://matlab.cheme.cmu.edu/2012/05/28/lather-rinse-and-repeat/">Post 1970</a> we examined recursive functions that could be replaced by loops. Here we examine a function that can only work with recursion because the nature of the nested data structure is arbitrary. There are arbitrary branches and depth in the data structure. Recursion is nice because you do not have to define that structure in advance.
</p>
</div>
</div>
</div>

<div id="outline-container-org20a8dbc" class="outline-3">
<h3 id="org20a8dbc"><span class="section-number-3">12.2.</span> Sorting in python</h3>
<div class="outline-text-3" id="text-12-2">
<p>
<a href="sort">sort</a>
<a href="http://matlab.cheme.cmu.edu/2011/11/12/sorting-in-matlab/">Matlab post</a>
</p>

<p>
Occasionally it is important to have sorted data. Python has a few sorting options.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [4, 5, 1, 6, 8, 3, 2]
<span style="color: #0000FF;">print</span>(a)
a.sort()  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">inplace sorting</span>
<span style="color: #0000FF;">print</span>(a)

a.sort(reverse=<span style="color: #D0372D;">True</span>)
<span style="color: #0000FF;">print</span>(a)
</pre>
</div>

<p>
If you do not want to modify your list, but rather get a copy of a sorted list, use the sorted command.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [4, 5, 1, 6, 8, 3, 2]
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'sorted a = '</span>,<span style="color: #006FE0;">sorted</span>(a))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">no change to a</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'sorted a = '</span>,<span style="color: #006FE0;">sorted</span>(a, reverse=<span style="color: #D0372D;">True</span>))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">no change to a</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'a        = '</span>,a)
</pre>
</div>

<p>
This works for strings too:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [<span style="color: #008000;">'b'</span>, <span style="color: #008000;">'a'</span>, <span style="color: #008000;">'c'</span>, <span style="color: #008000;">'tree'</span>]
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sorted</span>(a))
</pre>
</div>

<p>
Here is a subtle point though. A capitalized letter comes before a lowercase letter. We can pass a function to the sorted command that is called on each element prior to the sort. Here we make each word lower case before sorting.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [<span style="color: #008000;">'B'</span>, <span style="color: #008000;">'a'</span>, <span style="color: #008000;">'c'</span>, <span style="color: #008000;">'tree'</span>]
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sorted</span>(a))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">sort by lower case letter</span>
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sorted</span>(a, key=<span style="color: #006FE0;">str</span>.lower))
</pre>
</div>

<p>
Here is a more complex sorting problem. We have a list of tuples with group names and the letter grade. We want to sort the list by the letter grades. We do this by creating a function that maps the letter grades to the position of the letter grades in a sorted list. We use the list.index function to find the index of the letter grade, and then sort on that.
</p>

<div class="org-src-container">
<pre class="src src-python">
<span style="color: #BA36A5;">groups</span> = [(<span style="color: #008000;">'group1'</span>, <span style="color: #008000;">'B'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> (<span style="color: #008000;">'group2'</span>, <span style="color: #008000;">'A+'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> (<span style="color: #008000;">'group3'</span>, <span style="color: #008000;">'A'</span>)]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">grade_key</span>(gtup):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''gtup is a tuple of ('groupname', 'lettergrade')'''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">lettergrade</span> = gtup[1]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">grades</span> = [<span style="color: #008000;">'A++'</span>, <span style="color: #008000;">'A+'</span>, <span style="color: #008000;">'A'</span>, <span style="color: #008000;">'A-'</span>, <span style="color: #008000;">'A/B'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> <span style="color: #008000;">'B+'</span>, <span style="color: #008000;">'B'</span>, <span style="color: #008000;">'B-'</span>, <span style="color: #008000;">'B/C'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> <span style="color: #008000;">'C+'</span>, <span style="color: #008000;">'C'</span>, <span style="color: #008000;">'C-'</span>, <span style="color: #008000;">'C/D'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> <span style="color: #008000;">'D+'</span>, <span style="color: #008000;">'D'</span>, <span style="color: #008000;">'D-'</span>, <span style="color: #008000;">'D/R'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> <span style="color: #008000;">'R+'</span>, <span style="color: #008000;">'R'</span>, <span style="color: #008000;">'R-'</span>, <span style="color: #008000;">'R--'</span>]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> grades.index(lettergrade)

<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">sorted</span>(groups, key=grade_key))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb88c03d" class="outline-3">
<h3 id="orgb88c03d"><span class="section-number-3">12.3.</span> Unique entries in a vector</h3>
<div class="outline-text-3" id="text-12-3">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/12/unique-entries-in-a-vector/">Matlab post</a>
</p>

<p>
It is surprising how often you need to know only the unique entries in a vector of entries. In python, we create a "set" from a list, which only contains unique entries. Then we convert the set back to a list.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [1, 1, 2, 3, 4, 5, 3, 5]

<span style="color: #BA36A5;">b</span> = <span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">set</span>(a))
<span style="color: #0000FF;">print</span>(b)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">a</span> = [<span style="color: #008000;">'a'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #008000;">'b'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #008000;">'abracadabra'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #008000;">'b'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #008000;">'c'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #008000;">'d'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #008000;">'b'</span>]

<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">set</span>(a)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgede7dd2" class="outline-3">
<h3 id="orgede7dd2"><span class="section-number-3">12.4.</span> Lather, rinse and repeat</h3>
<div class="outline-text-3" id="text-12-4">
<p>
<a href="http://matlab.cheme.cmu.edu/2012/05/28/lather-rinse-and-repeat/">Matlab post</a>
</p>

<p>
Recursive functions are functions that call themselves repeatedly until some exit condition is met. Today we look at a classic example of recursive function for computing a factorial. The factorial of a non-negative integer n is denoted n!, and is defined as the product of all positive integers less than or equal to n.
</p>

<p>
The key ideas in defining a recursive function is that there needs to be some logic to identify when to terminate the function. Then, you need logic that calls the function again, but with a smaller part of the problem. Here we recursively call the function with n-1 until it gets called with n=0. 0! is defined to be 1.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">recursive_factorial</span>(n):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''compute the factorial recursively. Note if you put a negative</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   number in, this function will never end. We also do not check if</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   n is an integer.'''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> n == 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> n * recursive_factorial(n - 1)

<span style="color: #0000FF;">print</span>(recursive_factorial(5))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.misc <span style="color: #0000FF;">import</span> factorial
<span style="color: #0000FF;">print</span>(factorial(5))
</pre>
</div>
</div>

<div id="outline-container-org4956a41" class="outline-5">
<h5 id="org4956a41"><span class="section-number-5">12.4.0.1.</span> Compare to a loop solution</h5>
<div class="outline-text-5" id="text-12-4-0-1">
<p>
This example can also be solved by a loop. This loop is easier to read and understand than the recursive function. Note the recursive nature of defining the variable as itself times a number.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">n</span> = 5
<span style="color: #BA36A5;">factorial_loop</span> = 1
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, n + 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">factorial_loop</span> *= i

<span style="color: #0000FF;">print</span>(factorial_loop)
</pre>
</div>

<p>
There are some significant differences in this example than in Matlab.
</p>

<ol class="org-ol">
<li>the syntax of the for loop is quite different with the use of the <code>in</code> operator.</li>
<li>python has the nice *= operator to replace a = a * i</li>
<li>We have to loop from 1 to n+1 because the last number in the range is not returned.</li>
</ol>
</div>
</div>

<div id="outline-container-orgd8c3342" class="outline-4">
<h4 id="orgd8c3342"><span class="section-number-4">12.4.1.</span> Conclusions</h4>
<div class="outline-text-4" id="text-12-4-1">
<p>
Recursive functions have a special niche in mathematical programming. There is often another way to accomplish the same goal. That is not always true though, and in a future post we will examine cases where recursion is the only way to solve a problem.
</p>
</div>
</div>
</div>
<div id="outline-container-org5400662" class="outline-3">
<h3 id="org5400662"><span class="section-number-3">12.5.</span> Brief intro to regular expressions</h3>
<div class="outline-text-3" id="text-12-5">
<p>
<a href="http://matlab.cheme.cmu.edu/2012/05/07/1701/">Matlab post</a>
</p>

<p>
This example shows how to use a regular expression to find strings matching the pattern :cmd:`datastring`. We want to find these strings, and then replace them with something that depends on what cmd is, and what datastring is.
</p>

<p>
Let us define some commands that will take datasring as an argument, and return the modified text. The idea is to find all the cmds, and then run them. We use python's <code>eval</code> command to get the function handle from a string, and the cmd functions all take a datastring argument (we define them that way). We will create commands to replace :cmd:`datastring` with html code for a light gray background, and :red:`some text` with html code making the text red.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">text</span> = r<span style="color: #008000;">'''Here is some text. use the :cmd:`open` to get the text into</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">   </span><span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">   </span><span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;"> a variable. It might also be possible to get a multiline</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">   </span><span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">   </span><span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">   :red:`line</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">   </span><span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">2`</span><span style="color: #D0372D;"> directive.</span><span style="color: #008000;">'''</span>

<span style="color: #0000FF;">print</span>(text)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'---------------------------------'</span>)
</pre>
</div>

<p>
Now, we define our functions.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">cmd</span>(datastring):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">' replace :cmd:`</span><span style="color: #D0372D;">datastring` with html code with light gray background</span><span style="color: #036A07;">'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   s = <span style="color: #008000;">'&lt;FONT style="BACKGROUND-COLOR: LightGray"&gt;%{0}&lt;/FONT&gt;'</span>;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">html</span> = s.<span style="color: #006FE0;">format</span>(datastring)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> html

<span style="color: #0000FF;">def</span> <span style="color: #006699;">red</span>(datastring):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'replace :red:`</span><span style="color: #D0372D;">datastring` with html code to make datastring in red font</span><span style="color: #036A07;">'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   html = <span style="color: #008000;">'&lt;font color=red&gt;{0}&lt;/font&gt;'</span>.<span style="color: #006FE0;">format</span>(datastring)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> html
</pre>
</div>

<p>
Finally, we do the regular expression. Regular expressions are hard. There are whole books on them. The point of this post is to alert you to the possibilities. I will break this regexp down as follows. 1. we want everything between :*: as the directive. <code>([^:]*)</code> matches everything not a :. <code>:([^:]*):</code> matches the stuff between two :. 2. then we want everything between `*`. <code>([^`]*)</code> matches everything not a `. 3. The () makes a group that python stores so we can refer to them later.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> re
<span style="color: #BA36A5;">regex</span> = <span style="color: #008000;">':([^:]*):`</span><span style="color: #D0372D;">([^`]*)`</span><span style="color: #008000;">'</span>
<span style="color: #BA36A5;">matches</span> = re.findall(regex, text)
<span style="color: #0000FF;">for</span> directive, datastring <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">matches</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   directive = <span style="color: #006FE0;">eval</span>(directive) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">get the function</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">text</span> = re.sub(regex, directive(datastring), text)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Modified text:'</span>)
<span style="color: #0000FF;">print</span>(text)
</pre>
</div>
</div>
</div>

<div id="outline-container-org65c1243" class="outline-3">
<h3 id="org65c1243"><span class="section-number-3">12.6.</span> Working with lists</h3>
<div class="outline-text-3" id="text-12-6">
<p>
It is not too uncommon to have a list of data, and then to apply a function to every element, to filter the list, or extract elements that meet some criteria. In this example, we take a string and split it into words. Then, we will examine several ways to apply functions to the words, to filter the list to get data that meets some criteria. Here is the string splitting.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">text</span> = <span style="color: #008000;">'''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #008000;">As we have seen, handling units with third party functions is fragile, and often requires additional code to wrap the function to handle the units. An alternative approach that avoids the wrapping is to rescale the equations so they are dimensionless. Then, we should be able to use all the standard external functions without modification. We obtain the final solutions by rescaling back to the answers we want.</span>

<span style="color: #008000;">Before doing the examples, let us consider how the quantities package handles dimensionless numbers.</span>

<span style="color: #008000;">import quantities as u</span>

<span style="color: #008000;">a = 5 * u.m</span>
<span style="color: #008000;">L = 10 * u.m # characteristic length</span>

<span style="color: #008000;">print a/L</span>
<span style="color: #008000;">print type(a/L)</span>

<span style="color: #008000;">'''</span>

<span style="color: #BA36A5;">words</span> = text.split()
<span style="color: #0000FF;">print</span>(words)
</pre>
</div>

<p>
Let us get the length of each word.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>([<span style="color: #006FE0;">len</span>(word) <span style="color: #0000FF;">for</span> word <span style="color: #0000FF;">in</span> words])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">functional approach with a lambda function</span>
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">map</span>(<span style="color: #0000FF;">lambda</span> word: <span style="color: #006FE0;">len</span>(word), words)))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">functional approach with a builtin function</span>
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">map</span>(<span style="color: #006FE0;">len</span>, words)))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">functional approach with a user-defined function</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">get_length</span>(word):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #006FE0;">len</span>(word)

<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">map</span>(get_length, words)))
</pre>
</div>

<p>
Now let us get all the words that start with the letter "a". This is sometimes called filtering a list. We use a string function <code>startswith</code> to check for upper and lower-case letters. We will use list comprehension with a condition.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>([word <span style="color: #0000FF;">for</span> word <span style="color: #0000FF;">in</span> words <span style="color: #0000FF;">if</span> word.startswith(<span style="color: #008000;">'a'</span>) <span style="color: #0000FF;">or</span> word.startswith(<span style="color: #008000;">'A'</span>)])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">make word lowercase to simplify the conditional statement</span>
<span style="color: #0000FF;">print</span>([word <span style="color: #0000FF;">for</span> word <span style="color: #0000FF;">in</span> words <span style="color: #0000FF;">if</span> word.lower().startswith(<span style="color: #008000;">'a'</span>)])
</pre>
</div>

<p>
A slightly harder example is to find all the words that are actually numbers. We could use a regular expression for that, but we will instead use a function we create. We use a function that tries to cast a word as a float. If this fails, we know the word is not a float, so we return False.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">float_p</span>(word):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #006FE0;">float</span>(word)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">ValueError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>

<span style="color: #0000FF;">print</span>([word <span style="color: #0000FF;">for</span> word <span style="color: #0000FF;">in</span> words <span style="color: #0000FF;">if</span> float_p(word)])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">here is a functional approach</span>
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">filter</span>(float_p, words)))
</pre>
</div>

<p>
Finally, we consider filtering the list to find all words that contain certain symbols, say any character in this string "./=*#". Any of those characters will do, so we search each word for one of them, and return True if it contains it, and False if none are contained.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">punctuation_p</span>(word):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">S</span> = <span style="color: #008000;">'./=*#'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> s <span style="color: #0000FF;">in</span> S:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> s <span style="color: #0000FF;">in</span> word:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>

<span style="color: #0000FF;">print</span>([word <span style="color: #0000FF;">for</span> word <span style="color: #0000FF;">in</span> words <span style="color: #0000FF;">if</span> punctuation_p(word)])
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">filter</span>(punctuation_p, words))
</pre>
</div>

<p>
In this section we examined a few ways to interact with lists using list comprehension and functional programming. These approaches make it possible to work on arbitrary size lists, without needing to know in advance how big the lists are. New lists are automatically generated as results, without the need to preallocate lists, i.e. you do not need to know the size of the output. This can be handy as it avoids needing to write loops in some cases and leads to more compact code.
</p>
</div>
</div>

<div id="outline-container-org6cc054a" class="outline-3">
<h3 id="org6cc054a"><span class="section-number-3">12.7.</span> Making word files in python</h3>
<div class="outline-text-3" id="text-12-7">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/22/create-a-word-document-from-matlab/">Matlab post</a>
</p>

<p>
We can use COM automation in python to create Microsoft Word documents. This only works on windows, and Word must be installed.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> win32com.client <span style="color: #0000FF;">import</span> constants, Dispatch
<span style="color: #0000FF;">import</span> os

<span style="color: #BA36A5;">word</span> = Dispatch(<span style="color: #008000;">'Word.Application'</span>)
word.<span style="color: #BA36A5;">Visible</span> = <span style="color: #D0372D;">True</span>

<span style="color: #BA36A5;">document</span> = word.Documents.Add()
<span style="color: #BA36A5;">selection</span> = word.Selection

selection.TypeText(<span style="color: #008000;">'Hello world. \n'</span>)
selection.TypeText(<span style="color: #008000;">'My name is Professor Kitchin\n'</span>)
selection.TypeParagraph
selection.TypeText(<span style="color: #008000;">'How are you today?\n'</span>)
selection.TypeParagraph
selection.<span style="color: #BA36A5;">Style</span>=<span style="color: #008000;">'Normal'</span>


selection.TypeText(<span style="color: #008000;">'Big Finale\n'</span>)
selection.<span style="color: #BA36A5;">Style</span>=<span style="color: #008000;">'Heading 1'</span>
selection.TypeParagraph

<span style="color: #BA36A5;">H1</span> = document.Styles.Item(<span style="color: #008000;">'Heading 1'</span>)
H1.Font.<span style="color: #BA36A5;">Name</span> = <span style="color: #008000;">'Garamond'</span>
H1.Font.<span style="color: #BA36A5;">Size</span> = 20
H1.Font.<span style="color: #BA36A5;">Bold</span> = 1
H1.Font.TextColor.<span style="color: #BA36A5;">RGB</span>=60000 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">some ugly color green</span>

selection.TypeParagraph
selection.TypeText(<span style="color: #008000;">'That is all for today!'</span>)


document.SaveAs2(os.getcwd() + <span style="color: #008000;">'/test.docx'</span>)
word.Quit()
</pre>
</div>

<p>
msx:./test.docx
</p>

<p>
That is it! I would not call this extra convenient, but if you have a need to automate the production of Word documents from a program, this is an approach that you can use. You may find <a href="http://msdn.microsoft.com/en-us/library/kw65a0we%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/kw65a0we%28v=vs.80%29.aspx</a> a helpful link for documentation of what you can do.
</p>


<p>
I was going to do this by docx, which does not require windows, but it appears broken. It is missing a template directory, and it does not match the github code. docx is not actively maintained anymore either.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> docx <span style="color: #0000FF;">import</span> *

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Make a new document tree - this is the main part of a Word document</span>
<span style="color: #BA36A5;">document</span> = Docx()

document.append(paragraph(<span style="color: #008000;">'Hello world. '</span>
<span style="color: #008000;">'My name is Professor Kitchin'</span>
<span style="color: #008000;">'How are you today?'</span>))

document.append(heading(<span style="color: #008000;">"Big Finale"</span>, 1))

document.append(paragraph(<span style="color: #008000;">'That is all for today.'</span>))

document.save(<span style="color: #008000;">'test.doc'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org2ced41c" class="outline-3">
<h3 id="org2ced41c"><span class="section-number-3">12.8.</span> Interacting with Excel in python</h3>
<div class="outline-text-3" id="text-12-8">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/07/manipulating-excel-with-matlab/">Matlab post</a>
</p>

<p>
There will be times it is convenient to either read data from Excel, or write data to Excel. This is possible in python (<a href="http://www.python-excel.org/">http://www.python-excel.org/</a>). You may also look at (<a href="https://bitbucket.org/ericgazoni/openpyxl/wiki/Home">https://bitbucket.org/ericgazoni/openpyxl/wiki/Home</a>).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> xlrd

<span style="color: #BA36A5;">wb</span> = xlrd.open_workbook(<span style="color: #008000;">'data/example.xlsx'</span>)
<span style="color: #BA36A5;">sh1</span> = wb.sheet_by_name(u<span style="color: #008000;">'Sheet1'</span>)

<span style="color: #0000FF;">print</span>(sh1.col_values(0))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">column 0</span>
<span style="color: #0000FF;">print</span>(sh1.col_values(1))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">column 1</span>

<span style="color: #BA36A5;">sh2</span> = wb.sheet_by_name(u<span style="color: #008000;">'Sheet2'</span>)

<span style="color: #BA36A5;">x</span> = sh2.col_values(0)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">column 0</span>
<span style="color: #BA36A5;">y</span> = sh2.col_values(1)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">column 1</span>

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(x, y)
plt.savefig(<span style="color: #008000;">'images/excel-1.png'</span>)
</pre>
</div>


<div id="orgd595583" class="figure">
<p><img src="pycse-chapters/images/excel-1.png" alt="excel-1.png" />
</p>
</div>
</div>

<div id="outline-container-org903a65a" class="outline-4">
<h4 id="org903a65a"><span class="section-number-4">12.8.1.</span> Writing Excel workbooks</h4>
<div class="outline-text-4" id="text-12-8-1">
<p>
Writing data to Excel sheets is pretty easy. Note, however, that this overwrites the worksheet if it already exists.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> xlwt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2)
<span style="color: #BA36A5;">y</span> = np.sqrt(x)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">save the data</span>
<span style="color: #BA36A5;">book</span> = xlwt.Workbook()

<span style="color: #BA36A5;">sheet1</span> = book.add_sheet(<span style="color: #008000;">'Sheet 1'</span>)

<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(x)):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sheet1.write(i, 0, x[i])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sheet1.write(i, 1, y[i])

book.save(<span style="color: #008000;">'data/example2.xls'</span>) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">maybe can only write .xls format</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4d65955" class="outline-4">
<h4 id="org4d65955"><span class="section-number-4">12.8.2.</span> Updating an existing Excel workbook</h4>
<div class="outline-text-4" id="text-12-8-2">
<p>
It turns out you have to make a copy of an existing workbook, modify the copy and then write out the results using the <code>xlwt</code> module.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> xlrd <span style="color: #0000FF;">import</span> open_workbook

<span style="color: #0000FF;">from</span> xlutils.copy <span style="color: #0000FF;">import</span> copy

<span style="color: #BA36A5;">rb</span> = open_workbook(<span style="color: #008000;">'data/example2.xls'</span>,formatting_info=<span style="color: #D0372D;">True</span>)
rs = rb.sheet_by_index(0)

wb = copy(rb)

ws = wb.add_sheet(<span style="color: #008000;">'Sheet 2'</span>)
ws.write(0, 0, <span style="color: #008000;">"Appended"</span>)

wb.save(<span style="color: #008000;">'data/example2.xls'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc55aa17" class="outline-4">
<h4 id="orgc55aa17"><span class="section-number-4">12.8.3.</span> Summary</h4>
<div class="outline-text-4" id="text-12-8-3">
<p>
Matlab has better support for interacting with Excel than python does right now. You could get better Excel interaction via COM, but that is Windows specific, and requires you to have Excel installed on your computer.
If you only need to read or write data, then xlrd/xlwt or the openpyxl modules will server you well.
</p>
</div>
</div>
</div>
<div id="outline-container-org1fc33a5" class="outline-3">
<h3 id="org1fc33a5"><span class="section-number-3">12.9.</span> Using Excel in Python</h3>
<div class="outline-text-3" id="text-12-9">
<p>
<a href="Excel">Excel</a>, <a href="COM">COM</a>
There may be a time where you have an Excel sheet that already has a model built into it, and you normally change cells in the sheet, and it solves the model. It can be tedious to do that a lot, and we can use python to do that. Python has a COM interface that can communicate with Excel (and many other windows programs. see <a href="http://my.safaribooksonline.com/1565926218">http://my.safaribooksonline.com/1565926218</a> for Python Programming on Win32). In this example, we will use a very simple Excel sheet that calculates the volume of a CSTR that runs a zeroth order reaction (\(-r_A = k\)) for a particular conversion. You set the conversion in the cell B1, and the volume is automatically computed in cell B6. We simply need to set the value of B1, and get the value of B6 for a range of different conversion values. In this example, the volume is returned in Liters.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> win32com.client <span style="color: #0000FF;">as</span> win32
<span style="color: #BA36A5;">excel</span> = win32.Dispatch(<span style="color: #008000;">'Excel.Application'</span>)

<span style="color: #BA36A5;">wb</span> = excel.Workbooks.Open(<span style="color: #008000;">'c:/Users/jkitchin/Dropbox/pycse/data/cstr-zeroth-order.xlsx'</span>)
<span style="color: #BA36A5;">ws</span> = wb.Worksheets(<span style="color: #008000;">'Sheet1'</span>)

<span style="color: #BA36A5;">X</span> = [0.1, 0.5, 0.9]
<span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">X</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ws.Range(<span style="color: #008000;">"B1"</span>).Value = x
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">V</span> = ws.Range(<span style="color: #008000;">"B6"</span>).Value
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span> <span style="color: #008000;">'at X = {0} V = {1:1.2f} L'</span>.<span style="color: #006FE0;">format</span>(x, V)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we tell Excel the workbook is saved, even though it is not, so it</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">will quit without asking us to save.</span>
excel.ActiveWorkbook.<span style="color: #BA36A5;">Saved</span> = <span style="color: #D0372D;">True</span>
excel.Application.Quit()
</pre>
</div>

<p>
This was a simple example (one that did not actually need Excel at all) that illustrates the feasibility of communicating with Excel via a COM interface.
</p>

<p>
Some links I have found that help figure out how to do this are:
</p>
<ul class="org-ul">
<li><a href="http://www.numbergrinder.com/2008/11/pulling-data-from-excel-using-python-com/">http://www.numbergrinder.com/2008/11/pulling-data-from-excel-using-python-com/</a></li>
<li><a href="http://www.numbergrinder.com/2008/11/closing-excel-using-python/">http://www.numbergrinder.com/2008/11/closing-excel-using-python/</a></li>
<li><a href="http://www.dzone.com/snippets/script-excel-python">http://www.dzone.com/snippets/script-excel-python</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgda5a03d" class="outline-3">
<h3 id="orgda5a03d"><span class="section-number-3">12.10.</span> Running Aspen via Python</h3>
<div class="outline-text-3" id="text-12-10">
<p>
Aspen is a process modeling tool that simulates industrial processes. It has a GUI for setting up the flowsheet, defining all the stream inputs and outputs, and for running the simulation. For single calculations it is pretty convenient. For many calculations, all the pointing and clicking to change properties can be tedious, and difficult to reproduce. Here we show how to use Python to automate Aspen using the COM interface.
</p>

<p>
We have an Aspen flowsheet setup for a flash operation. The feed consists of 91.095 mol% water and 8.905 mol% ethanol at 100 degF and 50 psia. 48.7488 lbmol/hr of the mixture is fed to the flash tank which is at 150 degF and 20 psia. We want to know the composition of the VAPOR and LIQUID streams. The simulation has been run once.
</p>


<div id="org4faa572" class="figure">
<p><img src="pycse-chapters/images/flash-flowsheet.png" alt="flash-flowsheet.png" />
</p>
</div>

<p>
This is an example that just illustrates it is possible to access data from a simulation that has been run. You have to know quite a bit about the Aspen flowsheet before writing this code. Particularly, you need to open the Variable Explorer to find the "path" to the variables that you want, and to know what the units are of those variables are.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> os
<span style="color: #0000FF;">import</span> win32com.client <span style="color: #0000FF;">as</span> win32
<span style="color: #BA36A5;">aspen</span> = win32.Dispatch(<span style="color: #008000;">'Apwn.Document'</span>)

aspen.InitFromArchive2(os.path.abspath(<span style="color: #008000;">'data\Flash_Example.bkp'</span>))

<span style="color: #8D8D84; background-color: #E6ECFF;">## </span><span style="color: #8D8D84; background-color: #E6ECFF; font-style: italic;">Input variables</span>
<span style="color: #BA36A5;">feed_temp</span> = aspen.Tree.FindNode(<span style="color: #008000;">'\Data\Streams\FEED\Input\TEMP\MIXED'</span>).Value
<span style="color: #0000FF;">print</span> <span style="color: #008000;">'Feed temperature was {0} degF'</span>.<span style="color: #006FE0;">format</span>(feed_temp)

<span style="color: #BA36A5;">ftemp</span> = aspen.Tree.FindNode(<span style="color: #008000;">'\Data\Blocks\FLASH\Input\TEMP'</span>).Value
<span style="color: #0000FF;">print</span> <span style="color: #008000;">'Flash temperature = {0}'</span>.<span style="color: #006FE0;">format</span>(ftemp)

<span style="color: #8D8D84; background-color: #E6ECFF;">## </span><span style="color: #8D8D84; background-color: #E6ECFF; font-style: italic;">Output variables</span>
<span style="color: #BA36A5;">eL_out</span> = aspen.Tree.FindNode(<span style="color: #008000;">"\Data\Streams\LIQUID\Output\MOLEFLOW\MIXED\ETHANOL"</span>).Value
<span style="color: #BA36A5;">wL_out</span> = aspen.Tree.FindNode(<span style="color: #008000;">"\Data\Streams\LIQUID\Output\MOLEFLOW\MIXED\WATER"</span>).Value

<span style="color: #BA36A5;">eV_out</span> = aspen.Tree.FindNode(<span style="color: #008000;">"\Data\Streams\VAPOR\Output\MOLEFLOW\MIXED\ETHANOL"</span>).Value
<span style="color: #BA36A5;">wV_out</span> = aspen.Tree.FindNode(<span style="color: #008000;">"\Data\Streams\VAPOR\Output\MOLEFLOW\MIXED\WATER"</span>).Value

<span style="color: #BA36A5;">tot</span> = aspen.Tree.FindNode(<span style="color: #008000;">"\Data\Streams\FEED\Input\TOTFLOW\MIXED"</span>).Value

<span style="color: #0000FF;">print</span> <span style="color: #008000;">'Ethanol vapor mol flow: {0} lbmol/hr'</span>.<span style="color: #006FE0;">format</span>(eV_out)
<span style="color: #0000FF;">print</span> <span style="color: #008000;">'Ethanol liquid mol flow: {0} lbmol/hr'</span>.<span style="color: #006FE0;">format</span>(eL_out)

<span style="color: #0000FF;">print</span> <span style="color: #008000;">'Water vapor mol flow: {0} lbmol/hr'</span>.<span style="color: #006FE0;">format</span>(wV_out)
<span style="color: #0000FF;">print</span> <span style="color: #008000;">'Water liquid mol flow: {0} lbmol/hr'</span>.<span style="color: #006FE0;">format</span>(wL_out)

<span style="color: #0000FF;">print</span> <span style="color: #008000;">'Total = {0}. Total in = {1}'</span>.<span style="color: #006FE0;">format</span>(eV_out + eL_out + wV_out + wL_out,
                                           tot)

aspen.Close()
</pre>
</div>

<p>
It is nice that we can read data from a simulation, but it would be helpful if we could change variable values and to rerun the simulations. That is possible. We simply set the value of the variable, and tell Aspen to rerun. Here, we will change the temperature of the Flash tank and plot the composition of the outlet streams as a function of that temperature.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> os
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> win32com.client <span style="color: #0000FF;">as</span> win32

<span style="color: #BA36A5;">aspen</span> = win32.Dispatch(<span style="color: #008000;">'Apwn.Document'</span>)
aspen.InitFromArchive2(os.path.abspath(<span style="color: #008000;">'data\Flash_Example.bkp'</span>))

<span style="color: #BA36A5;">T</span> = np.linspace(150, 200, 10)

<span style="color: #BA36A5;">x_ethanol</span>, <span style="color: #BA36A5;">y_ethanol</span> = [], []

<span style="color: #0000FF;">for</span> temperature <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">T</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   aspen.Tree.FindNode(<span style="color: #008000;">'\Data\Blocks\FLASH\Input\TEMP'</span>).Value = temperature
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   aspen.Engine.Run2()

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x_ethanol.append(aspen.Tree.FindNode(<span style="color: #008000;">'\Data\Streams\LIQUID\Output\MOLEFRAC\MIXED\ETHANOL'</span>).Value)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   y_ethanol.append(aspen.Tree.FindNode(<span style="color: #008000;">'\Data\Streams\VAPOR\Output\MOLEFRAC\MIXED\ETHANOL'</span>).Value)

plt.plot(T, y_ethanol, T, x_ethanol)
plt.legend([<span style="color: #008000;">'vapor'</span>, <span style="color: #008000;">'liquid'</span>])
plt.xlabel(<span style="color: #008000;">'Flash Temperature (degF)'</span>)
plt.ylabel(<span style="color: #008000;">'Ethanol mole fraction'</span>)
plt.savefig(<span style="color: #008000;">'images/aspen-water-ethanol-flash.png'</span>)
aspen.Close()
</pre>
</div>


<div id="org2451374" class="figure">
<p><img src="pycse-chapters/images/aspen-water-ethanol-flash.png" alt="aspen-water-ethanol-flash.png" />
</p>
</div>


<p>
It takes about 30 seconds to run the previous example. Unfortunately, the way it is written, if you want to change anything, you have to run all of the calculations over again. How to avoid that is moderately tricky, and will be the subject of another example.
</p>

<p>
In summary, it seems possible to do a lot with Aspen automation via python. This can also be done with Matlab, Excel, and other programming languages where COM automation is possible. The COM interface is not especially well documented, and you have to do a lot of digging to figure out some things. It is not clear how committed Aspen is to maintaining or improving the COM interface (<a href="http://www.chejunkie.com/aspen-plus/aspen-plus-activex-automation-server/">http://www.chejunkie.com/aspen-plus/aspen-plus-activex-automation-server/</a>). Hopefully they can keep it alive for power users who do not want to program in Excel!
</p>
</div>
</div>
<div id="outline-container-orgea1727d" class="outline-3">
<h3 id="orgea1727d"><span class="section-number-3">12.11.</span> Using an external solver with Aspen</h3>
<div class="outline-text-3" id="text-12-11">
<p>
One reason to interact with Aspen via python is to use external solvers to drive the simulations. Aspen has some built-in solvers, but it does not have everything. You may also want to integrate additional calculations, e.g. capital costs, water usage, etc&#x2026; and integrate those results into a report.
</p>

<p>
Here is a simple example where we use fsolve to find the temperature of the flash tank that will give a vapor phase mole fraction of ethanol of 0.8. It is a simple example, but it illustrates the possibility.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> os
<span style="color: #0000FF;">import</span> win32com.client <span style="color: #0000FF;">as</span> win32
<span style="color: #BA36A5;">aspen</span> = win32.Dispatch(<span style="color: #008000;">'Apwn.Document'</span>)

aspen.InitFromArchive2(os.path.abspath(<span style="color: #008000;">'data\Flash_Example.bkp'</span>))

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(flashT):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">flashT</span> = <span style="color: #006FE0;">float</span>(flashT) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">COM objects do not understand numpy types</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   aspen.Tree.FindNode(<span style="color: #008000;">'\Data\Blocks\FLASH\Input\TEMP'</span>).<span style="color: #BA36A5;">Value</span> = flashT
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   aspen.Engine.Run2()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = aspen.Tree.FindNode(<span style="color: #008000;">'\Data\Streams\VAPOR\Output\MOLEFRAC\MIXED\ETHANOL'</span>).Value
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y - 0.8

<span style="color: #BA36A5;">sol</span>, = fsolve(func, 150.0)
<span style="color: #0000FF;">print</span> <span style="color: #008000;">'A flash temperature of {0:1.2f} degF will have y_ethanol = 0.8'</span>.<span style="color: #006FE0;">format</span>(sol)
</pre>
</div>

<p>
One unexpected detail was that the Aspen COM objects cannot be assigned numpy number types, so it was necessary to recast the argument as a float. Otherwise, this worked about as expected for an fsolve problem.
</p>
</div>
</div>

<div id="outline-container-org7aad7d6" class="outline-3">
<h3 id="org7aad7d6"><span class="section-number-3">12.12.</span> Redirecting the print function</h3>
<div class="outline-text-3" id="text-12-12">
<p>
Ordinarily a print statement prints to stdout, or your terminal/screen. You can redirect this so that printing is done to a file, for example. This might be helpful if you use print statements for debugging, and later want to save what is printed to a file. Here we make a simple function that prints some things.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">debug</span>():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'step 1'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(3 + 4)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'finished'</span>)

debug()
</pre>
</div>

<p>
Now, let us redirect the printed lines to a file. We create a file object, and set sys.stdout equal to that file object.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> sys
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'__stdout__ before = {0}'</span>.<span style="color: #006FE0;">format</span>(sys.__stdout__), <span style="color: #006FE0;">file</span>=sys.stdout)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'stdout before = {0}'</span>.<span style="color: #006FE0;">format</span>(sys.stdout), <span style="color: #006FE0;">file</span>=sys.stdout)

f = <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'data/debug.txt'</span>, <span style="color: #008000;">'w'</span>)
sys.stdout = f

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">note that sys.__stdout__ does not change, but stdout does.</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'__stdout__ after = {0}'</span>.<span style="color: #006FE0;">format</span>(sys.__stdout__), <span style="color: #006FE0;">file</span>=sys.stdout)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'stdout after = {0}'</span>.<span style="color: #006FE0;">format</span>(sys.stdout), <span style="color: #006FE0;">file</span>=sys.stdout)

debug()

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reset stdout back to console</span>
sys.stdout = sys.__stdout__

<span style="color: #0000FF;">print</span>(f)
f.close() <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">try to make it a habit to close files</span>
<span style="color: #0000FF;">print</span>(f)
</pre>
</div>

<p>
Note it can be important to close files. If you are looping through large numbers of files, you will eventually run out of file handles, causing an error. We can use a context manager to automatically close the file like this
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> sys

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">use the open context manager to automatically close the file</span>
<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'data/debug.txt'</span>, <span style="color: #008000;">'w'</span>) <span style="color: #0000FF;">as</span> <span style="color: #BA36A5;">f</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sys.stdout = f
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   debug()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(f, <span style="color: #006FE0;">file</span>=sys.__stdout__)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reset stdout</span>
sys.stdout = sys.__stdout__
<span style="color: #0000FF;">print</span>(f)
</pre>
</div>

<p>
See, the file is closed for us! We can see the contents of our file like this.
</p>
<div class="org-src-container">
<pre class="src src-sh">cat data/debug.txt
</pre>
</div>

<p>
The approaches above are not fault safe. Suppose our debug function raised an exception. Then, it could be possible the line to reset the stdout would not be executed. We can solve this with try/finally code.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> sys

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'before: '</span>, sys.stdout)
<span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'data/debug-2.txt'</span>, <span style="color: #008000;">'w'</span>) <span style="color: #0000FF;">as</span> <span style="color: #BA36A5;">f</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sys.stdout = f
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print to the original stdout</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'during: '</span>, sys.stdout, <span style="color: #006FE0;">file</span>=sys.__stdout__)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   debug()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">raise</span> <span style="color: #6434A3;">Exception</span>(<span style="color: #008000;">'something bad happened'</span>)
<span style="color: #0000FF;">finally</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reset stdout</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sys.stdout = sys.__stdout__

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'after: '</span>, sys.stdout)
<span style="color: #0000FF;">print</span>(f) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">verify it is closed</span>
<span style="color: #0000FF;">print</span>(sys.stdout) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">verify this is reset</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">cat data/debug-2.txt
</pre>
</div>

<p>
This is the kind of situation where a context manager is handy. Context managers are typically a class that executes some code when you "enter" the context, and then execute some code when you "exit" the context. Here we want to change sys.stdout to a new value inside our context, and change it back when we exit the context. We will store the value of sys.stdout going in, and restore it on the way out.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> sys

<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">redirect</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, f=sys.stdout):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"redirect print statement to f. f must be a file-like object"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.f = f
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.stdout = sys.stdout
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'init stdout: '</span>, sys.stdout, <span style="color: #006FE0;">file</span>=sys.__stdout__)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__enter__</span>(<span style="color: #0000FF;">self</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sys.stdout = <span style="color: #0000FF;">self</span>.f
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'stdout in context-manager: '</span>,sys.stdout, f=sys.__stdout__)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__exit__</span>(<span style="color: #0000FF;">self</span>, *args):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sys.stdout = <span style="color: #0000FF;">self</span>.stdout
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'__stdout__ at exit = '</span>,sys.__stdout__)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">regular printing</span>
<span style="color: #0000FF;">with</span> redirect():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   debug()

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">write to a file</span>
<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'data/debug-3.txt'</span>, <span style="color: #008000;">'w'</span>) <span style="color: #0000FF;">as</span> f:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">with</span> redirect(f):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   debug()

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mixed regular and</span>
<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'data/debug-4.txt'</span>, <span style="color: #008000;">'w'</span>) <span style="color: #0000FF;">as</span> f:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">with</span> redirect(f):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'testing redirect'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">with</span> redirect():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'temporary console printing'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   debug()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Now outside the inner context. This should go to data/debug-4.txt'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   debug()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">raise</span> <span style="color: #6434A3;">Exception</span>(<span style="color: #008000;">'something else bad happened'</span>)

<span style="color: #0000FF;">print</span>(sys.stdout)
</pre>
</div>

<p>
Here are the contents of the debug file.
</p>
<div class="org-src-container">
<pre class="src src-sh">cat data/debug-3.txt
</pre>
</div>

<p>
The contents of the other debug file have some additional lines, because we printed some things while in the redirect context.
</p>
<div class="org-src-container">
<pre class="src src-sh">cat data/debug-4.txt
</pre>
</div>

<p>
See <a href="http://www.python.org/dev/peps/pep-0343/">http://www.python.org/dev/peps/pep-0343/</a> (number 5) for another example of redirecting using a function decorator. I think it is harder to understand, because it uses a generator.
</p>

<p>
There were a couple of points in this section:
</p>

<ol class="org-ol">
<li>You can control where things are printed in your programs by modifying the value of sys.stdout</li>
<li>You can use try/except/finally blocks to make sure code gets executed in the event an exception is raised</li>
<li>You can use context managers to make sure files get closed, and code gets executed if exceptions are raised.</li>
</ol>
</div>
</div>

<div id="outline-container-org844dd9e" class="outline-3">
<h3 id="org844dd9e"><span class="section-number-3">12.13.</span> Getting a dictionary of counts</h3>
<div class="outline-text-3" id="text-12-13">
<p>
I frequently want to take a list and get a dictionary of keys that have the count of each element in the list. Here is how I have typically done this countless times in the past.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">L</span> = [<span style="color: #008000;">'a'</span>, <span style="color: #008000;">'a'</span>, <span style="color: #008000;">'b'</span>,<span style="color: #008000;">'d'</span>, <span style="color: #008000;">'e'</span>, <span style="color: #008000;">'b'</span>, <span style="color: #008000;">'e'</span>, <span style="color: #008000;">'a'</span>]

<span style="color: #BA36A5;">d</span> = {}
<span style="color: #0000FF;">for</span> el <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">L</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> el <span style="color: #0000FF;">in</span> d:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   d[<span style="color: #BA36A5;">el</span>] += 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   d[<span style="color: #BA36A5;">el</span>] = 1

<span style="color: #0000FF;">print</span>(d)
</pre>
</div>

<p>
That seems like too much code, and that there must be a list comprehension approach combined with a dictionary constructor.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">L</span> = [<span style="color: #008000;">'a'</span>, <span style="color: #008000;">'a'</span>, <span style="color: #008000;">'b'</span>,<span style="color: #008000;">'d'</span>, <span style="color: #008000;">'e'</span>, <span style="color: #008000;">'b'</span>, <span style="color: #008000;">'e'</span>, <span style="color: #008000;">'a'</span>]

<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">dict</span>((el,L.count(el)) <span style="color: #0000FF;">for</span> el <span style="color: #0000FF;">in</span> L))
</pre>
</div>

<p>
Wow, that is a lot simpler! I suppose for large lists this might be slow, since count must look through the list for each element, whereas the longer code looks at each element once, and does one conditional analysis.
</p>

<p>
Here is another example of much shorter and cleaner code.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> collections <span style="color: #0000FF;">import</span> Counter
<span style="color: #BA36A5;">L</span> = [<span style="color: #008000;">'a'</span>, <span style="color: #008000;">'a'</span>, <span style="color: #008000;">'b'</span>,<span style="color: #008000;">'d'</span>, <span style="color: #008000;">'e'</span>, <span style="color: #008000;">'b'</span>, <span style="color: #008000;">'e'</span>, <span style="color: #008000;">'a'</span>]
<span style="color: #0000FF;">print</span>(Counter(L))
<span style="color: #0000FF;">print</span>(Counter(L)[<span style="color: #008000;">'a'</span>])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgad16976" class="outline-3">
<h3 id="orgad16976"><span class="section-number-3">12.14.</span> About your python</h3>
<div class="outline-text-3" id="text-12-14">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> sys

<span style="color: #0000FF;">print</span>(sys.version)

<span style="color: #0000FF;">print</span>(sys.executable)

<span style="color: #0000FF;">print</span>(sys.platform)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">where the platform independent Python files are installed</span>
<span style="color: #0000FF;">print</span>(sys.prefix)
</pre>
</div>

<p>
The <code>platform</code> module provides similar, complementary information.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> platform

<span style="color: #0000FF;">print</span>(platform.uname())
<span style="color: #0000FF;">print</span>(platform.system())
<span style="color: #0000FF;">print</span>(platform.architecture())
<span style="color: #0000FF;">print</span>(platform.machine())
<span style="color: #0000FF;">print</span>(platform.node())
<span style="color: #0000FF;">print</span>(platform.platform())
<span style="color: #0000FF;">print</span>(platform.processor())
<span style="color: #0000FF;">print</span>(platform.python_build())
<span style="color: #0000FF;">print</span>(platform.python_version())
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd440f2b" class="outline-3">
<h3 id="orgd440f2b"><span class="section-number-3">12.15.</span> Automatic, temporary directory changing</h3>
<div class="outline-text-3" id="text-12-15">
<p>
If you are doing some analysis that requires you to change directories, e.g. to read a file, and then change back to another directory to read another file, you have probably run into problems if there is an error somewhere. You would like to make sure that the code changes back to the original directory after each error. We will look at a few ways to accomplish that here.
</p>

<p>
The try/except/finally method is the traditional way to handle exceptions, and make sure that some code "finally" runs. Let us look at two examples here. In the first example, we try to change into a directory that does not exist.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> os, sys

<span style="color: #BA36A5;">CWD</span> = os.getcwd() <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">store initial position</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'initially inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
<span style="color: #BA36A5;">TEMPDIR</span> = <span style="color: #008000;">'data/run1'</span> <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this does not exist</span>

<span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   os.chdir(TEMPDIR)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
<span style="color: #0000FF;">except</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Exception caught: '</span>,sys.exc_info()[0])
<span style="color: #0000FF;">finally</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Running final code'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   os.chdir(CWD)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'finally inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
</pre>
</div>


<p>
Now, let us look at an example where the directory does exist. We will change into the directory, run some code, and then raise an Exception.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> os, sys

<span style="color: #BA36A5;">CWD</span> = os.getcwd() <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">store initial position</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'initially inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
<span style="color: #BA36A5;">TEMPDIR</span> = <span style="color: #008000;">'data'</span>

<span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   os.chdir(TEMPDIR)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(os.listdir(<span style="color: #008000;">'.'</span>))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">raise</span> <span style="color: #6434A3;">Exception</span>(<span style="color: #008000;">'boom'</span>)
<span style="color: #0000FF;">except</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Exception caught: '</span>,sys.exc_info()[0])
<span style="color: #0000FF;">finally</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Running final code'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   os.chdir(CWD)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'finally inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
</pre>
</div>

<p>
You can see that we changed into the directory, ran some code, and then caught an exception. Afterwards, we changed back to our original directory. This code works fine, but it is somewhat verbose, and tedious to write over and over. We can get a cleaner syntax with a context manager. The context manager uses the <code>with</code> keyword in python. In a context manager some code is executed on entering the "context", and code is run on exiting the context. We can use that to automatically change directory, and when done, change back to the original directory. We use the <code>contextlib.contextmanager</code> decorator on a function. With a function, the code up to a <code>yield</code> statement is run on entering the context, and the code after the yield statement is run on exiting. We wrap the yield statement in try/except/finally block to make sure our final code gets run.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> contextlib
<span style="color: #0000FF;">import</span> os, sys

<span style="color: #6434A3;">@contextlib.contextmanager</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">cd</span>(path):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'initially inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">CWD</span> = os.getcwd()

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   os.chdir(path)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">yield</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Exception caught: '</span>,sys.exc_info()[0])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">finally</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'finally inside {0}'</span>.<span style="color: #006FE0;">format</span>(os.getcwd()))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   os.chdir(CWD)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Now we use the context manager</span>
<span style="color: #0000FF;">with</span> cd(<span style="color: #008000;">'data'</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(os.listdir(<span style="color: #008000;">'.'</span>))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">raise</span> <span style="color: #6434A3;">Exception</span>(<span style="color: #008000;">'boom'</span>)

<span style="color: #0000FF;">print</span>
<span style="color: #0000FF;">with</span> cd(<span style="color: #008000;">'data/run2'</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(os.listdir(<span style="color: #008000;">'.'</span>))
</pre>
</div>

<p>
One case that is not handled well with this code is if the directory you want to change into does not exist. In that case an exception is raised on entering the context when you try change into a directory that does not exist. An alternative class based context manager can be found <a href="http://code.activestate.com/recipes/576620-changedirectory-context-manager/">here</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-org9cda30c" class="outline-2">
<h2 id="org9cda30c"><span class="section-number-2">13.</span> Miscellaneous</h2>
<div class="outline-text-2" id="text-13">
</div>
<div id="outline-container-org066ac8c" class="outline-3">
<h3 id="org066ac8c"><span class="section-number-3">13.1.</span> Mail merge with python</h3>
<div class="outline-text-3" id="text-13-1">
<p>
Suppose you are organizing some event, and you have a mailing list of email addresses and people you need to send a mail to telling them what room they will be in. You would like to send a personalized email to each person, and you do not want to type each one by hand. Python can automate this for you. All you need is the mailing list in some kind of structured format, and then you can go through it line by line to create and send emails.
</p>

<p>
We will use an org-table to store the data in.
</p>

<table id="orge70f443" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">First name</th>
<th scope="col" class="org-left">Last name</th>
<th scope="col" class="org-left">email address</th>
<th scope="col" class="org-right">Room number</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Jane</td>
<td class="org-left">Doe</td>
<td class="org-left">jane-doe@gmail.com</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">John</td>
<td class="org-left">Doe</td>
<td class="org-left">john-doe@gmail.com</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Jimmy</td>
<td class="org-left">John</td>
<td class="org-left">jimmy-john@gmail.com</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>

<p>
We pass that table into an org-mode source block as a variable called data, which will be a list of lists, one for each row of the table. You could alternatively read these from an excel spreadsheet, a csv file, or some kind of python data structure.
</p>

<p>
We do not actually send the emails in this example. To do that you need to have access to a mail server, which could be on your own machine, or it could be a relay server you have access to.
</p>

<p>
We create a string that is a template with some fields to be substituted, e.g. the firstname and room number in this case. Then we loop through each row of the table, and format the template with those values, and create an email message to the person. First we print each message to check that they are correct.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> smtplib
<span style="color: #0000FF;">from</span> email.mime.multipart <span style="color: #0000FF;">import</span> MIMEMultipart
<span style="color: #0000FF;">from</span> email.mime.text <span style="color: #0000FF;">import</span> MIMEText
<span style="color: #0000FF;">from</span> email.utils <span style="color: #0000FF;">import</span>  formatdate

<span style="color: #BA36A5;">template</span> = <span style="color: #008000;">'''</span>
<span style="color: #008000;">Dear {firstname:s},</span>

<span style="color: #008000;">I am pleased to inform you that your talk will be in room {roomnumber:d}.</span>

<span style="color: #008000;">Sincerely,</span>
<span style="color: #008000;">John</span>
<span style="color: #008000;">'''</span>

<span style="color: #0000FF;">for</span> firstname, lastname, emailaddress, roomnumber <span style="color: #0000FF;">in</span> data:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   msg = MIMEMultipart()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">msg</span>[<span style="color: #008000;">'From'</span>] = <span style="color: #008000;">"youremail@gmail.com"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">msg</span>[<span style="color: #008000;">'To'</span>] = emailaddress
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">msg</span>[<span style="color: #008000;">'Date'</span>] = formatdate(localtime=<span style="color: #D0372D;">True</span>)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   msgtext = template.<span style="color: #006FE0;">format</span>(**<span style="color: #006FE0;">locals</span>())
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(msgtext)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   msg.attach(MIMEText(msgtext))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">## </span><span style="color: #8D8D84; font-style: italic;">Uncomment these lines and fix</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">server = smtplib.SMTP('your.relay.server.edu')</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">server.sendmail('your_email@gmail.com', # from</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#                </span><span style="color: #8D8D84; font-style: italic;">emailaddress,</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#                </span><span style="color: #8D8D84; font-style: italic;">msg.as_string())</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">server.quit()</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(msg.as_string())
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'------------------------------------------------------------------'</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org554bcef" class="outline-2">
<h2 id="org554bcef"><span class="section-number-2">14.</span> Worked examples</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-orgbde160a" class="outline-3">
<h3 id="orgbde160a"><span class="section-number-3">14.1.</span> Peak finding in Raman spectroscopy</h3>
<div class="outline-text-3" id="text-14-1">
<p>
Raman spectroscopy is a vibrational spectroscopy. The data typically comes as intensity vs. wavenumber, and it is discrete. Sometimes it is necessary to identify the precise location of a peak. In this post, we will use spline smoothing to construct an interpolating function of the data, and then use fminbnd to identify peak positions.
</p>

<p>
This example was originally worked out in Matlab at <a href="http://matlab.cheme.cmu.edu/2012/08/27/peak-finding-in-raman-spectroscopy/">http://matlab.cheme.cmu.edu/2012/08/27/peak-finding-in-raman-spectroscopy/</a>
</p>

<p>
numpy:loadtxt
</p>

<p>
Let us take a look at the raw data.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">w</span>, <span style="color: #BA36A5;">i</span> = np.loadtxt(<span style="color: #008000;">'data/raman.txt'</span>, usecols=(0, 1), unpack=<span style="color: #D0372D;">True</span>)

plt.plot(w, i)
plt.xlabel(<span style="color: #008000;">'Raman shift (cm$^{-1}$)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (counts)'</span>)
plt.savefig(<span style="color: #008000;">'images/raman-1.png'</span>)
</pre>
</div>


<div id="org943c2cc" class="figure">
<p><img src="pycse-chapters/images/raman-1.png" alt="raman-1.png" />
</p>
</div>

<p>
The next thing to do is narrow our focus to the region we are interested in between 1340 cm^{-1} and 1360 cm^{-1}.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">ind</span> = (w &gt; 1340) &amp; (w &lt; 1360)
<span style="color: #BA36A5;">w1</span> = w[ind]
<span style="color: #BA36A5;">i1</span> = i[ind]

plt.figure()
plt.plot(w1, i1, <span style="color: #008000;">'b. '</span>)
plt.xlabel(<span style="color: #008000;">'Raman shift (cm$^{-1}$)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (counts)'</span>)
plt.savefig(<span style="color: #008000;">'images/raman-2.png'</span>)
</pre>
</div>


<div id="org57a9a04" class="figure">
<p><img src="pycse-chapters/images/raman-2.png" alt="raman-2.png" />
</p>
</div>

<p>
Next we consider a scipy:UnivariateSpline. This function "smooths" the data.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> UnivariateSpline

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">s is a "smoothing" factor</span>
<span style="color: #BA36A5;">sp</span> = UnivariateSpline(w1, i1, k=4, s=2000)

plt.plot(w1, i1, <span style="color: #008000;">'b. '</span>)
plt.plot(w1, sp(w1), <span style="color: #008000;">'r-'</span>)
plt.xlabel(<span style="color: #008000;">'Raman shift (cm$^{-1}$)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (counts)'</span>)
plt.savefig(<span style="color: #008000;">'images/raman-3.png'</span>)
</pre>
</div>


<div id="orgea5a556" class="figure">
<p><img src="pycse-chapters/images/raman-3.png" alt="raman-3.png" />
</p>
</div>

<p>
Note that the UnivariateSpline function returns a "callable" function! Our next goal is to find the places where there are peaks. This is defined by the first derivative of the data being equal to zero. It is easy to get the first derivative of a UnivariateSpline with a second argument as shown below.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">get the first derivative evaluated at all the points</span>
<span style="color: #BA36A5;">d1s</span> = sp.derivative()

<span style="color: #BA36A5;">d1</span> = d1s(w1)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we can get the roots directly here, which correspond to minima and</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">maxima.</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Roots = {}'</span>.<span style="color: #006FE0;">format</span>(sp.derivative().roots()))
minmax = sp.derivative().roots()

plt.clf()
plt.plot(w1, d1, label=<span style="color: #008000;">'first derivative'</span>)
plt.xlabel(<span style="color: #008000;">'Raman shift (cm$^{-1}$)'</span>)
plt.ylabel(<span style="color: #008000;">'First derivative'</span>)
plt.grid()

plt.figure()
plt.plot(minmax, d1s(minmax), <span style="color: #008000;">'ro '</span>, label=<span style="color: #008000;">'zeros'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)

plt.plot(w1, i1, <span style="color: #008000;">'b. '</span>)
plt.plot(w1, sp(w1), <span style="color: #008000;">'r-'</span>)
plt.xlabel(<span style="color: #008000;">'Raman shift (cm$^{-1}$)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (counts)'</span>)
plt.plot(minmax, sp(minmax), <span style="color: #008000;">'ro '</span>)

plt.savefig(<span style="color: #008000;">'images/raman-4.png'</span>)
</pre>
</div>


<div id="org85d79ab" class="figure">
<p><img src="pycse-chapters/images/raman-4.png" alt="raman-4.png" />
</p>
</div>



<p>
In the end, we have illustrated how to construct a spline smoothing interpolation function and to find maxima in the function, including generating some initial guesses. There is more art to this than you might like, since you have to judge how much smoothing is enough or too much. With too much, you may smooth peaks out. With too little, noise may be mistaken for peaks.
</p>
</div>

<div id="outline-container-org124e111" class="outline-4">
<h4 id="org124e111"><span class="section-number-4">14.1.1.</span> Summary notes</h4>
<div class="outline-text-4" id="text-14-1-1">
<p>
Using org-mode with :session allows a large script to be broken up into mini sections. However, it only seems to work with the default python mode in Emacs, and it does not work with emacs-for-python or the latest python-mode. I also do not really like the output style, e.g. the output from the plotting commands.
</p>
</div>
</div>
</div>

<div id="outline-container-org5f35fa1" class="outline-3">
<h3 id="org5f35fa1"><span class="section-number-3">14.2.</span> Curve fitting to get overlapping peak areas</h3>
<div class="outline-text-3" id="text-14-2">
<p>
Today we examine an approach to fitting curves to overlapping peaks to deconvolute them so we can estimate the area under each curve. We have a text file that contains data from a gas chromatograph with two peaks that overlap. We want the area under each peak to estimate the gas composition. You will see how to read the text file in, parse it to get the data for plotting and analysis, and then how to fit it.
</p>


<p>
A line like "# of Points	9969" tells us the number of points we have to read. The data starts after a line containing "R.Time	Intensity". Here we read the number of points, and then get the data into arrays.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">datafile</span> = <span style="color: #008000;">'data/gc-data-21.txt'</span>

<span style="color: #BA36A5;">i</span> = 0
<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(datafile) <span style="color: #0000FF;">as</span> <span style="color: #BA36A5;">f</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   lines = f.readlines()

<span style="color: #0000FF;">for</span> i,line <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(lines):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #008000;">'# of Points'</span> <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">line</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   npoints = <span style="color: #006FE0;">int</span>(line.split()[-1])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> <span style="color: #008000;">'R.Time\tIntensity'</span> <span style="color: #0000FF;">in</span> <span style="color: #BA36A5;">line</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   i += 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">break</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now get the data</span>
<span style="color: #BA36A5;">t</span>, <span style="color: #BA36A5;">intensity</span> = [], []
<span style="color: #0000FF;">for</span> j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(i, i + npoints):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">fields</span> = lines[j].split()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">t</span> += [<span style="color: #006FE0;">float</span>(fields[0])]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">intensity</span> += [<span style="color: #006FE0;">int</span>(fields[1])]

<span style="color: #BA36A5;">t</span> = np.array(t)
<span style="color: #BA36A5;">intensity</span> = np.array(intensity, np.<span style="color: #006FE0;">float</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now plot the data in the relevant time frame</span>
plt.plot(t, intensity)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #008000;">'Time (s)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (arb. units)'</span>)
plt.savefig(<span style="color: #008000;">'images/deconvolute-1.png'</span>)
</pre>
</div>


<div id="orgc036169" class="figure">
<p><img src="pycse-chapters/images/deconvolute-1.png" alt="deconvolute-1.png" />
</p>
</div>

<p>
You can see there is a non-zero baseline. We will normalize that by the average between 4 and 4.4 seconds.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">intensity</span> -= np.mean(intensity[(t &gt; 4.0) &amp; (t &lt; 4.4)])
plt.figure()
plt.plot(t, intensity)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #008000;">'Time (s)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (arb. units)'</span>)
plt.savefig(<span style="color: #008000;">'./images/deconvolute-2.png'</span>)
</pre>
</div>


<div id="org81349f7" class="figure">
<p><img src="pycse-chapters/images/deconvolute-2.png" alt="deconvolute-2.png" />
</p>
</div>

<p>
The peaks are asymmetric, decaying gaussian functions. We define a function for this
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.special <span style="color: #0000FF;">import</span> erf

<span style="color: #0000FF;">def</span> <span style="color: #006699;">asym_peak</span>(t, pars):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'from Anal. Chem. 1994, 66, 1294-1301'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a0</span> = pars[0]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">peak area</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a1</span> = pars[1]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">elution time</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a2</span> = pars[2]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">width of gaussian</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a3</span> = pars[3]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">exponential damping term</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">f</span> = (a0/2/a3*np.exp(a2**2/2.0/a3**2 + (a1 - t)/a3)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>*(erf((t-a1)/(np.sqrt(2.0)*a2) - a2/np.sqrt(2.0)/a3) + 1.0))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> f
</pre>
</div>

<p>
To get two peaks, we simply add two peaks together.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">two_peaks</span>(t, *pars):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'function of two overlapping peaks'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a10</span> = pars[0]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">peak area</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a11</span> = pars[1]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">elution time</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a12</span> = pars[2]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">width of gaussian</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a13</span> = pars[3]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">exponential damping term</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a20</span> = pars[4]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">peak area</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a21</span> = pars[5]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">elution time</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a22</span> = pars[6]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">width of gaussian</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a23</span> = pars[7]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">exponential damping term</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">p1</span> = asym_peak(t, [a10, a11, a12, a13])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">p2</span> = asym_peak(t, [a20, a21, a22, a23])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> p1 + p2
</pre>
</div>

<p>
To show the function is close to reasonable, we plot the fitting function with an initial guess for each parameter. The fit is not good, but we have only guessed the parameters for now.
</p>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">parguess</span> = (1500, 4.85, 0.05, 0.05, 5000, 5.1, 0.05, 0.1)
plt.figure()
plt.plot(t, intensity)
plt.plot(t,two_peaks(t, *parguess),<span style="color: #008000;">'g-'</span>)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #008000;">'Time (s)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (arb. units)'</span>)
plt.savefig(<span style="color: #008000;">'images/deconvolution-3.png'</span>)
</pre>
</div>



<div id="org1fc35c3" class="figure">
<p><img src="pycse-chapters/images/deconvolution-3.png" alt="deconvolution-3.png" />
</p>
</div>

<p>
Next, we use nonlinear curve fitting from scipy.optimize.curve_fit
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> curve_fit

<span style="color: #BA36A5;">popt</span>, <span style="color: #BA36A5;">pcov</span> = curve_fit(two_peaks, t, intensity, parguess)
<span style="color: #0000FF;">print</span>(popt)

plt.plot(t, two_peaks(t, *popt), <span style="color: #008000;">'r-'</span>)
plt.legend([<span style="color: #008000;">'data'</span>, <span style="color: #008000;">'initial guess'</span>,<span style="color: #008000;">'final fit'</span>])

plt.savefig(<span style="color: #008000;">'images/deconvolution-4.png'</span>)
</pre>
</div>


<div id="orgd22289e" class="figure">
<p><img src="pycse-chapters/images/deconvolution-4.png" alt="deconvolution-4.png" />
</p>
</div>

<p>
The fits are not perfect. The small peak is pretty good, but there is an unphysical tail on the larger peak, and a small mismatch at the peak. There is not much to do about that, it means the model peak we are using is not a good model for the peak. We will still integrate the areas though.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">pars1</span> = popt[0:4]
<span style="color: #BA36A5;">pars2</span> = popt[4:8]

<span style="color: #BA36A5;">peak1</span> = asym_peak(t, pars1)
<span style="color: #BA36A5;">peak2</span> = asym_peak(t, pars2)

<span style="color: #BA36A5;">area1</span> = np.trapz(peak1, t)
<span style="color: #BA36A5;">area2</span> = np.trapz(peak2, t)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Area 1 = {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(area1))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Area 2 = {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(area2))

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Area 1 is {0:1.2%} of the whole area'</span>.<span style="color: #006FE0;">format</span>(area1/(area1 + area2)))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Area 2 is {0:1.2%} of the whole area'</span>.<span style="color: #006FE0;">format</span>(area2/(area1 + area2)))

plt.figure()
plt.plot(t, intensity)
plt.plot(t, peak1, <span style="color: #008000;">'r-'</span>)
plt.plot(t, peak2, <span style="color: #008000;">'g-'</span>)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #008000;">'Time (s)'</span>)
plt.ylabel(<span style="color: #008000;">'Intensity (arb. units)'</span>)
plt.legend([<span style="color: #008000;">'data'</span>, <span style="color: #008000;">'peak 1'</span>, <span style="color: #008000;">'peak 2'</span>])
plt.savefig(<span style="color: #008000;">'images/deconvolution-5.png'</span>)
</pre>
</div>


<div id="org65988d6" class="figure">
<p><img src="pycse-chapters/images/deconvolution-5.png" alt="deconvolution-5.png" />
</p>
</div>

<p>
This sample was air, and the first peak is oxygen, and the second peak is nitrogen. we come pretty close to the actual composition of air, although it is low on the oxygen content. To do better, one would have to use a calibration curve.
</p>

<p>
In the end, the overlap of the peaks is pretty small, but it is still difficult to reliably and reproducibly deconvolute them. By using an algorithm like we have demonstrated here, it is possible at least to make the deconvolution reproducible.
</p>
</div>

<div id="outline-container-orgb1fd87b" class="outline-4">
<h4 id="orgb1fd87b"><span class="section-number-4">14.2.1.</span> Notable differences from Matlab</h4>
<div class="outline-text-4" id="text-14-2-1">
<ol class="org-ol">
<li>The order of arguments to np.trapz is reversed.</li>
<li>The order of arguments to the fitting function scipy.optimize.curve_fit is different than in Matlab.</li>
<li>The scipy.optimize.curve_fit function expects a fitting function that has all parameters as arguments, where Matlab expects a vector of parameters.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org6a3411d" class="outline-3">
<h3 id="org6a3411d"><span class="section-number-3">14.3.</span> Estimating the boiling point of water</h3>
<div class="outline-text-3" id="text-14-3">
<p>
<a href="http://matlab.cheme.cmu.edu/2012/01/01/estimating-the-boiling-point-of-water/">Matlab post</a>
</p>

<p>
I got distracted looking for Shomate parameters for ethane today, and came across this <a href="http://senese.wordpress.com/2010/01/26/notebook-3-2-predicting-boiling-points-from-liquidvapor-gibbs-free-energy-functions/">website</a> on predicting the boiling point of water using the Shomate equations. The basic idea is to find the temperature where the Gibbs energy of water as a vapor is equal to the Gibbs energy of the liquid.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
</pre>
</div>

<p>
Liquid water (\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&Units=SI&Mask=2#Thermo-Condensed})
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">valid over 298-500</span>

<span style="color: #BA36A5;">Hf_liq</span> = -285.830   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kJ/mol</span>
<span style="color: #BA36A5;">S_liq</span> = 0.06995     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kJ/mol/K</span>
<span style="color: #BA36A5;">shomateL</span> = [-203.6060,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   1523.290,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  -3196.413,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   2474.455,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  3.855326,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -256.5478,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -488.7163,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -285.8304]
</pre>
</div>

<p>
Gas phase water (\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&Units=SI&Mask=1&Type=JANAFG&Table=on#JANAFG})
</p>

<p>
Interestingly, these parameters are listed as valid only above 500K. That means we have to extrapolate the values down to 298K. That is risky for polynomial models, as they can deviate substantially outside the region they were fitted to.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Hf_gas</span> = -241.826  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kJ/mol</span>
<span style="color: #BA36A5;">S_gas</span> = 0.188835   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kJ/mol/K</span>

<span style="color: #BA36A5;">shomateG</span> = [30.09200,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>6.832514,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>6.793435,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -2.534480,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>0.082139,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> -250.8810,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  223.3967,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> -241.8264]
</pre>
</div>

<p>
Now, we wan to compute G for each phase as a function of T
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">T</span> = np.linspace(0, 200) + 273.15
<span style="color: #BA36A5;">t</span> = T / 1000.0

<span style="color: #BA36A5;">sTT</span> = np.vstack([np.log(t),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>t,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(t**2) / 2.0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(t**3) / 3.0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>-1.0 / (2*t**2),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>0 * t,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>t**0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>0 * t**0]).T / 1000.0

<span style="color: #BA36A5;">hTT</span> = np.vstack([t,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(t**2)/2.0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(t**3)/3.0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(t**4)/4.0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>-1.0 / t,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>1 * t**0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>0 * t**0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>-1 * t**0]).T

<span style="color: #BA36A5;">Gliq</span> = Hf_liq + np.dot(hTT, shomateL) - T*(np.dot(sTT, shomateL))
<span style="color: #BA36A5;">Ggas</span> = Hf_gas + np.dot(hTT, shomateG) - T*(np.dot(sTT, shomateG))

<span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">f</span> = interp1d(T, Gliq - Ggas)
<span style="color: #BA36A5;">bp</span>, = fsolve(f, 373)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The boiling point is {0} K'</span>.<span style="color: #006FE0;">format</span>(bp))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">plt.figure(); plt.clf()
plt.plot(T-273.15, Gliq, T-273.15, Ggas)
plt.legend([<span style="color: #008000;">'liquid water'</span>, <span style="color: #008000;">'steam'</span>])

plt.xlabel(<span style="color: #008000;">'Temperature $^\circ$C'</span>)
plt.ylabel(<span style="color: #008000;">'$\Delta G$ (kJ/mol)'</span>)
plt.title(<span style="color: #008000;">'The boiling point is approximately {0:1.2f} $^\circ$C'</span>.<span style="color: #006FE0;">format</span>(bp-273.15))
plt.savefig(<span style="color: #008000;">'images/boiling-water.png'</span>)
</pre>
</div>


<div id="orge439236" class="figure">
<p><img src="pycse-chapters/images/boiling-water.png" alt="boiling-water.png" />
</p>
</div>
</div>

<div id="outline-container-org68712d0" class="outline-4">
<h4 id="org68712d0"><span class="section-number-4">14.3.1.</span> Summary</h4>
<div class="outline-text-4" id="text-14-3-1">
<p>
The answer we get us 0.05 K too high, which is not bad considering we estimated it using parameters that were fitted to thermodynamic data and that had finite precision and extrapolated the steam properties below the region the parameters were stated to be valid for.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfb1e20e" class="outline-3">
<h3 id="orgfb1e20e"><span class="section-number-3">14.4.</span> Gibbs energy minimization and the NIST webbook</h3>
<div class="outline-text-3" id="text-14-4">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/25/gibbs-energy-minimization-and-the-nist-webbook/">Matlab post</a>
In Post 1536 we used the NIST webbook to compute a temperature dependent Gibbs energy of reaction, and then used a reaction extent variable to compute the equilibrium concentrations of each species for the water gas shift reaction.
</p>

<p>
Today, we look at the direct minimization of the Gibbs free energy of the species, with no assumptions about stoichiometry of reactions. We only apply the constraint of conservation of atoms. We use the NIST Webbook to provide the data for the Gibbs energy of each species.
</p>

<p>
As a reminder we consider equilibrium between the species \(CO\), \(H_2O\), \(CO_2\) and \(H_2\), at 1000K, and 10 atm total pressure with an initial equimolar molar flow rate of \(CO\) and \(H_2O\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">T</span> = 1000  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">K</span>
<span style="color: #BA36A5;">R</span> = 8.314e-3 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kJ/mol/K</span>

<span style="color: #BA36A5;">P</span> = 10.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">atm, this is the total pressure in the reactor</span>
<span style="color: #BA36A5;">Po</span> = 1.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">atm, this is the standard state pressure</span>
</pre>
</div>

<p>
We are going to store all the data and calculations in vectors, so we need to assign each position in the vector to a species. Here are the definitions we use in this work.
</p>

<pre class="example" id="orgc1e4bdf">
1  CO
2  H2O
3  CO2
4  H2
</pre>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">species</span> = [<span style="color: #008000;">'CO'</span>, <span style="color: #008000;">'H2O'</span>, <span style="color: #008000;">'CO2'</span>, <span style="color: #008000;">'H2'</span>]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Heats of formation at 298.15 K</span>

<span style="color: #BA36A5;">Hf298</span> = [
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -110.53,  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">CO</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -241.826, <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H2O</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   -393.51,  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">CO2</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  0.0]   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H2</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Shomate parameters for each species</span>
<span style="color: #8D8D84;">#           </span><span style="color: #8D8D84; font-style: italic;">A          B           C          D          E            F          G       H</span>
<span style="color: #BA36A5;">WB</span> = [[25.56759,  6.096130,     4.054656,  -2.671301,  0.131021, -118.0089, 227.3665,   -110.5271],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">CO</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [30.09200,  6.832514,     6.793435,  -2.534480,  0.082139, -250.8810, 223.3967,   -241.8264],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H2O</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [24.99735,  55.18696,   -33.69137,    7.948387, -0.136638, -403.6075, 228.2431,   -393.5224],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">CO2</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> [33.066178, -11.363417,  11.432816,  -2.772874, -0.158558, -9.980797, 172.707974,    0.0]]     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H2</span>

<span style="color: #BA36A5;">WB</span> = np.array(WB)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Shomate equations</span>
<span style="color: #BA36A5;">t</span> = T/1000
<span style="color: #BA36A5;">T_H</span> = np.array([t,  t**2 / 2.0, t**3 / 3.0, t**4 / 4.0, -1.0 / t, 1.0, 0.0, -1.0])
<span style="color: #BA36A5;">T_S</span> = np.array([np.log(t), t,  t**2 / 2.0,  t**3 / 3.0, -1.0 / (2.0 * t**2), 0.0, 1.0, 0.0])

<span style="color: #BA36A5;">H</span> = np.dot(WB, T_H)        <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">(H - H_298.15) kJ/mol</span>
<span style="color: #BA36A5;">S</span> = np.dot(WB, T_S/1000.0) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">absolute entropy kJ/mol/K</span>

<span style="color: #BA36A5;">Gjo</span> = Hf298 + H - T*S      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Gibbs energy of each component at 1000 K</span>
</pre>
</div>

<p>
Now, construct the Gibbs free energy function, accounting for the change in activity due to concentration changes (ideal mixing).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(nj):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">nj</span> = np.array(nj)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Enj</span> = np.<span style="color: #006FE0;">sum</span>(nj);
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Gj</span> =  Gjo / (R * T) + np.log(nj / Enj * P / Po)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.dot(nj, Gj)
</pre>
</div>

<p>
We impose the constraint that all atoms are conserved from the initial conditions to the equilibrium distribution of species. These constraints are in the form of \(A_{eq} n = b_{eq}\), where \(n\) is the vector of mole numbers for each species.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Aeq</span> = np.array([[ 1,    0,    1,    0],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">C balance</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [ 1,    1,    2,    0],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">O balance</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [ 0,    2,    0,    2]]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H balance</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">equimolar feed of 1 mol H2O and 1 mol CO</span>
<span style="color: #BA36A5;">beq</span> = np.array([1,  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol C fed</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   2,  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol O fed</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   2]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol H fed</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ec1</span>(nj):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'conservation of atoms constraint'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.dot(Aeq, nj) - beq
</pre>
</div>

<p>
Now we are ready to solve the problem.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_slsqp

<span style="color: #BA36A5;">n0</span> = [0.5, 0.5, 0.5, 0.5]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial guesses</span>
<span style="color: #BA36A5;">N</span> = fmin_slsqp(func, n0, f_eqcons=ec1)
<span style="color: #0000FF;">print</span> N
</pre>
</div>
</div>

<div id="outline-container-orgfbfd55d" class="outline-4">
<h4 id="orgfbfd55d"><span class="section-number-4">14.4.1.</span> Compute mole fractions and partial pressures</h4>
<div class="outline-text-4" id="text-14-4-1">
<p>
The pressures here are in good agreement with the pressures found by other methods. The minor disagreement (in the third or fourth decimal place) is likely due to convergence tolerances in the different algorithms used.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">yj</span> = N / np.<span style="color: #006FE0;">sum</span>(N)
<span style="color: #BA36A5;">Pj</span> = yj * P

<span style="color: #0000FF;">for</span> s, y, p <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(species, yj, Pj):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:10s}: {1:1.2f} {2:1.2f}'</span>.<span style="color: #006FE0;">format</span>(s, y, p))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf4fbb2" class="outline-4">
<h4 id="orgbf4fbb2"><span class="section-number-4">14.4.2.</span> Computing equilibrium constants</h4>
<div class="outline-text-4" id="text-14-4-2">
<p>
We can compute the equilibrium constant for the reaction \(CO + H_2O \rightleftharpoons CO_2 + H_2\). Compared to the value of K = 1.44 we found at the end of Post 1536 , the agreement is excellent. Note, that to define an equilibrium constant it is necessary to specify a reaction, even though it is not necessary to even consider a reaction to obtain the equilibrium distribution of species!
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">nuj</span> = np.array([-1, -1, 1, 1])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">stoichiometric coefficients of the reaction</span>
<span style="color: #BA36A5;">K</span> = np.prod(yj**nuj)
<span style="color: #0000FF;">print</span>(K)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd496b44" class="outline-3">
<h3 id="orgd496b44"><span class="section-number-3">14.5.</span> Finding equilibrium composition by direct minimization of Gibbs free energy on mole numbers</h3>
<div class="outline-text-3" id="text-14-5">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/25/finding-equilibrium-composition-by-direct-minimization-of-gibbs-free-energy-on-mole-numbers/">Matlab post</a>
Adapted from problem 4.5 in Cutlip and Shacham
Ethane and steam are fed to a steam cracker at a total pressure of 1 atm and at 1000K at a ratio of 4 mol H2O to 1 mol ethane. Estimate the equilibrium distribution of products (CH4, C2H4, C2H2, CO2, CO, O2, H2, H2O, and C2H6).
</p>

<p>
Solution method: We will construct a Gibbs energy function for the mixture, and obtain the equilibrium composition by minimization of the function subject to elemental mass balance constraints.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">R</span> = 0.00198588 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kcal/mol/K</span>
<span style="color: #BA36A5;">T</span> = 1000 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">K</span>

<span style="color: #BA36A5;">species</span> = [<span style="color: #008000;">'CH4'</span>, <span style="color: #008000;">'C2H4'</span>, <span style="color: #008000;">'C2H2'</span>, <span style="color: #008000;">'CO2'</span>, <span style="color: #008000;">'CO'</span>, <span style="color: #008000;">'O2'</span>, <span style="color: #008000;">'H2'</span>, <span style="color: #008000;">'H2O'</span>, <span style="color: #008000;">'C2H6'</span>]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">$G_^\circ for each species. These are the heats of formation for each</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">species.</span>
<span style="color: #BA36A5;">Gjo</span> = np.array([4.61, 28.249, 40.604, -94.61, -47.942, 0, 0, -46.03, 26.13]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kcal/mol</span>
</pre>
</div>
</div>

<div id="outline-container-org01214f5" class="outline-4">
<h4 id="org01214f5"><span class="section-number-4">14.5.1.</span> The Gibbs energy of a mixture</h4>
<div class="outline-text-4" id="text-14-5-1">
<p>
We start with \(G=\sum\limits_j n_j \mu_j\). Recalling that we define \(\mu_j = G_j^\circ + RT \ln a_j\), and in the ideal gas limit, \(a_j = y_j P/P^\circ\), and that \(y_j = \frac{n_j}{\sum n_j}\). Since in this problem, P = 1 atm, this leads to the function \(\frac{G}{RT} = \sum\limits_{j=1}^n n_j\left(\frac{G_j^\circ}{RT} + \ln \frac{n_j}{\sum n_j}\right)\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(nj):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">nj</span> = np.array(nj)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Enj</span> = np.<span style="color: #006FE0;">sum</span>(nj);
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">G</span> = np.<span style="color: #006FE0;">sum</span>(nj * (Gjo / R / T + np.log(nj / Enj)))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> G
</pre>
</div>
</div>
</div>

<div id="outline-container-org2c88e05" class="outline-4">
<h4 id="org2c88e05"><span class="section-number-4">14.5.2.</span> Linear equality constraints for atomic mass conservation</h4>
<div class="outline-text-4" id="text-14-5-2">
<p>
The total number of each type of atom must be the same as what entered the reactor. These form equality constraints on the equilibrium composition. We express these constraints as: \(A_{eq} n = b\) where \(n\) is a vector of the moles of each species present in the mixture. CH4 C2H4 C2H2 CO2 CO O2 H2 H2O C2H6
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Aeq</span> = np.array([[0,   0,    0,   2,   1,  2,  0,  1,   0],      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">oxygen balance</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [4,   4,    2,   0,   0,  0,  2,  2,   6],      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">hydrogen balance</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [1,   2,    2,   1,   1,  0,  0,  0,   2]])     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">carbon balance</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the incoming feed was 4 mol H2O and 1 mol ethane</span>
<span style="color: #BA36A5;">beq</span> = np.array([4,  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">moles of oxygen atoms coming in</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   14, <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">moles of hydrogen atoms coming in</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   2]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">moles of carbon atoms coming in</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ec1</span>(n):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'equality constraint'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.dot(Aeq, n) - beq

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ic1</span>(n):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''inequality constraint</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   </span><span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">  all n&gt;=0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   '''</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> n
</pre>
</div>

<p>
Now we solve the problem.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial guess suggested in the example</span>
<span style="color: #BA36A5;">n0</span> = [1e-3, 1e-3, 1e-3, 0.993, 1.0, 1e-4, 5.992, 1.0, 1e-3]

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">n0 = [0.066, 8.7e-08, 2.1e-14, 0.545, 1.39, 5.7e-14, 5.346, 1.521, 1.58e-7]</span>

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_slsqp
<span style="color: #0000FF;">print</span>(func(n0))

<span style="color: #BA36A5;">X</span> = fmin_slsqp(func, n0, f_eqcons=ec1, f_ieqcons=ic1, <span style="color: #006FE0;">iter</span>=900, acc=1e-12)

<span style="color: #0000FF;">for</span> s,x <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(species, X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:10s} {1:1.4g}'</span>.<span style="color: #006FE0;">format</span>(s, x))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">check that constraints were met</span>
<span style="color: #0000FF;">print</span>(np.dot(Aeq, X) - beq)
<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">all</span>( np.<span style="color: #006FE0;">abs</span>( np.dot(Aeq, X) - beq) &lt; 1e-12))
</pre>
</div>

<p>
I found it necessary to tighten the accuracy parameter to get pretty good matches to the solutions found in Matlab. It was also necessary to increase the number of iterations. Even still, not all of the numbers match well, especially the very small numbers. You can, however, see that the constraints were satisfied pretty well.
</p>


<p>
Interestingly there is a distribution of products! That is interesting because only steam and ethane enter the reactor, but a small fraction of methane is formed! The main product is hydrogen. The stoichiometry of steam reforming is ideally \(C_2H_6 + 4H_2O \rightarrow 2CO_2 + 7 H2\). Even though nearly all the ethane is consumed, we do not get the full yield of hydrogen. It appears that another equilibrium, one between CO, CO2, H2O and H2, may be limiting that, since the rest of the hydrogen is largely in the water. It is also of great importance that we have not said anything about reactions, i.e. how these products were formed.
</p>

<p>
The water gas shift reaction is: \(CO + H_2O \rightleftharpoons CO_2 + H_2\). We can compute the Gibbs free energy of the reaction from the heats of formation of each species. Assuming these are the formation energies at 1000K, this is the reaction free energy at 1000K.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">G_wgs</span> = Gjo[3] + Gjo[6] - Gjo[4] - Gjo[7]
<span style="color: #0000FF;">print</span>(G_wgs)

<span style="color: #BA36A5;">K</span> = np.exp(-G_wgs / (R*T))
<span style="color: #0000FF;">print</span>(K)
</pre>
</div>
</div>
</div>

<div id="outline-container-org4eb8ba6" class="outline-4">
<h4 id="org4eb8ba6"><span class="section-number-4">14.5.3.</span> Equilibrium constant based on mole numbers</h4>
<div class="outline-text-4" id="text-14-5-3">
<p>
One normally uses activities to define the equilibrium constant. Since there are the same number of moles on each side of the reaction all factors that convert mole numbers to activity, concentration or pressure cancel, so we simply consider the ratio of mole numbers here.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span> (X[3] * X[6]) / (X[4] * X[7])
</pre>
</div>

<p>
This is very close to the equilibrium constant computed above.
</p>

<p>
Clearly, there is an equilibrium between these species that prevents the complete reaction of steam reforming.
</p>
</div>
</div>

<div id="outline-container-orgf72715c" class="outline-4">
<h4 id="orgf72715c"><span class="section-number-4">14.5.4.</span> Summary</h4>
<div class="outline-text-4" id="text-14-5-4">
<p>
This is an appealing way to minimize the Gibbs energy of a mixture. No assumptions about reactions are necessary, and the constraints are easy to identify. The Gibbs energy function is especially easy to code.
</p>
</div>
</div>
</div>
<div id="outline-container-org74b6fe0" class="outline-3">
<h3 id="org74b6fe0"><span class="section-number-3">14.6.</span> The Gibbs free energy of a reacting mixture and the equilibrium composition</h3>
<div class="outline-text-3" id="text-14-6">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/20/the-gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition/">Matlab post</a>
</p>

<p>
In this post we derive the equations needed to find the equilibrium composition of a reacting mixture. We use the method of direct minimization of the Gibbs free energy of the reacting mixture.
</p>

<p>
The Gibbs free energy of a mixture is defined as \(G = \sum\limits_j \mu_j n_j\) where \(\mu_j\) is the chemical potential of species \(j\), and it is temperature and pressure dependent, and \(n_j\) is the number of moles of species \(j\).
</p>

<p>
We define the chemical potential as \(\mu_j = G_j^\circ + RT\ln a_j\), where \(G_j^\circ\) is the Gibbs energy in a standard state, and \(a_j\) is the activity of species \(j\) if the pressure and temperature are not at standard state conditions.
</p>

<p>
If a reaction is occurring, then the number of moles of each species are related to each other through the reaction extent \(\epsilon\) and stoichiometric coefficients: \(n_j = n_{j0} + \nu_j \epsilon\). Note that the reaction extent has units of moles.
</p>

<p>
Combining these three equations and expanding the terms leads to:
</p>

<p>
\[G = \sum\limits_j n_{j0}G_j^\circ +\sum\limits_j \nu_j G_j^\circ \epsilon +RT\sum\limits_j(n_{j0} + \nu_j\epsilon)\ln a_j \]
</p>

<p>
The first term is simply the initial Gibbs free energy that is present before any reaction begins, and it is a constant. It is difficult to evaluate, so we will move it to the left side of the equation in the next step, because it does not matter what its value is since it is a constant. The second term is related to the Gibbs free energy of reaction: \(\Delta_rG = \sum\limits_j \nu_j G_j^\circ\). With these observations we rewrite the equation as:
</p>

<p>
\[G - \sum\limits_j n_{j0}G_j^\circ = \Delta_rG \epsilon +RT\sum\limits_j(n_{j0} + \nu_j\epsilon)\ln a_j \]
</p>

<p>
Now, we have an equation that allows us to compute the change in Gibbs free energy as a function of the reaction extent, initial number of moles of each species, and the activities of each species. This difference in Gibbs free energy has no natural scale, and depends on the size of the system, i.e. on \(n_{j0}\). It is desirable to avoid this, so we now rescale the equation by the total initial moles present, \(n_{T0}\) and define a new variable \(\epsilon' = \epsilon/n_{T0}\), which is dimensionless. This leads to:
</p>

<p>
\[ \frac{G - \sum\limits_j n_{j0}G_j^\circ}{n_{T0}} = \Delta_rG \epsilon' + RT \sum\limits_j(y_{j0} + \nu_j\epsilon')\ln a_j \]
</p>

<p>
where \(y_{j0}\) is the initial mole fraction of species \(j\) present. The mole fractions are intensive properties that do not depend on the system size. Finally, we need to address \(a_j\). For an ideal gas, we know that \(A_j = \frac{y_j P}{P^\circ}\), where the numerator is the partial pressure of species \(j\) computed from the mole fraction of species \(j\) times the total pressure. To get the mole fraction we note:
</p>

<p>
\[y_j = \frac{n_j}{n_T} = \frac{n_{j0} + \nu_j \epsilon}{n_{T0} + \epsilon \sum\limits_j \nu_j} = \frac{y_{j0} + \nu_j \epsilon'}{1 + \epsilon'\sum\limits_j \nu_j} \]
</p>

<p>
This finally leads us to an equation that we can evaluate as a function of reaction extent:
</p>

<p>
\[ \frac{G - \sum\limits_j n_{j0}G_j^\circ}{n_{T0}} = \widetilde{\widetilde{G}} = \Delta_rG \epsilon' + RT\sum\limits_j(y_{j0} + \nu_j\epsilon') \ln\left(\frac{y_{j0}+\nu_j\epsilon'}{1+\epsilon'\sum\limits_j\nu_j} \frac{P}{P^\circ}\right) \]
</p>

<p>
we use a double tilde notation to distinguish this quantity from the quantity derived by Rawlings and Ekerdt which is further normalized by a factor of \(RT\). This additional scaling makes the quantities dimensionless, and makes the quantity have a magnitude of order unity, but otherwise has no effect on the shape of the graph.
</p>

<p>
Finally, if we know the initial mole fractions, the initial total pressure, the Gibbs energy of reaction, and the stoichiometric coefficients, we can plot the scaled reacting mixture energy as a function of reaction extent. At equilibrium, this energy will be a minimum. We consider the example in Rawlings and Ekerdt where isobutane (I) reacts with 1-butene (B) to form 2,2,3-trimethylpentane (P). The reaction occurs at a total pressure of 2.5 atm at 400K, with equal molar amounts of I and B. The standard Gibbs free energy of reaction at 400K is -3.72 kcal/mol. Compute the equilibrium composition.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">R</span> = 8.314
<span style="color: #BA36A5;">P</span> = 250000  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Pa</span>
<span style="color: #BA36A5;">P0</span> = 100000 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Pa, approximately 1 atm</span>
<span style="color: #BA36A5;">T</span> = 400 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">K</span>

<span style="color: #BA36A5;">Grxn</span> = -15564.0 <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">J/mol</span>
<span style="color: #BA36A5;">yi0</span> = 0.5; <span style="color: #BA36A5;">yb0</span> = 0.5; <span style="color: #BA36A5;">yp0</span> = 0.0; <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial mole fractions</span>

<span style="color: #BA36A5;">yj0</span> = np.array([yi0, yb0, yp0])
<span style="color: #BA36A5;">nu_j</span> = np.array([-1.0, -1.0, 1.0])   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">stoichiometric coefficients</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Gwigglewiggle</span>(extentp):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">diffg</span> = Grxn * extentp
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sum_nu_j</span> = np.<span style="color: #006FE0;">sum</span>(nu_j)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i,y <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(yj0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x1</span> = yj0[i] + nu_j[i] * extentp
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">x2</span> = x1 / (1.0 + extentp*sum_nu_j)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">diffg</span> += R * T * x1 * np.log(x2 * P / P0)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> diffg
</pre>
</div>

<p>
There are bounds on how large \(\epsilon'\) can be. Recall that \(n_j = n_{j0} + \nu_j \epsilon\), and that \(n_j \ge 0\). Thus, \(\epsilon_{max} = -n_{j0}/\nu_j\), and the maximum value that \(\epsilon'\) can have is therefore \(-y_{j0}/\nu_j\) where \(y_{j0}>0\). When there are multiple species, you need the smallest \(epsilon'_{max}\) to avoid getting negative mole numbers.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">epsilonp_max</span> = <span style="color: #006FE0;">min</span>(-yj0[yj0 &gt; 0] / nu_j[yj0 &gt; 0])
<span style="color: #BA36A5;">epsilonp</span> = np.linspace(1e-6, epsilonp_max, 1000);

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.plot(epsilonp,Gwigglewiggle(epsilonp))
plt.xlabel(<span style="color: #008000;">'$\epsilon$'</span>)
plt.ylabel(<span style="color: #008000;">'Gwigglewiggle'</span>)
plt.savefig(<span style="color: #008000;">'images/gibbs-minim-1.png'</span>)
</pre>
</div>


<div id="orga78fb56" class="figure">
<p><img src="pycse-chapters/images/gibbs-minim-1.png" alt="gibbs-minim-1.png" />
</p>
</div>

<p>
Now we simply minimize our Gwigglewiggle function. Based on the figure above, the miminum is near 0.45.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fminbound

<span style="color: #BA36A5;">epsilonp_eq</span> = fminbound(Gwigglewiggle, 0.4, 0.5)
<span style="color: #0000FF;">print</span>(epsilonp_eq)

plt.plot([epsilonp_eq], [Gwigglewiggle(epsilonp_eq)], <span style="color: #008000;">'ro'</span>)
plt.savefig(<span style="color: #008000;">'images/gibbs-minim-2.png'</span>)
</pre>
</div>


<div id="org207f91a" class="figure">
<p><img src="pycse-chapters/images/gibbs-minim-2.png" alt="gibbs-minim-2.png" />
</p>
</div>

<p>
To compute equilibrium mole fractions we do this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">yi</span> = (yi0 + nu_j[0]*epsilonp_eq) / (1.0 + epsilonp_eq*np.<span style="color: #006FE0;">sum</span>(nu_j))
<span style="color: #BA36A5;">yb</span> = (yb0 + nu_j[1]*epsilonp_eq) / (1.0 + epsilonp_eq*np.<span style="color: #006FE0;">sum</span>(nu_j))
<span style="color: #BA36A5;">yp</span> = (yp0 + nu_j[2]*epsilonp_eq) / (1.0 + epsilonp_eq*np.<span style="color: #006FE0;">sum</span>(nu_j))

<span style="color: #0000FF;">print</span>(yi, yb, yp)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">or this</span>
<span style="color: #BA36A5;">y_j</span> = (yj0 + np.dot(nu_j, epsilonp_eq)) / (1.0 + epsilonp_eq*np.<span style="color: #006FE0;">sum</span>(nu_j))
<span style="color: #0000FF;">print</span>(y_j)
</pre>
</div>

<p>
\(K = \frac{a_P}{a_I a_B} = \frac{y_p P/P^\circ}{y_i P/P^\circ y_b P/P^\circ} = \frac{y_P}{y_i y_b}\frac{P^\circ}{P}\).
</p>

<p>
We can express the equilibrium constant like this :\(K = \prod\limits_j a_j^{\nu_j}\), and compute it with a single line of code.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">K</span> = np.exp(-Grxn/R/T)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'K from delta G '</span>,K)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'K as ratio of mole fractions '</span>,yp / (yi * yb) * P0 / P)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'compact notation: '</span>,np.prod((y_j * P / P0)**nu_j))
</pre>
</div>


<p>
These results are very close, and only disagree because of the default tolerance used in identifying the minimum of our function. You could tighten the tolerances by setting options to the fminbnd function.
</p>
</div>

<div id="outline-container-org19b6d58" class="outline-4">
<h4 id="org19b6d58"><span class="section-number-4">14.6.1.</span> Summary</h4>
<div class="outline-text-4" id="text-14-6-1">
<p>
In this post we derived an equation for the Gibbs free energy of a reacting mixture and used it to find the equilibrium composition. In future posts we will examine some alternate forms of the equations that may be more useful in some circumstances.
</p>
</div>
</div>
</div>

<div id="outline-container-org0cd1088" class="outline-3">
<h3 id="org0cd1088"><span class="section-number-3">14.7.</span> Water gas shift equilibria via the NIST Webbook</h3>
<div class="outline-text-3" id="text-14-7">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/12/water-gas-shift-equilibria-via-the-nist-webbook/">Matlab post</a>
</p>

<p>
The <a href="http://webbook.nist.gov/chemistry/">NIST webbook</a> provides parameterized models of the enthalpy, entropy and heat capacity of many molecules. In this example, we will examine how to use these to compute the equilibrium constant for the water gas shift reaction \(CO + H_2O \rightleftharpoons CO_2 + H_2\) in the temperature range of 500K to 1000K.
</p>

<p>
Parameters are provided for:
</p>

<p>
Cp = heat capacity (J/mol*K)
H = standard enthalpy (kJ/mol)
S = standard entropy (J/mol*K)
</p>

<p>
with models in the form: \(Cp^\circ = A + B*t + C*t^2 + D*t^3 + E/t^2\)
</p>

<p>
\(H^\circ - H^\circ_{298.15}= A*t + B*t^2/2 + C*t^3/3 + D*t^4/4 - E/t + F - H\)
</p>

<p>
\(S^\circ = A*ln(t) + B*t + C*t^2/2 + D*t^3/3 - E/(2*t^2) + G\)
</p>

<p>
where \(t=T/1000\), and \(T\) is the temperature in Kelvin. We can use this data to calculate equilibrium constants in the following manner. First, we have heats of formation at standard state for each compound; for elements, these are zero by definition, and for non-elements, they have values available from the NIST webbook. There are also values for the absolute entropy at standard state. Then, we have an expression for the change in enthalpy from standard state as defined above, as well as the absolute entropy. From these we can derive the reaction enthalpy, free energy and entropy at standard state, as well as at other temperatures.
</p>

<p>
We will examine the water gas shift enthalpy, free energy and equilibrium constant from 500K to 1000K, and finally compute the equilibrium composition of a gas feed containing 5 atm of CO and H_2 at 1000K.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">T</span> = np.linspace(500,1000) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">degrees K</span>
<span style="color: #BA36A5;">t</span> = T/1000;
</pre>
</div>
</div>

<div id="outline-container-orgfa18a6a" class="outline-4">
<h4 id="orgfa18a6a"><span class="section-number-4">14.7.1.</span> hydrogen</h4>
<div class="outline-text-4" id="text-14-7-1">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C1333740&Units=SI&Mask=1#Thermo-Gas}
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">T = 298-1000K valid temperature range</span>
<span style="color: #BA36A5;">A</span> =  33.066178
<span style="color: #BA36A5;">B</span> = -11.363417
<span style="color: #BA36A5;">C</span> =  11.432816
<span style="color: #BA36A5;">D</span> = -2.772874
<span style="color: #BA36A5;">E</span> = -0.158558
<span style="color: #BA36A5;">F</span> = -9.980797
<span style="color: #BA36A5;">G</span> =  172.707974
<span style="color: #BA36A5;">H</span> =  0.0

<span style="color: #BA36A5;">Hf_29815_H2</span> = 0.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kJ/mol</span>
<span style="color: #BA36A5;">S_29815_H2</span> = 130.68 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">J/mol/K</span>

<span style="color: #BA36A5;">dH_H2</span> = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
<span style="color: #BA36A5;">S_H2</span> = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge333dac" class="outline-4">
<h4 id="orge333dac"><span class="section-number-4">14.7.2.</span> H_{2}O</h4>
<div class="outline-text-4" id="text-14-7-2">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&Units=SI&Mask=1#Thermo-Gas}
</p>

<p>
Note these parameters limit the temperature range we can examine, as these parameters are not valid below 500K. There is another set of parameters for lower temperatures, but we do not consider them here.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">500-1700 K valid temperature range</span>
<span style="color: #BA36A5;">A</span> =   30.09200
<span style="color: #BA36A5;">B</span> =   6.832514
<span style="color: #BA36A5;">C</span> =   6.793435
<span style="color: #BA36A5;">D</span> =  -2.534480
<span style="color: #BA36A5;">E</span> =   0.082139
<span style="color: #BA36A5;">F</span> =  -250.8810
<span style="color: #BA36A5;">G</span> =   223.3967
<span style="color: #BA36A5;">H</span> =  -241.8264

<span style="color: #BA36A5;">Hf_29815_H2O</span> = -241.83 <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">this is Hf.</span>
<span style="color: #BA36A5;">S_29815_H2O</span> = 188.84

<span style="color: #BA36A5;">dH_H2O</span> = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
<span style="color: #BA36A5;">S_H2O</span> = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfdd9f42" class="outline-4">
<h4 id="orgfdd9f42"><span class="section-number-4">14.7.3.</span> CO</h4>
<div class="outline-text-4" id="text-14-7-3">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C630080&Units=SI&Mask=1#Thermo-Gas}
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">298. - 1300K valid temperature range</span>
<span style="color: #BA36A5;">A</span> =   25.56759
<span style="color: #BA36A5;">B</span> =   6.096130
<span style="color: #BA36A5;">C</span> =   4.054656
<span style="color: #BA36A5;">D</span> =  -2.671301
<span style="color: #BA36A5;">E</span> =   0.131021
<span style="color: #BA36A5;">F</span> =  -118.0089
<span style="color: #BA36A5;">G</span> =   227.3665
<span style="color: #BA36A5;">H</span> = -110.5271

<span style="color: #BA36A5;">Hf_29815_CO</span> = -110.53 <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">this is Hf kJ/mol.</span>
<span style="color: #BA36A5;">S_29815_CO</span> = 197.66

<span style="color: #BA36A5;">dH_CO</span> = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
<span style="color: #BA36A5;">S_CO</span> = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ca2dbb" class="outline-4">
<h4 id="org5ca2dbb"><span class="section-number-4">14.7.4.</span> CO_{2}</h4>
<div class="outline-text-4" id="text-14-7-4">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C124389&Units=SI&Mask=1#Thermo-Gas}
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">298. - 1200.K valid temperature range</span>
<span style="color: #BA36A5;">A</span> =   24.99735
<span style="color: #BA36A5;">B</span> =   55.18696
<span style="color: #BA36A5;">C</span> =  -33.69137
<span style="color: #BA36A5;">D</span> =   7.948387
<span style="color: #BA36A5;">E</span> =  -0.136638
<span style="color: #BA36A5;">F</span> =  -403.6075
<span style="color: #BA36A5;">G</span> =   228.2431
<span style="color: #BA36A5;">H</span> =  -393.5224

<span style="color: #BA36A5;">Hf_29815_CO2</span> = -393.51 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is Hf.</span>
<span style="color: #BA36A5;">S_29815_CO2</span> = 213.79

<span style="color: #BA36A5;">dH_CO2</span> = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
<span style="color: #BA36A5;">S_CO2</span> = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f39689" class="outline-4">
<h4 id="org5f39689"><span class="section-number-4">14.7.5.</span> Standard state heat of reaction</h4>
<div class="outline-text-4" id="text-14-7-5">
<p>
We compute the enthalpy and free energy of reaction at 298.15 K for the following reaction \(CO + H2O \rightleftharpoons H2 + CO2\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Hrxn_29815</span> = Hf_29815_CO2 + Hf_29815_H2 - Hf_29815_CO - Hf_29815_H2O;
<span style="color: #BA36A5;">Srxn_29815</span> = S_29815_CO2 + S_29815_H2 - S_29815_CO - S_29815_H2O;
<span style="color: #BA36A5;">Grxn_29815</span> = Hrxn_29815 - 298.15*(Srxn_29815)/1000;

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'deltaH = {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(Hrxn_29815))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'deltaG = {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(Grxn_29815))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f44dd9" class="outline-4">
<h4 id="org8f44dd9"><span class="section-number-4">14.7.6.</span> Non-standard state \(\Delta H\) and \(\Delta G\)</h4>
<div class="outline-text-4" id="text-14-7-6">
<p>
We have to correct for temperature change away from standard state. We only correct the enthalpy for this temperature change. The correction looks like this:
</p>

<p>
\[ \Delta H_{rxn}(T) = \Delta H_{rxn}(T_{ref}) + \sum_i \nu_i (H_i(T)-H_i(T_{ref}))\]
</p>

<p>
Where \(\nu_i\) are the stoichiometric coefficients of each species, with appropriate sign for reactants and products, and \((H_i(T)-H_i(T_{ref})\) is precisely what is calculated for each species with the equations
</p>

<p>
The entropy is on an absolute scale, so we directly calculate entropy at each temperature. Recall that H is in kJ/mol and S is in J/mol/K, so we divide S by 1000 to make the units match.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">Hrxn</span> = Hrxn_29815 + dH_CO2 + dH_H2 - dH_CO - dH_H2O
<span style="color: #BA36A5;">Grxn</span> = Hrxn - T*(S_CO2 + S_H2 - S_CO - S_H2O)/1000
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce3542f" class="outline-4">
<h4 id="orgce3542f"><span class="section-number-4">14.7.7.</span> Plot how the \(\Delta G\) varies with temperature</h4>
<div class="outline-text-4" id="text-14-7-7">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.figure(); plt.clf()
plt.plot(T,Grxn, label=<span style="color: #008000;">'$\Delta G_{rxn}$'</span>)
plt.plot(T,Hrxn, label=<span style="color: #008000;">'$\Delta H_{rxn}$'</span>)
plt.xlabel(<span style="color: #008000;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #008000;">'(kJ/mol)'</span>)
plt.legend( loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/wgs-nist-1.png'</span>)
</pre>
</div>


<div id="org695bc5b" class="figure">
<p><img src="pycse-chapters/images/wgs-nist-1.png" alt="wgs-nist-1.png" />
</p>
</div>

<p>
Over this temperature range the reaction is exothermic, although near 1000K it is just barely exothermic. At higher temperatures we expect the reaction to become endothermic.
</p>
</div>
</div>

<div id="outline-container-org6bec3b3" class="outline-4">
<h4 id="org6bec3b3"><span class="section-number-4">14.7.8.</span> Equilibrium constant calculation</h4>
<div class="outline-text-4" id="text-14-7-8">
<p>
Note the equilibrium constant starts out high, i.e. strongly favoring the formation of products, but drops very quicky with increasing temperature.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">R</span> = 8.314e-3 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">kJ/mol/K</span>
<span style="color: #BA36A5;">K</span> = np.exp(-Grxn/R/T);

plt.figure()
plt.plot(T,K)
plt.xlim([500, 1000])
plt.xlabel(<span style="color: #008000;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #008000;">'Equilibrium constant'</span>)
plt.savefig(<span style="color: #008000;">'images/wgs-nist-2.png'</span>)
</pre>
</div>


<div id="org8ca7ca6" class="figure">
<p><img src="pycse-chapters/images/wgs-nist-2.png" alt="wgs-nist-2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc0f3129" class="outline-4">
<h4 id="orgc0f3129"><span class="section-number-4">14.7.9.</span> Equilibrium yield of WGS</h4>
<div class="outline-text-4" id="text-14-7-9">
<p>
Now let us suppose we have a reactor with a feed of H_2O and CO at 10atm at 1000K. What is the equilibrium yield of H_2? Let \(\epsilon\) be the extent of reaction, so that \(F_i = F_{i,0} + \nu_i \epsilon\). For reactants, \(\nu_i\) is negative, and for products, \(\nu_i\) is positive. We have to solve for the extent of reaction that satisfies the equilibrium condition.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.interpolate <span style="color: #0000FF;">import</span> interp1d
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #8D8D84;">#</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">A = CO</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">B = H2O</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">C = H2</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">D = CO2</span>

<span style="color: #BA36A5;">Pa0</span> = 5; <span style="color: #BA36A5;">Pb0</span> = 5; <span style="color: #BA36A5;">Pc0</span> = 0; <span style="color: #BA36A5;">Pd0</span> = 0;  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">pressure in atm</span>
<span style="color: #BA36A5;">R</span> = 0.082;
<span style="color: #BA36A5;">Temperature</span> = 1000;

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we can estimate the equilibrium like this. We could also calculate it</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">using the equations above, but we would have to evaluate each term. Above</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we simply computed a vector of enthalpies, entropies, etc... Here we interpolate</span>
<span style="color: #BA36A5;">K_func</span> = interp1d(T,K);
<span style="color: #BA36A5;">K_Temperature</span> = K_func(1000)


<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">If we let X be fractional conversion then we have $C_A = C_{A0}(1-X)$,</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">$C_B = C_{B0}-C_{A0}X$, $C_C = C_{C0}+C_{A0}X$, and $C_D =</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">C_{D0}+C_{A0}X$. We also have $K(T) = (C_C C_D)/(C_A C_B)$, which finally</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reduces to $0 = K(T) - Xeq^2/(1-Xeq)^2$ under these conditions.</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> K_Temperature - X**2/(1-X)**2;

<span style="color: #BA36A5;">x0</span> = 0.5
<span style="color: #BA36A5;">Xeq</span>, = fsolve(f, x0)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The equilibrium conversion for these feed conditions is: {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(Xeq))
</pre>
</div>
</div>
</div>

<div id="outline-container-org45dab0b" class="outline-4">
<h4 id="org45dab0b"><span class="section-number-4">14.7.10.</span> Compute gas phase pressures of each species</h4>
<div class="outline-text-4" id="text-14-7-10">
<p>
Since there is no change in moles for this reaction, we can directly calculation the pressures from the equilibrium conversion and the initial pressure of gases. you can see there is a slightly higher pressure of H_2 and CO_2 than the reactants, consistent with the equilibrium constant of about 1.44 at 1000K. At a lower temperature there would be a much higher yield of the products. For example, at 550K the equilibrium constant is about 58, and the pressure of H_2 is 4.4 atm due to a much higher equilibrium conversion of 0.88.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">P_CO</span> = Pa0*(1-Xeq)
<span style="color: #BA36A5;">P_H2O</span> = Pa0*(1-Xeq)
<span style="color: #BA36A5;">P_H2</span> = Pa0*Xeq
<span style="color: #BA36A5;">P_CO2</span> = Pa0*Xeq

<span style="color: #0000FF;">print</span>(P_CO,P_H2O, P_H2, P_CO2)
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b00e57" class="outline-4">
<h4 id="org0b00e57"><span class="section-number-4">14.7.11.</span> Compare the equilibrium constants</h4>
<div class="outline-text-4" id="text-14-7-11">
<p>
We can compare the equilibrium constant from the Gibbs free energy and the one from the ratio of pressures. They should be the same!
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>(K_Temperature)
<span style="color: #0000FF;">print</span>((P_CO2*P_H2)/(P_CO*P_H2O))
</pre>
</div>

<p>
They are the same.
</p>
</div>
</div>

<div id="outline-container-org88b0d60" class="outline-4">
<h4 id="org88b0d60"><span class="section-number-4">14.7.12.</span> Summary</h4>
<div class="outline-text-4" id="text-14-7-12">
<p>
The NIST Webbook provides a plethora of data for computing thermodynamic properties. It is a little tedious to enter it all into Matlab, and a little tricky to use the data to estimate temperature dependent reaction energies. A limitation of the Webbook is that it does not tell you have the thermodynamic properties change with pressure. Luckily, those changes tend to be small.
</p>

<p>
I noticed a different behavior in interpolation between scipy.interpolate.interp1d and Matlab's interp1. The scipy function returns an interpolating function, whereas the Matlab function directly interpolates new values, and returns the actual interpolated data.
</p>
</div>
</div>
</div>

<div id="outline-container-org2b386a5" class="outline-3">
<h3 id="org2b386a5"><span class="section-number-3">14.8.</span> Constrained minimization to find equilibrium compositions</h3>
<div class="outline-text-3" id="text-14-8">
<p>
adapated from Chemical Reactor analysis and design fundamentals, Rawlings and Ekerdt, appendix A.2.3.
</p>

<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/12/constrained-minimization-to-find-equilibrium-compositions/">Matlab post</a>
</p>

<p>
The equilibrium composition of a reaction is the one that minimizes the total Gibbs free energy. The Gibbs free energy of a reacting ideal gas mixture depends on the mole fractions of each species, which are determined by the initial mole fractions of each species, the extent of reactions that convert each species, and the equilibrium constants.
</p>

<p>
Reaction 1: \(I + B \rightleftharpoons P1\)
</p>

<p>
Reaction 2: \(I + B \rightleftharpoons P2\)
</p>

<p>
Here we define the Gibbs free energy of the mixture as a function of the reaction extents.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">gibbs</span>(E):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'function defining Gibbs free energy as a function of reaction extents'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e1</span> = E[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e2</span> = E[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">known equilibrium constants and initial amounts</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">K1</span> = 108; <span style="color: #BA36A5;">K2</span> = 284; <span style="color: #BA36A5;">P</span> = 2.5
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yI0</span> = 0.5; <span style="color: #BA36A5;">yB0</span> = 0.5; <span style="color: #BA36A5;">yP10</span> = 0.0; <span style="color: #BA36A5;">yP20</span> = 0.0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">compute mole fractions</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">d</span> = 1 - e1 - e2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yI</span> = (yI0 - e1 - e2) / d
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yB</span> = (yB0 - e1 - e2) / d
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yP1</span> = (yP10 + e1) / d
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yP2</span> = (yP20 + e2) / d
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">G</span> = (-(e1 * np.log(K1) + e2 * np.log(K2)) +
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>d * np.log(P) + yI * d * np.log(yI) +
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>yB * d * np.log(yB) + yP1 * d * np.log(yP1) + yP2 * d * np.log(yP2))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> G
</pre>
</div>

<p>
The equilibrium constants for these reactions are known, and we seek to find the equilibrium reaction extents so we can determine equilibrium compositions. The equilibrium reaction extents are those that minimize the Gibbs free energy.  We have the following constraints, written in standard less than or equal to form:
</p>

<p>
\(-\epsilon_1 \le 0\)
</p>

<p>
\(-\epsilon_2 \le 0\)
</p>

<p>
\(\epsilon_1 + \epsilon_2 \le 0.5\)
</p>

<p>
In Matlab we express this in matrix form as Ax=b where
</p>
\begin{equation}
A = \left[ \begin{array}{cc} -1 & 0 \\ 0 & -1 \\ 1 & 1 \end{array} \right]
\end{equation}

<p>
and
</p>

\begin{equation}
b = \left[ \begin{array}{c} 0 \\ 0 \\ 0.5\end{array} \right]
\end{equation}

<p>
Unlike in Matlab, in python we construct the inequality constraints as functions that are greater than or equal to zero when the constraint is met.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">constraint1</span>(E):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e1</span> = E[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> e1


<span style="color: #0000FF;">def</span> <span style="color: #006699;">constraint2</span>(E):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e2</span> = E[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> e2


<span style="color: #0000FF;">def</span> <span style="color: #006699;">constraint3</span>(E):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e1</span> = E[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e2</span> = E[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 0.5 - (e1 + e2)
</pre>
</div>

<p>
Now, we minimize.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_slsqp

<span style="color: #BA36A5;">X0</span> = [0.2, 0.2]
<span style="color: #BA36A5;">X</span> = fmin_slsqp(gibbs, X0, ieqcons=[constraint1, constraint2, constraint3],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  bounds=((0.001, 0.499),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  (0.001, 0.499)))
<span style="color: #0000FF;">print</span>(X)

<span style="color: #0000FF;">print</span>(gibbs(X))
</pre>
</div>



<p>
One way we can verify our solution is to plot the gibbs function and see where the minimum is, and whether there is more than one minimum. We start by making grids over the range of 0 to 0.5. Note we actually start slightly above zero because at zero there are some numerical imaginary elements of the gibbs function or it is numerically not defined since there are logs of zero there. We also set all elements where the sum of the two extents is greater than 0.5 to near zero, since those regions violate the constraints.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">gibbs</span>(E):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'function defining Gibbs free energy as a function of reaction extents'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e1</span> = E[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">e2</span> = E[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">known equilibrium constants and initial amounts</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">K1</span> = 108; <span style="color: #BA36A5;">K2</span> = 284; <span style="color: #BA36A5;">P</span> = 2.5;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yI0</span> = 0.5; <span style="color: #BA36A5;">yB0</span> = 0.5; <span style="color: #BA36A5;">yP10</span> = 0.0; <span style="color: #BA36A5;">yP20</span> = 0.0;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">compute mole fractions</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">d</span> = 1 - e1 - e2;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yI</span> = (yI0 - e1 - e2)/d;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yB</span> = (yB0 - e1 - e2)/d;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yP1</span> = (yP10 + e1)/d;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">yP2</span> = (yP20 + e2)/d;
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">G</span> = (-(e1 * np.log(K1) + e2 * np.log(K2)) +
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>d * np.log(P) + yI * d * np.log(yI) +
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>yB * d * np.log(yB) + yP1 * d * np.log(yP1) + yP2 * d * np.log(yP2))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> G


<span style="color: #BA36A5;">a</span> = np.linspace(0.001, 0.5, 100)
<span style="color: #BA36A5;">E1</span>, <span style="color: #BA36A5;">E2</span> = np.meshgrid(a,a)

<span style="color: #BA36A5;">sumE</span> = E1 + E2
<span style="color: #BA36A5;">E1</span>[sumE &gt;= 0.5] = 0.00001
<span style="color: #BA36A5;">E2</span>[sumE &gt;= 0.5] = 0.00001

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now evaluate gibbs</span>
<span style="color: #BA36A5;">G</span> = np.zeros(E1.shape)
<span style="color: #BA36A5;">m</span>,<span style="color: #BA36A5;">n</span> = E1.shape

<span style="color: #BA36A5;">G</span> = gibbs([E1, E2])

<span style="color: #BA36A5;">CS</span> = plt.contour(E1, E2, G, levels=np.linspace(G.<span style="color: #006FE0;">min</span>(),G.<span style="color: #006FE0;">max</span>(),100))
plt.xlabel(<span style="color: #008000;">'$\epsilon_1$'</span>)
plt.ylabel(<span style="color: #008000;">'$\epsilon_2$'</span>)
plt.colorbar()

plt.plot([0.13336503],  [0.35066486], <span style="color: #008000;">'ro'</span>)

plt.savefig(<span style="color: #008000;">'images/gibbs-minimization-1.png'</span>)
plt.savefig(<span style="color: #008000;">'images/gibbs-minimization-1.svg'</span>)
plt.show()
</pre>
</div>


<div id="org9f90672" class="figure">
<p><img src="pycse-chapters/images/gibbs-minimization-1.png" alt="gibbs-minimization-1.png" />
</p>
</div>

<p>
You can see we found the minimum. We can compute the mole fractions pretty easily.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">e1</span> = X[0];
<span style="color: #BA36A5;">e2</span> = X[1];

<span style="color: #BA36A5;">yI0</span> = 0.5; <span style="color: #BA36A5;">yB0</span> = 0.5; <span style="color: #BA36A5;">yP10</span> = 0; <span style="color: #BA36A5;">yP20</span> = 0; <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">initial mole fractions</span>

<span style="color: #BA36A5;">d</span> = 1 - e1 - e2;
<span style="color: #BA36A5;">yI</span> = (yI0 - e1 - e2) / d
<span style="color: #BA36A5;">yB</span> = (yB0 - e1 - e2) / d
<span style="color: #BA36A5;">yP1</span> = (yP10 + e1) / d
<span style="color: #BA36A5;">yP2</span> = (yP20 + e2) / d

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'y_I = {0:1.3f} y_B = {1:1.3f} y_P1 = {2:1.3f} y_P2 = {3:1.3f}'</span>.<span style="color: #006FE0;">format</span>(yI,yB,yP1,yP2))
</pre>
</div>
</div>

<div id="outline-container-org4487730" class="outline-4">
<h4 id="org4487730"><span class="section-number-4">14.8.1.</span> summary</h4>
<div class="outline-text-4" id="text-14-8-1">
<p>
I found setting up the constraints in this example to be more confusing than the Matlab syntax.
</p>
</div>
</div>
</div>
<div id="outline-container-org1ebb54d" class="outline-3">
<h3 id="org1ebb54d"><span class="section-number-3">14.9.</span> Using constrained optimization to find the amount of each phase present</h3>
<div class="outline-text-3" id="text-14-9">
<p>
The problem we solve here is that we have several compounds containing Ni and Al, and a bulk mixture of a particular composition of Ni and Al. We want to know which mixture of phases will minimize the total energy. The tricky part is that the optimization is constrained because the mixture of phases must have the overall stoichiometry we want.  We formulate the problem like this.
</p>

<p>
Basically, we want to minimize the function \(E = \sum w_i E_i\), where \(w_i\) is the mass of phase \(i\), and \(E_i\) is the energy per unit mass of phase \(i\). There are some constraints to ensure conservation of mass. Let us consider the following compounds: Al, NiAl, Ni3Al, and Ni, and consider a case where the bulk composition of our alloy is 93.8% Ni and balance Al. We want to know which phases are present, and in what proportions. There are some subtleties in considering the formula and molecular weight of an alloy. We consider the formula with each species amount normalized so the fractions all add up to one. For example, Ni_3Al is represented as Ni_{0.75}Al_{0.25}, and the molecular weight is computed as 0.75*MW_{Ni} + 0.25*MW_{Al}.
</p>

<p>
We use scipy.optimize.fmin_slsqp to solve this problem, and define two equality constraint functions, and the bounds on each weight fraction.
</p>

<p>
Note: the energies in this example were computed by density functional theory at 0K.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_slsqp

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">these are atomic masses of each species</span>
<span style="color: #BA36A5;">Ni</span> = 58.693
<span style="color: #BA36A5;">Al</span> = 26.982

<span style="color: #BA36A5;">COMPOSITIONS</span> = [<span style="color: #008000;">'Al'</span>, <span style="color: #008000;">'NiAl'</span>,              <span style="color: #008000;">'Ni3Al'</span>,  <span style="color: #008000;">'Ni'</span>]
<span style="color: #BA36A5;">MW</span> = np.array(  [Al,  (Ni + Al)/2.0, (3 * Ni + Al)/4.0, Ni])

<span style="color: #BA36A5;">xNi</span> = np.array([0.0, 0.5, 0.75, 1.0])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mole fraction of nickel in each compd</span>
<span style="color: #BA36A5;">WNi</span> = xNi * Ni / MW                      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">weight fraction of Ni in each cmpd</span>

<span style="color: #BA36A5;">ENERGIES</span> = np.array([0.0, -0.7, -0.5, 0.0])

<span style="color: #BA36A5;">BNi</span> = 0.938

<span style="color: #0000FF;">def</span> <span style="color: #006699;">G</span>(w):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'function to minimize. w is a vector of weight fractions, ENERGIES is defined above.'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.dot(w, ENERGIES)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ec1</span>(w):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'conservation of Ni constraint'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> BNi - np.dot(w, WNi)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ec2</span>(w):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'weight fractions sum to one constraint'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1 - np.<span style="color: #006FE0;">sum</span>(w)

<span style="color: #BA36A5;">w0</span> = np.array([0.0, 0.0, 0.5, 0.5]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">guess weight fractions</span>

<span style="color: #BA36A5;">y</span> = fmin_slsqp(G,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  w0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  eqcons=[ec1, ec2],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  bounds=[(0,1)]*<span style="color: #006FE0;">len</span>(w0))

<span style="color: #0000FF;">for</span> ci, wi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(COMPOSITIONS, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:8s} {1:+8.2%}'</span>.<span style="color: #006FE0;">format</span>(ci, wi))
</pre>
</div>

<p>
So, the sample will be about 47% <i>by weight</i> of Ni3Al, and 53% <i>by weight</i> of pure Ni.
</p>

<p>
It may be convenient to formulate this in terms of moles.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fmin_slsqp

<span style="color: #BA36A5;">COMPOSITIONS</span> = [<span style="color: #008000;">'Al'</span>, <span style="color: #008000;">'NiAl'</span>, <span style="color: #008000;">'Ni3Al'</span>,  <span style="color: #008000;">'Ni'</span>]
<span style="color: #BA36A5;">xNi</span> = np.array([0.0, 0.5, 0.75, 1.0])   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">define this in mole fractions</span>

<span style="color: #BA36A5;">ENERGIES</span> = np.array([0.0, -0.7, -0.5, 0.0])

<span style="color: #BA36A5;">xNiB</span> = 0.875  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">bulk Ni composition</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">G</span>(n):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'function to minimize'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.dot(n, ENERGIES)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ec1</span>(n):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'conservation of Ni'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ntot</span> = np.<span style="color: #006FE0;">sum</span>(n)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> (Ntot * xNiB) - np.dot(n,  xNi)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ec2</span>(n):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'mole fractions sum to one'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1 - np.<span style="color: #006FE0;">sum</span>(n)

<span style="color: #BA36A5;">n0</span> = np.array([0.0, 0.0, 0.45, 0.55]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial guess of mole fractions</span>

<span style="color: #BA36A5;">y</span> = fmin_slsqp(G,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  n0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  eqcons=[ec1, ec2],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  bounds=[(0, 1)]*(<span style="color: #006FE0;">len</span>(n0)))

<span style="color: #0000FF;">for</span> ci, xi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(COMPOSITIONS, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{0:8s} {1:+8.2%}'</span>.<span style="color: #006FE0;">format</span>(ci, xi))
</pre>
</div>

<p>
This means we have a 1:1 molar ratio of Ni and Ni_{0.75}Al_{0.25}. That works out to the overall bulk composition in this particular problem.
</p>

<p>
Let us verify that these two approaches really lead to the same conclusions. On a weight basis we estimate 53.3%wt Ni and 46.7%wt Ni3Al, whereas we predict an equimolar mixture of the two phases. Below we compute the mole fraction of Ni in each case.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">these are atomic masses of each species</span>
<span style="color: #BA36A5;">Ni</span> = 58.693
<span style="color: #BA36A5;">Al</span> = 26.982

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Molar case</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1 mol Ni + 1 mol Ni_{0.75}Al_{0.25}</span>
<span style="color: #BA36A5;">N1</span> = 1.0; <span style="color: #BA36A5;">N2</span> = 1.0
<span style="color: #BA36A5;">mol_Ni</span> = 1.0 * N1 + 0.75 * N2
<span style="color: #BA36A5;">xNi</span> = mol_Ni / (N1 + N2)
<span style="color: #0000FF;">print</span>(xNi)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Mass case</span>
<span style="color: #BA36A5;">M1</span> = 0.533; <span style="color: #BA36A5;">M2</span> = 0.467
<span style="color: #BA36A5;">MW1</span> = Ni; <span style="color: #BA36A5;">MW2</span> = 0.75*Ni + 0.25*Al

<span style="color: #BA36A5;">xNi2</span> = (1.0 * M1/MW1 + 0.75 * M2 / MW2) / (M1/MW1 + M2/MW2)
<span style="color: #0000FF;">print</span>(xNi2)
</pre>
</div>

<p>
You can see the overall mole fraction of Ni is practically the same in each case.
</p>
</div>
</div>

<div id="outline-container-orgf6f26b1" class="outline-3">
<h3 id="orgf6f26b1"><span class="section-number-3">14.10.</span> Conservation of mass in chemical reactions</h3>
<div class="outline-text-3" id="text-14-10">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/18/conservation-of-mass-in-chemical-reactions/">Matlab post</a>
</p>

<p>
Atoms cannot be destroyed in non-nuclear chemical reactions, hence it follows that the same number of atoms entering a reactor must also leave the reactor. The atoms may leave the reactor in a different molecular configuration due to the reaction, but the total mass leaving the reactor must be the same. Here we look at a few ways to show this.
</p>

<p>
We consider the water gas shift reaction : \(CO + H_2O \rightleftharpoons H_2 + CO_2\). We can illustrate the conservation of mass with the following equation: \(\bf{\nu}\bf{M}=\bf{0}\). Where \(\bf{\nu}\) is the stoichiometric coefficient vector and \(\bf{M}\) is a column vector of molecular weights. For simplicity, we use pure isotope molecular weights, and not the isotope-weighted molecular weights. This equation simply examines the mass on the right side of the equation and the mass on left side of the equation.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">nu</span> = [-1, -1, 1, 1];
<span style="color: #BA36A5;">M</span> = [28, 18, 2, 44];
<span style="color: #0000FF;">print</span>(np.dot(nu, M))
</pre>
</div>

<p>
You can see that sum of the stoichiometric coefficients times molecular weights is zero. In other words a CO and H_2O have the same mass as H_2 and CO_2.
</p>

<p>
For any balanced chemical equation, there are the same number of each kind of atom on each side of the equation. Since the mass of each atom is unchanged with reaction, that means the mass of all the species that are reactants must equal the mass of all the species that are products! Here we look at the number of C, O, and H on each side of the reaction. Now if we add the mass of atoms in the reactants and products, it should sum to zero (since we used the negative sign for stoichiometric coefficients of reactants).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">C   O   H</span>
<span style="color: #BA36A5;">reactants</span> = [-1, -2, -2]
<span style="color: #BA36A5;">products</span>  = [ 1,  2,  2]

<span style="color: #BA36A5;">atomic_masses</span> = [12.011, 15.999, 1.0079]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">atomic masses</span>

<span style="color: #0000FF;">print</span>(np.dot(reactants, atomic_masses) + np.dot(products, atomic_masses))
</pre>
</div>

<p>
That is all there is to mass conservation with reactions. Nothing changes if there are lots of reactions, as long as each reaction is properly balanced, and none of them are nuclear reactions!
</p>
</div>
</div>

<div id="outline-container-org3790393" class="outline-3">
<h3 id="org3790393"><span class="section-number-3">14.11.</span> Numerically calculating an effectiveness factor for a porous catalyst bead</h3>
<div class="outline-text-3" id="text-14-11">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/18/numerically-calculating-an-effectiveness-factor-for-a-porous-catalyst-bead/">Matlab post</a>
</p>

<p>
If reaction rates are fast compared to diffusion in a porous catalyst pellet, then the observed kinetics will appear to be slower than they really are because not all of the catalyst surface area will be effectively used. For example, the reactants may all be consumed in the near surface area of a catalyst bead, and the inside of the bead will be unutilized because no reactants can get in due to the high reaction rates.
</p>

<p>
References: Ch 12. Elements of Chemical Reaction Engineering, Fogler, 4th edition.
</p>

<p>
A mole balance on the particle volume in spherical coordinates with a first order reaction leads to: \(\frac{d^2Ca}{dr^2} + \frac{2}{r}\frac{dCa}{dr}-\frac{k}{D_e}C_A=0\) with boundary conditions \(C_A(R) = C_{As}\) and \(\frac{dCa}{dr}=0\) at \(r=0\). We convert this equation to a system of first order ODEs by letting \(W_A=\frac{dCa}{dr}\). Then, our two equations become:
</p>

<p>
\(\frac{dCa}{dr} = W_A\)
</p>

<p>
and
</p>

<p>
\(\frac{dW_A}{dr} = -\frac{2}{r} W_A + \frac{k}{D_E} C_A\)
</p>

<p>
We have a condition of no flux (\(W_A=0\)) at r=0 and Ca(R) = CAs, which makes this a boundary value problem. We use the shooting method here, and guess what Ca(0) is and iterate the guess to get Ca(R) = CAs.
</p>

<p>
The value of the second differential equation at r=0 is tricky because at this place we have a 0/0 term. We use L'Hopital's rule to evaluate it. The derivative of the top is \(\frac{dW_A}{dr}\) and the derivative of the bottom is 1. So, we have
\(\frac{dW_A}{dr} = -2\frac{dW_A}{dr} + \frac{k}{D_E} C_A\)
</p>

<p>
Which leads to:
</p>

<p>
\(3 \frac{dW_A}{dr} =  \frac{k}{D_E} C_A\)
</p>

<p>
or \(\frac{dW_A}{dr} =  \frac{3k}{D_E} C_A\) at \(r=0\).
</p>

<p>
Finally, we implement the equations in Python and solve.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">De</span> = 0.1    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">diffusivity cm^2/s</span>
<span style="color: #BA36A5;">R</span> = 0.5    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">particle radius, cm</span>
<span style="color: #BA36A5;">k</span> = 6.4    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate constant (1/s)</span>
<span style="color: #BA36A5;">CAs</span> = 0.2   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">concentration of A at outer radius of particle (mol/L)</span>


<span style="color: #0000FF;">def</span> <span style="color: #006699;">ode</span>(Y, r):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Wa</span> = Y[0]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">molar rate of delivery of A to surface of particle</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ca</span> = Y[1]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">concentration of A in the particle at r</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this solves the singularity at r = 0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> r == 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   dWadr = k / 3.0 * De * Ca
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   dWadr = -2 * Wa / r + k / De * Ca
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   dCadr = Wa
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [dWadr, dCadr]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Initial conditions</span>
Ca0 = 0.029315  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Ca(0) (mol/L) guessed to satisfy Ca(R) = CAs</span>
Wa0 = 0         <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">no flux at r=0 (mol/m^2/s)</span>

rspan = np.linspace(0, R, 500)

Y = odeint(ode, [Wa0, Ca0], rspan)

Ca = Y[:, 1]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">here we check that Ca(R) = Cas</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'At r={0} Ca={1}'</span>.<span style="color: #006FE0;">format</span>(rspan[-1], Ca[-1]))

plt.plot(rspan, Ca)
plt.xlabel(<span style="color: #008000;">'Particle radius'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$'</span>)
plt.savefig(<span style="color: #008000;">'images/effectiveness-factor.png'</span>)

r = rspan
eta_numerical = (np.trapz(k * Ca * 4 * np.pi * (r**2), r)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>/ np.trapz(k * CAs * 4 * np.pi * (r**2), r))

<span style="color: #0000FF;">print</span>(eta_numerical)

phi = R * np.sqrt(k / De)
eta_analytical = (3 / phi**2) * (phi * (1.0 / np.tanh(phi)) - 1)
<span style="color: #0000FF;">print</span>(eta_analytical)
</pre>
</div>


<div id="orgdc6a000" class="figure">
<p><img src="pycse-chapters/images/effectiveness-factor.png" alt="effectiveness-factor.png" />
</p>
</div>

<p>
You can see the concentration of A inside the particle is significantly lower than outside the particle. That is because it is reacting away faster than it can diffuse into the particle. Hence, the overall reaction rate in the particle is lower than it would be without the diffusion limit.
</p>

<p>
The effectiveness factor is the ratio of the actual reaction rate in the particle with diffusion limitation to the ideal rate in the particle if there was no concentration gradient:
</p>

<p>
\[\eta = \frac{\int_0^R k'' a C_A(r) 4 \pi r^2 dr}{\int_0^R k'' a C_{As} 4 \pi r^2 dr}\]
</p>

<p>
We will evaluate this numerically from our solution and compare it to the analytical solution. The results are in good agreement, and you can make the numerical estimate better by increasing the number of points in the solution so that the numerical integration is more accurate.
</p>

<p>
Why go through the numerical solution when an analytical solution exists? The analytical solution here is only good for 1st order kinetics in a sphere. What would you do for a complicated rate law? You might be able to find some limiting conditions where the analytical equation above is relevant, and if you are lucky, they are appropriate for your problem. If not, it is a good thing you can figure this out numerically!
</p>

<p>
Thanks to Radovan Omorjan for helping me figure out the ODE at r=0!
</p>
</div>
</div>

<div id="outline-container-org49d256d" class="outline-3">
<h3 id="org49d256d"><span class="section-number-3">14.12.</span> Computing a pipe diameter</h3>
<div class="outline-text-3" id="text-14-12">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/27/compute-pipe-diameter/">Matlab post</a>
A heat exchanger must handle 2.5 L/s of water through a smooth pipe with length of 100 m. The pressure drop cannot exceed 103 kPa at 25 degC. Compute the minimum pipe diameter required for this application.
</p>

<p>
Adapted from problem 8.8 in Problem solving in chemical and Biochemical Engineering with Polymath, Excel, and Matlab. page 303.
</p>

<p>
We need to estimate the Fanning friction factor for these conditions so we can estimate the frictional losses that result in a pressure drop for a uniform, circular pipe. The frictional forces are given by \(F_f = 2f_F \frac{\Delta L v^2}{D}\), and the corresponding pressure drop is given by \(\Delta P = \rho F_f\). In these equations, \(\rho\) is the fluid density, \(v\) is the fluid velocity, \(D\) is the pipe diameter, and \(f_F\) is the Fanning friction factor. The average fluid velocity is given by \(v = \frac{q}{\pi D^2/4}\).
</p>

<p>
For laminar flow, we estimate \(f_F = 16/Re\), which is a linear equation, and for turbulent flow (\(Re > 2100\)) we have the implicit equation \(\frac{1}{\sqrt{f_F}}=4.0 \log(Re \sqrt{f_F})-0.4\). Of course, we define \(Re = \frac{D v\rho}{\mu}\) where \(\mu\) is the viscosity of the fluid.
</p>

<p>
It is known that \(\rho(T) = 46.048 + 9.418 T -0.0329 T^2 +4.882\times10^{-5}-2.895\times10^{-8}T^4\) and \(\mu = \exp\left({-10.547 + \frac{541.69}{T-144.53}}\right)\) where \(\rho\) is in kg/m^3 and \(\mu\) is in kg/(m*s).
</p>

<p>
The aim is to find \(D\) that solves: \(\Delta p = \rho 2 f_F \frac{\Delta L v^2}{D}\). This is a nonlinear equation in \(D\), since D affects the fluid velocity, the Re, and the Fanning friction factor. Here is the solution
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">T</span> = 25 + 273.15
<span style="color: #BA36A5;">Q</span> = 2.5e-3       <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">m^3/s</span>
<span style="color: #BA36A5;">deltaP</span> = 103000  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Pa</span>
<span style="color: #BA36A5;">deltaL</span> = 100     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">m</span>

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">Note these correlations expect dimensionless T, where the magnitude</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">of T is in K</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">rho</span>(T):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 46.048 + 9.418 * T -0.0329 * T**2 +4.882e-5 * T**3 - 2.895e-8 * T**4

<span style="color: #0000FF;">def</span> <span style="color: #006699;">mu</span>(T):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.exp(-10.547 + 541.69 / (T - 144.53))

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fanning_friction_factor_</span>(Re):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> Re &lt; 2100:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">raise</span> <span style="color: #6434A3;">Exception</span>(<span style="color: #008000;">'Flow is probably not turbulent, so this correlation is not appropriate.'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">solve the Nikuradse correlation to get the friction factor</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">fz</span>(f): <span style="color: #0000FF;">return</span> 1.0/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sol</span>, = fsolve(fz, 0.01)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> sol

<span style="color: #BA36A5;">fanning_friction_factor</span> = np.vectorize(fanning_friction_factor_)

<span style="color: #BA36A5;">Re</span> = np.linspace(2200, 9000)
<span style="color: #BA36A5;">f</span> = fanning_friction_factor(Re)

plt.plot(Re, f)
plt.xlabel(<span style="color: #008000;">'Re'</span>)
plt.ylabel(<span style="color: #008000;">'fanning friction factor'</span>)
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">You can see why we use 0.01 as an initial guess for solving for the</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Fanning friction factor; it falls in the middle of ranges possible</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">for these Re numbers.</span>
plt.savefig(<span style="color: #008000;">'images/pipe-diameter-1.png'</span>)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(D):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">v</span> = Q / (np.pi * D**2 / 4)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Re</span> = D * v * rho(T) / mu(T)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">fF</span> = fanning_friction_factor(Re)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> deltaP - 2 * fF * rho(T) * deltaL * v**2 / D

<span style="color: #BA36A5;">D</span>, = fsolve(objective, 0.04)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The minimum pipe diameter is {0} m\n'</span>.<span style="color: #006FE0;">format</span>(D))
</pre>
</div>


<p>
Any pipe diameter smaller than that value will result in a larger pressure drop at the same volumetric flow rate, or a smaller volumetric flowrate at the same pressure drop. Either way, it will not meet the design specification.
</p>
</div>
</div>

<div id="outline-container-org0e35d49" class="outline-3">
<h3 id="org0e35d49"><span class="section-number-3">14.13.</span> Reading parameter database text files in python</h3>
<div class="outline-text-3" id="text-14-13">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/10/reading-parameter-database-text-files-in-matlab/">Matlab post</a>
</p>

<p>
The datafile at <a href="http://terpconnect.umd.edu/~nsw/ench250/antoine.dat">http://terpconnect.umd.edu/~nsw/ench250/antoine.dat</a> (dead link) contains data that can be used to estimate the vapor pressure of about 700 pure compounds using the Antoine equation
</p>

<p>
The data file has the following contents:
</p>

<pre class="example" id="org8bb748a">
Antoine Coefficients
  log(P) = A-B/(T+C) where P is in mmHg and T is in Celsius
Source of data: Yaws and Yang (Yaws, C.  L.  and Yang, H.  C.,
"To estimate vapor pressure easily. antoine coefficients relate vapor pressure to temperature for almost 700 major organic compounds", Hydrocarbon Processing, 68(10), p65-68, 1989.

ID  formula  compound name                  A       B       C     Tmin Tmax ??    ?
-----------------------------------------------------------------------------------
  1 CCL4     carbon-tetrachloride        6.89410 1219.580 227.170  -20  101 Y2    0
  2 CCL3F    trichlorofluoromethane      6.88430 1043.010 236.860  -33   27 Y2    0
  3 CCL2F2   dichlorodifluoromethane     6.68619  782.072 235.377 -119  -30 Y6    0
</pre>

<p>
To use this data, you find the line that has the compound you want, and read off the data. You could do that manually for each component you want but that is tedious, and error prone. Today we will see how to retrieve the file, then read the data into python to create a database we can use to store and retrieve the data.
</p>

<p>
We will use the data to find the temperature at which the vapor pressure of acetone is 400 mmHg.
</p>

<p>
We use numpy.loadtxt to read the file, and tell the function the format of each column. This creates a special kind of record array which we can access data by field name.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">data</span> = np.loadtxt(<span style="color: #008000;">'data/antoine_data.dat'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> dtype=[(<span style="color: #008000;">'id'</span>, np.<span style="color: #006FE0;">int</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'formula'</span>, <span style="color: #008000;">'S8'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'name'</span>, <span style="color: #008000;">'S28'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'A'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'B'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'C'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'Tmin'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'Tmax'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'??'</span>, <span style="color: #008000;">'S4'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'?'</span>, <span style="color: #008000;">'S4'</span>)],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> skiprows=7)

names = data[<span style="color: #008000;">'name'</span>]

acetone = data[names == <span style="color: #008000;">'acetone'</span>]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">for readability we unpack the array into variables</span>
<span style="color: #006FE0;">id</span>, <span style="color: #BA36A5;">formula</span>, <span style="color: #BA36A5;">name</span>, <span style="color: #BA36A5;">A</span>, <span style="color: #BA36A5;">B</span>, <span style="color: #BA36A5;">C</span>, <span style="color: #BA36A5;">Tmin</span>, <span style="color: #BA36A5;">Tmax</span>, <span style="color: #BA36A5;">u1</span>, <span style="color: #BA36A5;">u2</span> = acetone

T = np.linspace(Tmin, Tmax)
P = 10**(A - B / ( T + C))
plt.plot(T, P)
plt.xlabel(<span style="color: #008000;">'T ($^\circ$C)'</span>)
plt.ylabel(<span style="color: #008000;">'P$_{vap}$ (mmHg)'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Find T at which Pvap = 400 mmHg</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">from our graph we might guess T ~ 40 ^{\circ}C</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(T):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 400 - 10**(A - B / (T + C))

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #BA36A5;">Tsol</span>, = fsolve(objective, 40)
<span style="color: #0000FF;">print</span>(Tsol)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The vapor pressure is 400 mmHg at T = {0:1.1f} degC'</span>.<span style="color: #006FE0;">format</span>(Tsol))

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">Plot CRC data http://en.wikipedia.org/wiki/Acetone_%28data_page%29#Vapor_pressure_of_liquid</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">We only include the data for the range where the Antoine fit is valid.</span>

Tcrc  = [-59.4,         -31.1,  -9.4,   7.7,    39.5,   56.5]
Pcrc = [        1,      10,     40,     100,    400,    760]

plt.plot(Tcrc, Pcrc, <span style="color: #008000;">'bo'</span>)
plt.legend([<span style="color: #008000;">'Antoine'</span>,<span style="color: #008000;">'CRC Handbook'</span>], loc=<span style="color: #008000;">'best'</span>)
plt.savefig(<span style="color: #008000;">'images/antoine-2.png'</span>)
</pre>
</div>


<div id="orgdb5182a" class="figure">
<p><img src="pycse-chapters/images/antoine-1.png" alt="antoine-1.png" />
</p>
</div>

<p>
This result is close to the value reported <a href="http://en.wikipedia.org/wiki/Acetone_%28data_page%29#Vapor_pressure_of_liquid"> here</a> (39.5 degC), from the CRC Handbook. The difference is probably that the value reported in the CRC is an actual experimental number.
</p>


<div id="orgd48f64d" class="figure">
<p><img src="pycse-chapters/images/antoine-2.png" alt="antoine-2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgca9627c" class="outline-3">
<h3 id="orgca9627c"><span class="section-number-3">14.14.</span> Calculating a bubble point pressure of a mixture</h3>
<div class="outline-text-3" id="text-14-14">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/15/calculating-a-bubble-point-pressure/">Matlab post</a>
</p>

<p>
Adapted from <a href="http://terpconnect.umd.edu/~nsw/ench250/bubpnt.htm">http://terpconnect.umd.edu/~nsw/ench250/bubpnt.htm</a> (dead link)
</p>

<p>
We previously learned to read a datafile containing lots of Antoine coefficients into a database, and use the coefficients to estimate vapor pressure of a single compound. Here we use those coefficents to compute a bubble point pressure of a mixture.
</p>

<p>
The bubble point is the temperature at which the sum of the component vapor pressures is equal to the the total pressure. This is where a bubble of vapor will first start forming, and the mixture starts to boil.
</p>

<p>
Consider an equimolar mixture of benzene, toluene, chloroform, acetone and methanol. Compute the bubble point at 760 mmHg, and the gas phase composition. The gas phase composition is given by: \(y_i = x_i*P_i/P_T\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">load our thermodynamic data</span>
<span style="color: #BA36A5;">data</span> = np.loadtxt(<span style="color: #008000;">'data/antoine_data.dat'</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> dtype=[(<span style="color: #008000;">'id'</span>, np.<span style="color: #006FE0;">int</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'formula'</span>, <span style="color: #008000;">'S8'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'name'</span>, <span style="color: #008000;">'S28'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'A'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'B'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'C'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'Tmin'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'Tmax'</span>, np.<span style="color: #006FE0;">float</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'??'</span>, <span style="color: #008000;">'S4'</span>),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>(<span style="color: #008000;">'?'</span>, <span style="color: #008000;">'S4'</span>)],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> skiprows=7)

compounds = [<span style="color: #008000;">'benzene'</span>, <span style="color: #008000;">'toluene'</span>, <span style="color: #008000;">'chloroform'</span>, <span style="color: #008000;">'acetone'</span>, <span style="color: #008000;">'methanol'</span>]

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">extract the data we want</span>
A = np.array([data[data[<span style="color: #008000;">'name'</span>] == x.encode(encoding=<span style="color: #008000;">'UTF-8'</span>)][<span style="color: #008000;">'A'</span>][0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> compounds])
B = np.array([data[data[<span style="color: #008000;">'name'</span>] == x.encode(encoding=<span style="color: #008000;">'UTF-8'</span>)][<span style="color: #008000;">'B'</span>][0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> compounds])
C = np.array([data[data[<span style="color: #008000;">'name'</span>] == x.encode(encoding=<span style="color: #008000;">'UTF-8'</span>)][<span style="color: #008000;">'C'</span>][0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> compounds])
Tmin = np.array([data[data[<span style="color: #008000;">'name'</span>] == x.encode(encoding=<span style="color: #008000;">'UTF-8'</span>)][<span style="color: #008000;">'Tmin'</span>][0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> compounds])
Tmax = np.array([data[data[<span style="color: #008000;">'name'</span>] == x.encode(encoding=<span style="color: #008000;">'UTF-8'</span>)][<span style="color: #008000;">'Tmax'</span>][0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> compounds])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we have an equimolar mixture</span>
x = np.array([0.2, 0.2, 0.2, 0.2, 0.2])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Given a T, we can compute the pressure of each species like this:</span>

T = 67 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">degC</span>
P = 10**(A - B / (T + C))
<span style="color: #0000FF;">print</span>(P)
<span style="color: #0000FF;">print</span>(np.dot(x, P))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">total mole-fraction weighted pressure</span>

Tguess = 67
Ptotal = 760

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(T):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   P = 10**(A - B / (T + C))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Ptotal - np.dot(x, P)

<span style="color: #BA36A5;">Tbubble</span>, = fsolve(func, Tguess)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The bubble point is {0:1.2f} degC'</span>.<span style="color: #006FE0;">format</span>(Tbubble))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">double check answer is in a valid T range</span>
<span style="color: #0000FF;">if</span> np.<span style="color: #006FE0;">any</span>(Tbubble &lt; Tmin) <span style="color: #0000FF;">or</span> np.<span style="color: #006FE0;">any</span>(Tbubble &gt; Tmax):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'T_bubble is out of range!'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print gas phase composition</span>
y = x * 10**(A - B / (Tbubble + C))/Ptotal

<span style="color: #0000FF;">for</span> cmpd, yi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(compounds, y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'y_{0:&lt;10s} = {1:1.3f}'</span>.<span style="color: #006FE0;">format</span>(cmpd, yi))
</pre>
</div>
</div>
</div>

<div id="outline-container-org43c308a" class="outline-3">
<h3 id="org43c308a"><span class="section-number-3">14.15.</span> The equal area method for the van der Waals equation</h3>
<div class="outline-text-3" id="text-14-15">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/11/the-equal-area-method-for-the-van-der-waals-equation/">Matlab post</a>
</p>

<p>
When a gas is below its Tc the van der Waal equation oscillates. In the portion of the isotherm where \(\partial P_R/\partial V_r > 0\), the isotherm fails to describe real materials, which phase separate into a liquid and gas in this region.
</p>

<p>
Maxwell proposed to replace this region by a flat line, where the area above and below the curves are equal. Today, we examine how to identify where that line should be.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">Tr</span> = 0.9 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">A Tr below Tc:  Tr = T/Tc</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">analytical equation for Pr. This is the reduced form of the van der Waal</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">equation.</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">Prfh</span>(Vr):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span>  8.0 / 3.0 * Tr / (Vr - 1.0 / 3.0) - 3.0 / (Vr**2)

<span style="color: #BA36A5;">Vr</span> = np.linspace(0.5, 4, 100)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">vector of reduced volume</span>
<span style="color: #BA36A5;">Pr</span> = Prfh(Vr)                 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">vector of reduced pressure</span>

plt.clf()
plt.plot(Vr,Pr)
plt.ylim([0, 2])
plt.xlabel(<span style="color: #008000;">'$V_R$'</span>)
plt.ylabel(<span style="color: #008000;">'$P_R$'</span>)
plt.savefig(<span style="color: #008000;">'images/maxwell-eq-area-1.png'</span>)
</pre>
</div>


<div id="orgb7d79ea" class="figure">
<p><img src="pycse-chapters/images/maxwell-eq-area-1.png" alt="maxwell-eq-area-1.png" />
</p>
</div>

<p>
The idea is to pick a Pr and draw a line through the EOS. We want the areas between the line and EOS to be equal on each side of the middle intersection. Let us draw a line on the figure at y = 0.65.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">y</span> = 0.65

plt.plot([0.5, 4.0], [y, y], <span style="color: #008000;">'k--'</span>)
plt.savefig(<span style="color: #008000;">'images/maxwell-eq-area-2.png'</span>)
</pre>
</div>


<div id="org82d487c" class="figure">
<p><img src="pycse-chapters/images/maxwell-eq-area-2.png" alt="maxwell-eq-area-2.png" />
</p>
</div>

<p>
To find the areas, we need to know where the intersection of the vdW eqn with the horizontal line. This is the same as asking what are the roots of the vdW equation at that Pr. We need all three intersections so we can integrate from the first root to the middle root, and then the middle root to the third root. We take advantage of the polynomial nature of the vdW equation, which allows us to use the roots command to get all the roots at once. The polynomial is \(V_R^3 - \frac{1}{3}(1+8 T_R/P_R) + 3/P_R - 1/P_R = 0\). We use the coefficients t0 get the roots like this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">vdWp</span> = [1.0, -1. / 3.0 * (1.0 + 8.0 * Tr / y), 3.0 / y, - 1.0 / y]
<span style="color: #BA36A5;">v</span> = np.roots(vdWp)
v.sort()
<span style="color: #0000FF;">print</span>(v)

plt.plot(v[0], y, <span style="color: #008000;">'bo'</span>, v[1], y, <span style="color: #008000;">'bo'</span>, v[2], y, <span style="color: #008000;">'bo'</span>)
plt.savefig(<span style="color: #008000;">'images/maxwell-eq-area-3.png'</span>)
</pre>
</div>


<div id="org0f830c9" class="figure">
<p><img src="pycse-chapters/images/maxwell-eq-area-3.png" alt="maxwell-eq-area-3.png" />
</p>
</div>
</div>

<div id="outline-container-org7c44836" class="outline-4">
<h4 id="org7c44836"><span class="section-number-4">14.15.1.</span> Compute areas</h4>
<div class="outline-text-4" id="text-14-15-1">
<p>
for A1, we need the area under the line minus the area under the vdW curve. That is the area between the curves. For A2, we want the area under the vdW curve minus the area under the line. The area under the line between root 2 and root 1 is just the width (root2 - root1)*y
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #BA36A5;">A1</span>, <span style="color: #BA36A5;">e1</span> = (v[1] - v[0]) * y - quad(Prfh,  v[0], v[1])
<span style="color: #BA36A5;">A2</span>, <span style="color: #BA36A5;">e2</span> = quad(Prfh, v[1], v[2]) - (v[2] - v[1])* y

<span style="color: #0000FF;">print</span>(A1, A2)
<span style="color: #0000FF;">print</span>(e1, e2)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">interesting these look so large</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">equal_area</span>(y):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Tr</span> = 0.9
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">vdWp</span> = [1, -1.0 / 3 * ( 1.0 + 8.0 * Tr / y), 3.0 / y,  -1.0 / y]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">v</span> = np.roots(vdWp)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   v.sort()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">A1</span> = (v[1] - v[0]) * y - quad(Prfh, v[0], v[1])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">A2</span> = quad(Prfh, v[1], v[2]) - (v[2] - v[1]) * y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span>  A1 - A2

<span style="color: #BA36A5;">y_eq</span>, = fsolve(equal_area, 0.65)
<span style="color: #0000FF;">print</span>(y_eq)

<span style="color: #BA36A5;">Tr</span> = 0.9
<span style="color: #BA36A5;">vdWp</span> = [1, -1.0 / 3 * ( 1.0 + 8.0 * Tr / y_eq), 3.0 / y_eq,  -1.0 / y_eq]
<span style="color: #BA36A5;">v</span> = np.roots(vdWp)
v.sort()

<span style="color: #BA36A5;">A1</span>, <span style="color: #BA36A5;">e1</span> = (v[1] - v[0]) * y_eq - quad(Prfh,  v[0], v[1])
<span style="color: #BA36A5;">A2</span>, <span style="color: #BA36A5;">e2</span> = quad(Prfh, v[1], v[2]) - (v[2] - v[1]) * y_eq

<span style="color: #0000FF;">print</span>(A1, A2)
</pre>
</div>

<p>
Now let us plot the equal areas and indicate them by shading.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">fig</span> = plt.gcf()
<span style="color: #BA36A5;">ax</span> = fig.add_subplot(111)

ax.plot(Vr,Pr)

<span style="color: #BA36A5;">hline</span> = np.ones(Vr.size) * y_eq

ax.plot(Vr, hline)
ax.fill_between(Vr, hline, Pr, where=(Vr &gt;= v[0]) &amp; (Vr &lt;= v[1]), facecolor=<span style="color: #008000;">'gray'</span>)
ax.fill_between(Vr, hline, Pr, where=(Vr &gt;= v[1]) &amp; (Vr &lt;= v[2]), facecolor=<span style="color: #008000;">'gray'</span>)

plt.text(v[0], 1, <span style="color: #008000;">'A1 = {0}'</span>.<span style="color: #006FE0;">format</span>(A1))
plt.text(v[2], 1, <span style="color: #008000;">'A2 = {0}'</span>.<span style="color: #006FE0;">format</span>(A2))
plt.xlabel(<span style="color: #008000;">'$V_R$'</span>)
plt.ylabel(<span style="color: #008000;">'$P_R$'</span>)
plt.title(<span style="color: #008000;">'$T_R$ = 0.9'</span>)

plt.savefig(<span style="color: #008000;">'images/maxwell-eq-area-4.png'</span>)
plt.savefig(<span style="color: #008000;">'images/maxwell-eq-area-4.svg'</span>)
</pre>
</div>


<div id="org2122fbf" class="figure">
<p><img src="pycse-chapters/images/maxwell-eq-area-4.png" alt="maxwell-eq-area-4.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3892415" class="outline-3">
<h3 id="org3892415"><span class="section-number-3">14.16.</span> Time dependent concentration in a first order reversible reaction in a batch reactor</h3>
<div class="outline-text-3" id="text-14-16">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/07/first-order-reversible-reaction-in-batch-reactor/">Matlab post</a>
</p>

<p>
Given this reaction \(A \rightleftharpoons B\), with these rate laws:
</p>

<p>
forward rate law: \(-r_a = k_1 C_A\)
</p>

<p>
backward rate law: \(-r_b = k_{-1} C_B\)
</p>

<p>
plot the concentration of A vs. time. This example illustrates a set of coupled first order ODES.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">myode</span>(C, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">ra = -k1*Ca</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rb = -k_1*Cb</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">net rate for production of A:  ra - rb</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">net rate for production of B: -ra + rb</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">k1</span> = 1   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1/min;</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">k_1</span> = 0.5   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1/min;</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ca</span> = C[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Cb</span> = C[1]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ra</span> = -k1 * Ca
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">rb</span> = -k_1 * Cb

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dCadt</span> =  ra - rb
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dCbdt</span> = -ra + rb

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dCdt</span> = [dCadt, dCbdt]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> dCdt

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 5)

<span style="color: #BA36A5;">init</span> = [1, 0]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol/L</span>
<span style="color: #BA36A5;">C</span> = odeint(myode, init, tspan)

<span style="color: #BA36A5;">Ca</span> = C[:,0]
<span style="color: #BA36A5;">Cb</span> = C[:,1]

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(tspan, Ca, tspan, Cb)
plt.xlabel(<span style="color: #008000;">'Time (min)'</span>)
plt.ylabel(<span style="color: #008000;">'C (mol/L)'</span>)
plt.legend([<span style="color: #008000;">'$C_A$'</span>, <span style="color: #008000;">'$C_B$'</span>])
plt.savefig(<span style="color: #008000;">'images/reversible-batch.png'</span>)
</pre>
</div>


<div id="orgba06862" class="figure">
<p><img src="pycse-chapters/images/reversible-batch.png" alt="reversible-batch.png" />
</p>
</div>

<p>
That is it. The main difference between this and Matlab is the order of arguments in odeint is different, and the ode function has differently ordered arguments.
</p>
</div>
</div>

<div id="outline-container-org75e20e2" class="outline-3">
<h3 id="org75e20e2"><span class="section-number-3">14.17.</span> Finding equilibrium conversion</h3>
<div class="outline-text-3" id="text-14-17">
<p>
A common problem to solve in reaction engineering is finding the equilibrium conversion.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> A typical problem to solve is the following nonlinear equation:
</p>

<p>
\(1.44 = \frac{X_e^2}{(1-X_e)^2}\)
</p>

<p>
To solve this we create a function:
</p>

<p>
\(f(X_e)=0=1.44 - \frac{X_e^2}{(1-X_e)^2}\)
</p>

<p>
and use a nonlinear solver to find the value of \(X_e\) that makes this function equal to zero. We have to provide an initial guess. Chemical intuition suggests that the solution must be between 0 and 1, and mathematical intuition suggests the solution might be near 0.5 (which would give a ratio near 1).
</p>

<p>
Here is our solution.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Xe):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">z</span> = 1.44 - (Xe**2)/(1-Xe)**2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> z

<span style="color: #BA36A5;">X0</span> = 0.5
<span style="color: #BA36A5;">Xe</span>, = fsolve(func, X0)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The equilibrium conversion is X = {0:1.2f}'</span>.<span style="color: #006FE0;">format</span>(Xe))
</pre>
</div>
</div>
</div>

<div id="outline-container-org475e5eb" class="outline-3">
<h3 id="org475e5eb"><span class="section-number-3">14.18.</span> Integrating a batch reactor design equation</h3>
<div class="outline-text-3" id="text-14-18">
<p>
For a constant volume batch reactor where \(A \rightarrow B\) at a rate of \(-r_A = k C_A^2\), we derive the following design equation for the length of time required to achieve a particular level of conversion :
</p>

<p>
\(t(X) = \frac{1}{k C_{A0}} \int_{X=0}^X \frac{dX}{(1-X)^2}\)
</p>

<p>
if \(k = 10^{-3}\) L/mol/s and \(C_{A0}\) = 1 mol/L, estimate the time to achieve 90% conversion.
</p>

<p>
We could analytically solve the integral and evaluate it, but instead we will numerically evaluate it using scipy.integrate.quad. This function returns two values: the evaluated integral, and an estimate of the absolute error in the answer.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">k</span> = 1.0e-3
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Ca0</span> = 1.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol/L</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1./(k*Ca0)*(1./(1-X)**2)

<span style="color: #BA36A5;">sol</span>, <span style="color: #BA36A5;">abserr</span> = quad(integrand, 0, 0.9)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'t = {0} seconds ({1} hours)'</span>.<span style="color: #006FE0;">format</span>(sol, sol/3600))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Estimated absolute error = {0}'</span>.<span style="color: #006FE0;">format</span>(abserr))
</pre>
</div>


<p>
You can see the estimate error is very small compared to the solution.
</p>
</div>
</div>

<div id="outline-container-org6a22086" class="outline-3">
<h3 id="org6a22086"><span class="section-number-3">14.19.</span> Uncertainty in an integral equation</h3>
<div class="outline-text-3" id="text-14-19">
<p>
In a <a href="http://jkitchin.github.io/blog/2013/01/06/Integrating-a-batch-reactor-design-equation/">previous example</a>, we solved for the time to reach a specific conversion in a batch reactor. However, it is likely there is uncertainty in the rate constant, and possibly in the initial concentration. Here we examine the effects of that uncertainty on the time to reach the desired conversion.
</p>

<p>
To do this we have to write a function that takes arguments with uncertainty, and wrap the function with the uncertainties.wrap decorator. The function must return a single float number (current limitation of the uncertainties package). Then, we simply call the function, and the uncertainties from the inputs will be automatically propagated to the outputs. Let us say there is about 10% uncertainty in the rate constant, and 1% uncertainty in the initial concentration.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad
<span style="color: #0000FF;">import</span> uncertainties <span style="color: #0000FF;">as</span> u

<span style="color: #BA36A5;">k</span> = u.ufloat((1.0e-3, 1.0e-4))
<span style="color: #BA36A5;">Ca0</span> = u.ufloat((1.0, 0.01))<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol/L</span>

<span style="color: #6434A3;">@u.wrap</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(k, Ca0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> 1./(k*Ca0)*(1./(1-X)**2)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">integral</span>, <span style="color: #BA36A5;">abserr</span> = quad(integrand, 0, 0.9)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> integral

<span style="color: #BA36A5;">sol</span> = func(k, Ca0)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'t = {0} seconds ({1} hours)'</span>.<span style="color: #006FE0;">format</span>(sol, sol/3600))
</pre>
</div>

<p>
The result shows about a 10% uncertainty in the time, which is similar to the largest uncertainty in the inputs.  This information should certainly be used in making decisions about how long to actually run the reactor to be sure of reaching the goal. For example, in this case, running the reactor for 3 hours (that is roughly + 2&sigma;) would ensure at a high level of confidence (approximately 95% confidence) that you reach at least 90% conversion.
</p>
</div>
</div>

<div id="outline-container-orgadbd3c0" class="outline-3">
<h3 id="orgadbd3c0"><span class="section-number-3">14.20.</span> Integrating the batch reactor mole balance</h3>
<div class="outline-text-3" id="text-14-20">
<p>
An alternative approach of evaluating an integral is to integrate a differential equation. For the batch reactor, the differential equation that describes conversion as a function of time is:
</p>

<p>
\(\frac{dX}{dt} = -r_A V/N_{A0}\).
</p>

<p>
Given a value of initial concentration, or volume and initial number of moles of A, we can integrate this ODE to find the conversion at some later time. We assume that \(X(t=0)=0\). We will integrate the ODE over a time span of 0 to 10,000 seconds.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">k</span> = 1.0e-3
<span style="color: #BA36A5;">Ca0</span> = 1.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol/L</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(X, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ra</span> = -k * (Ca0 * (1 - X))**2
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -ra / Ca0

<span style="color: #BA36A5;">X0</span> = 0
<span style="color: #BA36A5;">tspan</span> = np.linspace(0,10000)

<span style="color: #BA36A5;">sol</span> = odeint(func, X0, tspan)
plt.plot(tspan,sol)
plt.xlabel(<span style="color: #008000;">'Time (sec)'</span>)
plt.ylabel(<span style="color: #008000;">'Conversion'</span>)
plt.savefig(<span style="color: #008000;">'images/2013-01-06-batch-conversion.png'</span>)
</pre>
</div>


<div id="org3ee74f0" class="figure">
<p><img src="pycse-chapters/images/2013-01-06-batch-conversion.png" alt="2013-01-06-batch-conversion.png" />
</p>
</div>

<p>
You can read off of this figure to find the time required to achieve a particular conversion.
</p>
</div>
</div>

<div id="outline-container-orgcd12cf9" class="outline-3">
<h3 id="orgcd12cf9"><span class="section-number-3">14.21.</span> Plug flow reactor with a pressure drop</h3>
<div class="outline-text-3" id="text-14-21">
<p>
If there is a pressure drop in a plug flow reactor, <sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> there are two equations needed to determine the exit conversion: one for the conversion, and one from the pressure drop.
</p>

\begin{eqnarray}
\frac{dX}{dW} &=& \frac{k'}{F_A0} \left ( \frac{1-X}{1 + \epsilon X} \right) y\\
\frac{dX}{dy} &=& -\frac{\alpha (1 + \epsilon X)}{2y}
\end{eqnarray}

<p>
Here is how to integrate these equations numerically in python.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">kprime</span> = 0.0266
<span style="color: #BA36A5;">Fa0</span> = 1.08
<span style="color: #BA36A5;">alpha</span> = 0.0166
<span style="color: #BA36A5;">epsilon</span> = -0.15

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dFdW</span>(F, W):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'set of ODEs to integrate'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">X</span> = F[0]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">y</span> = F[1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dXdW</span> = kprime / Fa0 * (1-X) / (1 + epsilon*X) * y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">dydW</span> = -alpha * (1 + epsilon * X) / (2 * y)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [dXdW, dydW]

<span style="color: #BA36A5;">Wspan</span> = np.linspace(0,60)
<span style="color: #BA36A5;">X0</span> = 0.0
<span style="color: #BA36A5;">y0</span> = 1.0
<span style="color: #BA36A5;">F0</span> = [X0, y0]
<span style="color: #BA36A5;">sol</span> = odeint(dFdW, F0, Wspan)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now plot the results</span>
plt.plot(Wspan, sol[:,0], label=<span style="color: #008000;">'Conversion'</span>)
plt.plot(Wspan, sol[:,1], <span style="color: #008000;">'g--'</span>, label=<span style="color: #008000;">'y=$P/P_0$'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.xlabel(<span style="color: #008000;">'Catalyst weight (lb_m)'</span>)
plt.savefig(<span style="color: #008000;">'images/2013-01-08-pdrop.png'</span>)
</pre>
</div>

<p>
Here is the resulting figure.
</p>


<div id="org77ed417" class="figure">
<p><img src="pycse-chapters/images/2013-01-08-pdrop.png" alt="2013-01-08-pdrop.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgab6aab0" class="outline-3">
<h3 id="orgab6aab0"><span class="section-number-3">14.22.</span> Solving CSTR design equations</h3>
<div class="outline-text-3" id="text-14-22">
<p>
Given a continuously stirred tank reactor with a volume of 66,000 dm^3 where the reaction \(A \rightarrow B\) occurs, at a rate of \(-r_A = k C_A^2\) (\(k=3\) L/mol/h), with an entering molar flow of F_{A0} = 5 mol/h and a volumetric flowrate of 10 L/h, what is the exit concentration of A?
</p>

<p>
From a mole balance we know that at steady state \(0 = F_{A0} - F_A + V r_A\). That equation simply states the sum of the molar flow of A in in minus the molar flow of A out  plus the molar rate A is generated is equal to zero at steady state. This is directly the equation we need to solve. We need the following relationship:
</p>

<ol class="org-ol">
<li>\(F_A = v0 C_A\)</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">Fa0</span> = 5.0
<span style="color: #BA36A5;">v0</span> = 10.

<span style="color: #BA36A5;">V</span> = 66000.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reactor volume L^3</span>
<span style="color: #BA36A5;">k</span> = 3.0      <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate constant L/mol/h</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Ca):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Fa</span> = v0 * Ca     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">exit molar flow of A</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">ra</span> = -k * Ca**2  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate of reaction of A L/mol/h</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> Fa0 - Fa + V * ra

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">CA guess that that 90 % is reacted away</span>
<span style="color: #BA36A5;">CA_guess</span> = 0.1 * Fa0 / v0
<span style="color: #BA36A5;">CA_sol</span>, = fsolve(func, CA_guess)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The exit concentration is {0} mol/L'</span>.<span style="color: #006FE0;">format</span>(CA_sol))
</pre>
</div>

<pre class="example">
None
</pre>


<p>
It is a little confusing why it is necessary to put a comma after the CA_sol in the fsolve command. If you do not put it there, you get brackets around the answer.
</p>
</div>
</div>

<div id="outline-container-org0d3f2ad" class="outline-3">
<h3 id="org0d3f2ad"><span class="section-number-3">14.23.</span> Meet the steam tables</h3>
<div class="outline-text-3" id="text-14-23">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/31/matlab-meets-the-steam-tables/">Matlab post</a>
</p>

<p>
We will use the <a href="https://pypi.python.org/pypi/iapws">iapws</a> module. Install it like this:
</p>

<div class="org-src-container">
<pre class="src src-sh">pip install iapws
</pre>
</div>

<p>
Problem statement: A Rankine cycle operates using steam with the condenser at 100 degC, a pressure of 3.0 MPa and temperature of 600 degC in the boiler. Assuming the compressor and turbine operate reversibly, estimate the efficiency of the cycle.
</p>

<p>
Starting point in the Rankine cycle in condenser.
</p>

<p>
we have saturated liquid here, and we get the thermodynamic properties for the given temperature. In this python module, these properties are all in attributes of an IAPWS object created at a set of conditions.
</p>
</div>

<div id="outline-container-orgc51e371" class="outline-4">
<h4 id="orgc51e371"><span class="section-number-4">14.23.1.</span> Starting point in the Rankine cycle in condenser.</h4>
<div class="outline-text-4" id="text-14-23-1">
<p>
We have saturated liquid here, and we get the thermodynamic properties for the given temperature.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">import iapws</span>
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">print iapws.__version__</span>
<span style="color: #0000FF;">from</span> iapws <span style="color: #0000FF;">import</span> IAPWS97

<span style="color: #BA36A5;">T1</span> = 100 + 273.15 <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">in K</span>

<span style="color: #BA36A5;">sat_liquid1</span>  = IAPWS97(T=T1, x=0) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">x is the steam quality. 0 = liquid</span>

P1 = sat_liquid1.P
s1 = sat_liquid1.s
h1 = sat_liquid1.h
v1 = sat_liquid1.v
</pre>
</div>
</div>
</div>

<div id="outline-container-org2470e0b" class="outline-4">
<h4 id="org2470e0b"><span class="section-number-4">14.23.2.</span> Isentropic compression of liquid to point 2</h4>
<div class="outline-text-4" id="text-14-23-2">
<p>
The final pressure is given, and we need to compute the new temperatures, and enthalpy.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">P2</span> = 3.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">MPa</span>
<span style="color: #BA36A5;">s2</span> = s1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is what isentropic means</span>

<span style="color: #BA36A5;">sat_liquid2</span> = IAPWS97(P=P2, s=s1)
T2, = sat_liquid2.T
h2 = sat_liquid2.h

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">work done to compress liquid. This is an approximation, since the</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">volume does change a little with pressure, but the overall work here</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">is pretty small so we neglect the volume change.</span>
WdotP = v1*(P2 - P1);

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The compressor work is: {0:1.4f} kJ/kg'</span>.<span style="color: #006FE0;">format</span>(WdotP))

</pre>
</div>

<p>
The compression work is almost negligible. This number is 1000 times smaller than we computed with Xsteam. I wonder what the units of v1 actually are.
</p>
</div>
</div>

<div id="outline-container-org2121b9a" class="outline-4">
<h4 id="org2121b9a"><span class="section-number-4">14.23.3.</span> Isobaric heating to T3 in boiler where we make steam</h4>
<div class="outline-text-4" id="text-14-23-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">T3</span> = 600 + 273.15 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">K</span>
<span style="color: #BA36A5;">P3</span> = P2 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">definition of isobaric</span>
<span style="color: #BA36A5;">steam</span> = IAPWS97(P=P3, T=T3)

h3 = steam.h
s3 = steam.s

Qb, = h3 - h2 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">heat required to make the steam</span>

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The boiler heat duty is: {0:1.2f} kJ/kg'</span>.<span style="color: #006FE0;">format</span>(Qb))
</pre>
</div>
</div>
</div>

<div id="outline-container-org64a929e" class="outline-4">
<h4 id="org64a929e"><span class="section-number-4">14.23.4.</span> Isentropic expansion through turbine to point 4</h4>
<div class="outline-text-4" id="text-14-23-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">steam</span> =  IAPWS97(P=P1, s=s3)
T4, = steam.T
h4 = steam.h
s4 = s3 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">isentropic</span>
Qc, = h4 - h1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">work required to cool from T4 to T1</span>

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The condenser heat duty is {0:1.2f} kJ/kg'</span>.<span style="color: #006FE0;">format</span>(Qc))
</pre>
</div>
</div>
</div>

<div id="outline-container-org09394c7" class="outline-4">
<h4 id="org09394c7"><span class="section-number-4">14.23.5.</span> To get from point 4 to point 1</h4>
<div class="outline-text-4" id="text-14-23-5">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">WdotTurbine</span>, = h4 - h3 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">work extracted from the expansion</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The turbine work is: {0:1.2f} kJ/kg'</span>.<span style="color: #006FE0;">format</span>(WdotTurbine))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgef8ebaf" class="outline-4">
<h4 id="orgef8ebaf"><span class="section-number-4">14.23.6.</span> Efficiency</h4>
<div class="outline-text-4" id="text-14-23-6">
<p>
This is a ratio of the work put in to make the steam, and the net work obtained from the turbine. The answer here agrees with the efficiency calculated in Sandler on page 135.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">eta</span> = -(WdotTurbine - WdotP) / Qb
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The overall efficiency is {0:1.2%}.'</span>.<span style="color: #006FE0;">format</span>(eta))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c05393" class="outline-4">
<h4 id="org4c05393"><span class="section-number-4">14.23.7.</span> Entropy-temperature chart</h4>
<div class="outline-text-4" id="text-14-23-7">
<p>
The IAPWS module makes it pretty easy to generate figures of the steam tables. Here we generate an entropy-Temperature graph. We do this to illustrate the path of the Rankine cycle. We need to compute the values of steam entropy for a range of pressures and temperatures.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.figure()
plt.clf()
<span style="color: #BA36A5;">T</span> = np.linspace(300, 372+273, 200) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">range of temperatures</span>
<span style="color: #0000FF;">for</span> P <span style="color: #0000FF;">in</span> [0.1, 1, 2, 5, 10, 20]: <span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">MPa</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">steam</span> = [IAPWS97(T=t, P=P) <span style="color: #0000FF;">for</span> t <span style="color: #0000FF;">in</span> T]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   S = [s.s <span style="color: #0000FF;">for</span> s <span style="color: #0000FF;">in</span> steam]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(S, T, <span style="color: #008000;">'k-'</span>)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">saturated vapor and liquid entropy lines</span>
svap = [s.s <span style="color: #0000FF;">for</span> s <span style="color: #0000FF;">in</span> [IAPWS97(T=t, x=1) <span style="color: #0000FF;">for</span> t <span style="color: #0000FF;">in</span> T]]
sliq = [s.s <span style="color: #0000FF;">for</span> s <span style="color: #0000FF;">in</span> [IAPWS97(T=t, x=0) <span style="color: #0000FF;">for</span> t <span style="color: #0000FF;">in</span> T]]

plt.plot(svap, T, <span style="color: #008000;">'r-'</span>)
plt.plot(sliq, T, <span style="color: #008000;">'b-'</span>)

plt.xlabel(<span style="color: #008000;">'Entropy (kJ/(kg K)'</span>)
plt.ylabel(<span style="color: #008000;">'Temperature (K)'</span>)
plt.savefig(<span style="color: #008000;">'images/iawps-steam.png'</span>)
</pre>
</div>



<div id="org4bcb780" class="figure">
<p><img src="pycse-chapters/images/iawps-steam.png" alt="iawps-steam.png" />
</p>
</div>


<p>
We can plot our Rankine cycle path like this. We compute the entropies along the non-isentropic paths.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">T23</span> = np.linspace(T2, T3)
<span style="color: #BA36A5;">S23</span> = [s.s <span style="color: #0000FF;">for</span> s <span style="color: #0000FF;">in</span> [IAPWS97(P=P2, T=t) <span style="color: #0000FF;">for</span> t <span style="color: #0000FF;">in</span> T23]]

T41 = np.linspace(T4, T1 - 0.01) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">subtract a tiny bit to make sure we get a liquid</span>
S41 = [s.s <span style="color: #0000FF;">for</span> s <span style="color: #0000FF;">in</span> [IAPWS97(P=P1, T=t) <span style="color: #0000FF;">for</span> t <span style="color: #0000FF;">in</span> T41]]
</pre>
</div>

<p>
And then we plot the paths.
</p>

<div class="org-src-container">
<pre class="src src-python">plt.plot([s1, s2], [T1, T2], <span style="color: #008000;">'r-'</span>, lw=4) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Path 1 to 2</span>
plt.plot(S23, T23, <span style="color: #008000;">'b-'</span>, lw=4) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">path from 2 to 3 is isobaric</span>
plt.plot([s3, s4], [T3, T4], <span style="color: #008000;">'g-'</span>, lw=4) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">path from 3 to 4 is isentropic</span>
plt.plot(S41, T41, <span style="color: #008000;">'k-'</span>, lw=4) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">and from 4 to 1 is isobaric</span>
plt.savefig(<span style="color: #008000;">'images/iawps-steam-2.png'</span>)
plt.savefig(<span style="color: #008000;">'images/iawps-steam-2.svg'</span>)
</pre>
</div>


<div id="orgfc053a7" class="figure">
<p><img src="pycse-chapters/images/iawps-steam-2.png" alt="iawps-steam-2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org72a6019" class="outline-4">
<h4 id="org72a6019"><span class="section-number-4">14.23.8.</span> Summary</h4>
<div class="outline-text-4" id="text-14-23-8">
<p>
This was an interesting exercise. On one hand, the tedium of interpolating the steam tables is gone. On the other hand, you still have to know exactly what to ask for to get an answer that is correct. The iapws interface is a little clunky, and takes some getting used to. It does not seem as robust as the Xsteam module I used in Matlab.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc235fbb" class="outline-3">
<h3 id="orgc235fbb"><span class="section-number-3">14.24.</span> What region is a point in</h3>
<div class="outline-text-3" id="text-14-24">
<p>
Suppose we have a space that is divided by a boundary into two regions, and we want to know if an arbitrary point is on one region or the other. One way to figure this out is to pick a point that is known to be in a region, and then draw a line to the arbitrary point counting the number of times it crosses the boundary. If the line crosses an even number of times, then the point is in the same region and if it crosses an odd number of times, then the point is in the other region.
</p>

<p>
Here is the boundary and region we consider in this example:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #BA36A5;">boundary</span> = [[0.1, 0],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.25, 0.1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.3, 0.2],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.35, 0.34],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.4, 0.43],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.51, 0.47],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.48, 0.55],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.44, 0.62],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.5, 0.66],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.55,0.57],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.556, 0.48],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.63, 0.43],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.70, 0.44],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.8, 0.51],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.91, 0.57],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [1.0, 0.6]]

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.clf()
plt.plot([p[0] <span style="color: #0000FF;">for</span> p <span style="color: #0000FF;">in</span> boundary],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[p[1] <span style="color: #0000FF;">for</span> p <span style="color: #0000FF;">in</span> boundary])
plt.ylim([0, 1])
plt.savefig(<span style="color: #008000;">'images/boundary-1.png'</span>)
</pre>
</div>


<div id="orgd0a37ac" class="figure">
<p><img src="pycse-chapters/images/boundary-1.png" alt="boundary-1.png" />
</p>
</div>

<p>
In this example, the boundary is complicated, and not described by a simple function. We will check for intersections of the line from the arbitrary point to the reference point with each segment defining the boundary. If there is an intersection in the boundary, we count that as a crossing. We choose the origin (0, 0) in this case for the reference point. For an arbitrary point (x1, y1), the equation of the line is therefore (provided x1 !=0):
</p>

<p>
\(y = \frac{y1}{x1} x\).
</p>

<p>
Let the points defining a boundary segment be (bx1, by1) and (bx2, by2). The equation for the line connecting these points (provided bx1 != bx2) is:
</p>

<p>
\(y = by1 + \frac{by2 - by1}{bx2 - bx1}(x - bx1)\)
</p>

<p>
Setting these two equations equal to each other, we can solve for the value of \(x\), and if \(bx1 <= x <= bx2\) then we would say there is an intersection with that segment. The solution for x is:
</p>

<p>
\(x = \frac{m bx1 - by1}{m - y1/x1}\)
</p>

<p>
This can only fail if \(m = y1/x1\) which means the segments are parallel and either do not intersect or go through each other. One issue we have to resolve is what to do when the intersection is at the boundary. In that case, we would see an intersection with two segments since bx1 of one segment is also bx2 of another segment. We resolve the issue by only counting intersections with bx1. Finally, there may be intersections at values of \(x\) greater than the point, and we are not interested in those because the intersections are not between the point and reference point.
</p>

<p>
Here are all of the special cases that we  have to handle:
</p>


<div id="org44d4dda" class="figure">
<p><img src="pycse-chapters/images/region-determination.png" alt="region-determination.png" />
</p>
</div>

<p>
We will have to do float comparisons, so we will define <a href="pycse-chapters/math.html#org5b69bee">tolerance functions</a> for all of these. I tried this previously with regular comparison operators, and there were many cases that did not work because of float comparisons. In the code that follows, we define the tolerance functions, the function that handles almost all the special cases, and show that it almost always correctly identifies the region a point is in.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">TOLERANCE</span> = 2 * np.spacing(1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">feq</span>(x, y, epsilon=TOLERANCE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x == y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">not</span>((x &lt; (y - epsilon)) <span style="color: #0000FF;">or</span> (y &lt; (x - epsilon)))

<span style="color: #0000FF;">def</span> <span style="color: #006699;">flt</span>(x, y, epsilon=TOLERANCE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &lt; y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x &lt; (y - epsilon)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fgt</span>(x, y, epsilon=TOLERANCE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &gt; y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y &lt; (x - epsilon)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fle</span>(x, y, epsilon=TOLERANCE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &lt;= y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">not</span>(y &lt; (x - epsilon))


<span style="color: #0000FF;">def</span> <span style="color: #006699;">fge</span>(x, y, epsilon=TOLERANCE):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'x &gt;= y'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">not</span>(x &lt; (y - epsilon))

boundary = [[0.1, 0],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.25, 0.1],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.3, 0.2],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.35, 0.34],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.4, 0.43],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.51, 0.47],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.48, 0.55],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.44, 0.62],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.5, 0.66],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.55,0.57],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.556, 0.48],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.63, 0.43],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.70, 0.44],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.8, 0.51],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [0.91, 0.57],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   [1.0, 0.6]]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">intersects</span>(p, isegment):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'p is a point (x1, y1), isegment is an integer indicating which segment starting with 0'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x1, y1 = p
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   bx1, by1 = boundary[isegment]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   bx2, by2 = boundary[isegment + 1]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> feq(bx1, bx2) <span style="color: #0000FF;">and</span> feq(x1, 0.0): <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">both segments are vertical</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> feq(bx1, x1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">elif</span> feq(bx1, bx2):  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">segment is vertical</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   m1 = y1 / x1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">slope of reference line</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   y = m1 * bx1 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">value of reference line at bx1</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> ((fge(y, by1) <span style="color: #0000FF;">and</span> flt(y, by2))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">or</span> (fle(y, by1) <span style="color: #0000FF;">and</span> fgt(y,by2))):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reference line intersects the segment</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">neither reference line nor segment is vertical</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   m = (by2 - by1) / (bx2 - bx1) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">segment slope</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   m1 = y1 / x1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> feq(m, m1): <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">line and segment are parallel</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> feq(y1, m * bx1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">lines are not parallel</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x = (m * bx1 - by1) / (m - m1) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">x at intersection</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> ((fge(x, bx1) <span style="color: #0000FF;">and</span> flt(x, bx2))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">or</span> (fle(x, bx1) <span style="color: #0000FF;">and</span> fgt(x, bx2))) <span style="color: #0000FF;">and</span> fle(x, x1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">raise</span> <span style="color: #6434A3;">Exception</span>(<span style="color: #008000;">'you should not get here'</span>)

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.plot([p[0] <span style="color: #0000FF;">for</span> p <span style="color: #0000FF;">in</span> boundary],
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>[p[1] <span style="color: #0000FF;">for</span> p <span style="color: #0000FF;">in</span> boundary], <span style="color: #008000;">'go-'</span>)
plt.ylim([0, 1])

N = 100

X = np.linspace(0, 1, N)

<span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> X:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> y <span style="color: #0000FF;">in</span> X:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   p = (x, y)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   nintersections = <span style="color: #006FE0;">sum</span>([intersects(p, i) <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(boundary) - 1)])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> nintersections % 2 == 0:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(x, y, <span style="color: #008000;">'r.'</span>)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   plt.plot(x, y, <span style="color: #008000;">'b.'</span>)

plt.savefig(<span style="color: #008000;">'images/boundary-2.png'</span>)
</pre>
</div>


<div id="org4c0afa2" class="figure">
<p><img src="pycse-chapters/images/boundary-2.png" alt="boundary-2.png" />
</p>
</div>

<p>
If you look carefully, there are two blue points in the red region, which means there is some edge case we do not capture in our function. Kudos to the person who figures it out.
Update: It was pointed out that the points intersect a point on the line.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf839a3" class="outline-2">
<h2 id="orgcf839a3"><span class="section-number-2">15.</span> Units</h2>
<div class="outline-text-2" id="text-15">
</div>
<div id="outline-container-org7b1092e" class="outline-3">
<h3 id="org7b1092e"><span class="section-number-3">15.1.</span> Using units in python</h3>
<div class="outline-text-3" id="text-15-1">
<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/05/using-cmu-units-in-matlab-for-basic-calculations/">Units in Matlab</a>
</p>

<p>
I think an essential feature in an engineering computational environment is properly handling units and unit conversions. Mathcad supports that pretty well. I wrote a <a href="https://github.com/jkitchin/matlab-cmu">package</a> for doing it in Matlab. Today I am going to explore units in python. Here are some of the packages that I have found which support units to some extent
</p>

<ol class="org-ol">
<li><a href="http://pypi.python.org/pypi/units/">http://pypi.python.org/pypi/units/</a></li>
<li><a href="http://packages.python.org/quantities/user/tutorial.html">http://packages.python.org/quantities/user/tutorial.html</a></li>
<li><a href="http://dirac.cnrs-orleans.fr/ScientificPython/ScientificPythonManual/Scientific.Physics.PhysicalQuantities-module.html">http://dirac.cnrs-orleans.fr/ScientificPython/ScientificPythonManual/Scientific.Physics.PhysicalQuantities-module.html</a></li>
<li><a href="http://home.scarlet.be/be052320/Unum.html">http://home.scarlet.be/be052320/Unum.html</a></li>
<li><a href="https://simtk.org/home/python_units">https://simtk.org/home/python_units</a></li>
<li><a href="http://docs.enthought.com/scimath/units/intro.html">http://docs.enthought.com/scimath/units/intro.html</a></li>
</ol>

<p>
The last one looks most promising.
</p>
</div>

<div id="outline-container-orgbd8b72d" class="outline-4">
<h4 id="orgbd8b72d"><span class="section-number-4">15.1.1.</span> scimath</h4>
<div class="outline-text-4" id="text-15-1-1">
<p>
scimath may only wok in Python2.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scimath.units.volume <span style="color: #0000FF;">import</span> liter
<span style="color: #0000FF;">from</span> scimath.units.substance <span style="color: #0000FF;">import</span> mol

<span style="color: #BA36A5;">q</span> = np.array([1, 2, 3]) * mol
<span style="color: #0000FF;">print</span>(q)

<span style="color: #BA36A5;">P</span> = q / liter
<span style="color: #0000FF;">print</span>(P)
</pre>
</div>

<p>
That doesn't look too bad. It is a little clunky to have to import every unit, and it is clear the package is saving everything in SI units by default. Let us try to solve an equation.
</p>

<p>
Find the time that solves this equation.
</p>

<p>
\(0.01 = C_{A0} e^{-kt}\)
</p>

<p>
First we solve without units. That way we know the answer.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">CA0</span> = 1.0  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol/L</span>
<span style="color: #BA36A5;">CA</span> = 0.01  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol/L</span>
<span style="color: #BA36A5;">k</span> = 1.0    <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1/s</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">z</span> = CA - CA0 * np.exp(-k*t)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> z

<span style="color: #BA36A5;">t0</span> = 2.3

<span style="color: #BA36A5;">t</span>, = fsolve(func, t0)
<span style="color: #0000FF;">print</span> <span style="color: #008000;">'t = {0:1.2f} seconds'</span>.<span style="color: #006FE0;">format</span>(t)
</pre>
</div>


<p>
Now, with units. I note here that I tried the obvious thing of just importing the units, and adding them on, but the package is unable to work with floats that have units. For some functions, there must be an ndarray with units which is practically what the UnitScalar code below does.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">from</span> scimath.units.volume <span style="color: #0000FF;">import</span> liter
<span style="color: #0000FF;">from</span> scimath.units.substance <span style="color: #0000FF;">import</span> mol
<span style="color: #0000FF;">from</span> scimath.units.time <span style="color: #0000FF;">import</span> second
<span style="color: #0000FF;">from</span> scimath.units.api <span style="color: #0000FF;">import</span> has_units, UnitScalar

<span style="color: #BA36A5;">CA0</span> = UnitScalar(1.0, units = mol / liter)
CA = UnitScalar(0.01, units = mol / liter)
k = UnitScalar(1.0, units = 1 / second)

<span style="color: #6434A3;">@has_units</span>(inputs=<span style="color: #008000;">"t::units=s"</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  outputs=<span style="color: #008000;">"result::units=mol/liter"</span>)
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   z = CA - CA0 * <span style="color: #006FE0;">float</span>(np.exp(-k*t))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> z

t0 = UnitScalar(2.3, units = second)

<span style="color: #BA36A5;">t</span>, = fsolve(func, t0)
<span style="color: #0000FF;">print</span> <span style="color: #008000;">'t = {0:1.2f} seconds'</span>.<span style="color: #006FE0;">format</span>(t)
<span style="color: #0000FF;">print</span> <span style="color: #006FE0;">type</span>(t)
</pre>
</div>

<p>
This is some heavy syntax that in the end does not preserve the units. In my Matlab package, we had to "wrap" many functions like fsolve so they would preserve units. Clearly this package will need that as well. Overall, in its current implementation this package does not do what I would expect all the time.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>
</p>
</div>
</div>
</div>

<div id="outline-container-orgbcb78f6" class="outline-3">
<h3 id="orgbcb78f6"><span class="section-number-3">15.2.</span> Handling units with the quantities module</h3>
<div class="outline-text-3" id="text-15-2">
<p>
The quantities module (<a href="https://pypi.python.org/pypi/quantities">https://pypi.python.org/pypi/quantities</a>) is another option for handling units in python. We are going to try the previous example. It does not work, because scipy.optimize.fsolve is not designed to work with units.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #BA36A5;">CA0</span> = 1 * u.mol / u.L
<span style="color: #BA36A5;">CA</span> = 0.01 * u.mol / u.L
<span style="color: #BA36A5;">k</span> = 1.0 / u.s

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> CA - CA0 * np.exp(-k * t)

<span style="color: #BA36A5;">tguess</span> = 4 * u.s

<span style="color: #0000FF;">print</span>(func(tguess))

<span style="color: #0000FF;">print</span>(fsolve(func, tguess))
</pre>
</div>

<p>
Our function works fine with units, but fsolve does not pass numbers with units back to the function, so this function fails because the exponential function gets an argument with dimensions in it.  We can create a new function that solves this problem. We need to "wrap" the function we want to solve to make sure that it uses units, but returns a float number. Then, we put the units back onto the final solved value. Here is how we do that.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve <span style="color: #0000FF;">as</span> _fsolve

<span style="color: #BA36A5;">CA0</span> = 1 * u.mol / u.L
<span style="color: #BA36A5;">CA</span> = 0.01 * u.mol / u.L
<span style="color: #BA36A5;">k</span> = 1.0 / u.s

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> CA - CA0 * np.exp(-k * t)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fsolve</span>(func, t0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'wrapped fsolve command to work with units'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">tU</span> = t0 / <span style="color: #006FE0;">float</span>(t0)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">units on initial guess, normalized</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">wrapped_func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'t will be unitless, so we add unit to it. t * tU has units.'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #006FE0;">float</span>(func(t * tU))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">sol</span>, = _fsolve(wrapped_func, t0)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> sol * tU

<span style="color: #BA36A5;">tguess</span> = 4 * u.s

<span style="color: #0000FF;">print</span>(fsolve(func, tguess))
</pre>
</div>

<p>
It is a little tedious to do this, but we might only have to do it once if we store the new fsolve command in a module. You might notice the wrapped function we wrote above only works for one dimensional problems. If there are multiple dimensions, we have to be a little more careful. In the next example, we expand the wrapped function definition to do both one and multidimensional problems. It appears we cannot use numpy.array element-wise multiplication because you cannot mix units in an array. We will use lists instead. When the problem is one-dimensional, the function will take a scalar, but when it is multidimensional it will take a list or array. We will use try/except blocks to handle these two cases. We will assume multidimensional cases, and if that raises an exception because the argument is not a list, we assume it is scalar. Here is the more robust code example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve <span style="color: #0000FF;">as</span> _fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fsolve</span>(func, t0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''wrapped fsolve command to work with units. We get the units on</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   the function argument, then wrap the function so we can add units</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   to the argument and return floats. Finally we call the original</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   fsolve from scipy. Note: this does not support all of the options</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   to fsolve.'''</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   tU = [t / <span style="color: #006FE0;">float</span>(t) <span style="color: #0000FF;">for</span> t <span style="color: #0000FF;">in</span> t0]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">units on initial guess, normalized</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   tU = t0 / <span style="color: #006FE0;">float</span>(t0)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">wrapped_func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'t will be unitless, so we add unit to it. t * tU has units.'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   T = [x1 * x2 <span style="color: #0000FF;">for</span> x1,x2 <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(t, tU)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   T = t * tU

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [<span style="color: #006FE0;">float</span>(x) <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> func(T)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #006FE0;">float</span>(func(T))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sol = _fsolve(wrapped_func, t0)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [x1 * x2 <span style="color: #0000FF;">for</span> x1,x2 <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(sol, tU)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> sol * tU

<span style="color: #8D8D84; background-color: #E6ECFF;">### </span><span style="color: #8D8D84; background-color: #E6ECFF; font-style: italic;">Problem 1</span>
<span style="color: #BA36A5;">CA0</span> = 1 * u.mol / u.L
<span style="color: #BA36A5;">CA</span> = 0.01 * u.mol / u.L
<span style="color: #BA36A5;">k</span> = 1.0 / u.s

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> CA - CA0 * np.exp(-k * t)


<span style="color: #BA36A5;">tguess</span> = 4 * u.s
<span style="color: #BA36A5;">sol1</span>, = fsolve(func, tguess)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'sol1 = '</span>,sol1)

<span style="color: #8D8D84; background-color: #E6ECFF;">### </span><span style="color: #8D8D84; background-color: #E6ECFF; font-style: italic;">Problem 2</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func2</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">a</span>,<span style="color: #BA36A5;">b</span> = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [a**2 - 4*u.kg**2,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   b**2 - 25*u.J**2]

Xguess = [2.2*u.kg, 5.2*u.J]
<span style="color: #BA36A5;">s2a</span>, <span style="color: #BA36A5;">s2b</span> = fsolve(func2, Xguess)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'s2a = {0}\ns2b = {1}'</span>.<span style="color: #006FE0;">format</span>(s2a, s2b))
</pre>
</div>

<p>
That is pretty good. There is still room for improvement in the wrapped function, as it does not support all of the options that scipy.optimize.fsolve supports. Here is a draft of a function that does that. We have to return different numbers of arguments depending on the value of full_output. This function works, but I have not fully tested all the options. Here are three examples that work, including one with an argument.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve <span style="color: #0000FF;">as</span> _fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">fsolve</span>(func, t0, args=(),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  fprime=<span style="color: #D0372D;">None</span>, full_output=0, col_deriv=0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  xtol=1.49012e-08, maxfev=0, band=<span style="color: #D0372D;">None</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  epsfcn=0.0, factor=100, diag=<span style="color: #D0372D;">None</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'''wrapped fsolve command to work with units. We get the units on</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   the function argument, then wrap the function so we can add units</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   to the argument and return floats. Finally we call the original</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #036A07;">   fsolve from scipy. '''</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   tU = [t / <span style="color: #006FE0;">float</span>(t) <span style="color: #0000FF;">for</span> t <span style="color: #0000FF;">in</span> t0]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">units on initial guess, normalized</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   tU = t0 / <span style="color: #006FE0;">float</span>(t0)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">wrapped_func</span>(t, *args):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #036A07;">'t will be unitless, so we add unit to it. t * tU has units.'</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   T = [x1 * x2 <span style="color: #0000FF;">for</span> x1,x2 <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(t, tU)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   T = t * tU

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [<span style="color: #006FE0;">float</span>(x) <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> func(T, *args)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #006FE0;">float</span>(func(T))

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   sol = _fsolve(wrapped_func, t0, args,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  fprime, full_output, col_deriv,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  xtol, maxfev, band,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  epsfcn, factor, diag)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> full_output:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x, infodict, ier, mesg = sol
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x = [x1 * x2 <span style="color: #0000FF;">for</span> x1,x2 <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(x, tU)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x = x * tU
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x, infodict, ier, mesg
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x = [x1 * x2 <span style="color: #0000FF;">for</span> x1,x2 <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(sol, tU)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   x = sol * tU
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> x

<span style="color: #8D8D84; background-color: #E6ECFF;">### </span><span style="color: #8D8D84; background-color: #E6ECFF; font-style: italic;">Problem 1</span>
CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> CA - CA0 * np.exp(-k * t)


tguess = 4 * u.s
sol1, = fsolve(func, tguess)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'sol1 = '</span>,sol1)

<span style="color: #8D8D84; background-color: #E6ECFF;">### </span><span style="color: #8D8D84; background-color: #E6ECFF; font-style: italic;">Problem 2</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func2</span>(X):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   a,b = X
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [a**2 - 4*u.kg**2,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   b**2 - 25*u.J**2]

Xguess = [2.2*u.kg, 5.2*u.J]
sol, infodict, ier, mesg = fsolve(func2, Xguess, full_output=1)
s2a, s2b = sol
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'s2a = {0}\ns2b = {1}'</span>.<span style="color: #006FE0;">format</span>(s2a, s2b))

<span style="color: #8D8D84; background-color: #E6ECFF;">### </span><span style="color: #8D8D84; background-color: #E6ECFF; font-style: italic;">Problem 3 - with an arg</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">func3</span>(a, arg):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> a**2 - 4*u.kg**2 + arg**2

Xguess = 1.5 * u.kg
arg = 0.0* u.kg

sol3, = fsolve(func3, Xguess, args=(arg,))

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'sol3 = '</span>, sol3)
</pre>
</div>

<p>
The only downside I can see in the quantities module is that it only handle temperature differences, and not absolute temperatures. If you only use absolute temperatures, this would not be a problem I think. But, if you have mixed temperature scales, the quantities module does not convert them on an absolute scale.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u

<span style="color: #BA36A5;">T</span> = 20 * u.degC

<span style="color: #0000FF;">print</span>(T.rescale(u.K))
<span style="color: #0000FF;">print</span>(T.rescale(u.degF))
</pre>
</div>

<p>
Nevertheless, this module seems pretty promising, and there are a lot more features than shown here. Some documentation can be found at <a href="http://pythonhosted.org/quantities/">http://pythonhosted.org/quantities/</a>.
</p>
</div>
</div>

<div id="outline-container-orgaa00542" class="outline-3">
<h3 id="orgaa00542"><span class="section-number-3">15.3.</span> Units in ODEs</h3>
<div class="outline-text-3" id="text-15-3">
<p>
We reconsider a simple ODE but this time with units. We will use the quantities package again.
</p>

<p>
Here is the ODE, \(\frac{dCa}{dt} = -k Ca\) with \(C_A(0) = 1.0\) mol/L and \(k = 0.23\) 1/s. Compute the concentration after 5 s.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u

<span style="color: #BA36A5;">k</span> = 0.23 / u.s
<span style="color: #BA36A5;">Ca0</span> = 1 * u.mol / u.L

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dCadt</span>(Ca, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -k * Ca

<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 5) * u.s

<span style="color: #BA36A5;">sol</span> = odeint(dCadt, Ca0, tspan)

<span style="color: #0000FF;">print</span>(sol[-1])
</pre>
</div>

<p>
No surprise, the units are lost. Now we start wrapping odeint. We wrap everything, and then test two examples including a single ODE, and a coupled set of ODEs with mixed units.
</p>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint <span style="color: #0000FF;">as</span> _odeint

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odeint</span>(func, y0, t, args=(),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  Dfun=<span style="color: #D0372D;">None</span>, col_deriv=0, full_output=0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  ml=<span style="color: #D0372D;">None</span>, mu=<span style="color: #D0372D;">None</span>, rtol=<span style="color: #D0372D;">None</span>, atol=<span style="color: #D0372D;">None</span>,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  tcrit=<span style="color: #D0372D;">None</span>, h0=0.0, hmax=0.0, hmin=0.0,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  ixpr=0, mxstep=0, mxhnil=0, mxordn=12,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>  mxords=5, printmessg=0):

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">wrapped_func</span>(Y0, T, *args):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">put units on T if they are on the original t</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">check for units so we don't put them on twice</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #0000FF;">not</span> <span style="color: #006FE0;">hasattr</span>(T, <span style="color: #008000;">'units'</span>) <span style="color: #0000FF;">and</span> <span style="color: #006FE0;">hasattr</span>(t, <span style="color: #008000;">'units'</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   T = T * t.units
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now for the dependent variable units. Y0 may be a scalar or</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">a list or an array. we want to check each element of y0 for</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">units, and add them to the corresponding element of Y0 if we</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">need to.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   uY0 = [x <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> Y0] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">a list copy of contents of Y0</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this works if y0 is an iterable, eg. a list or array</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i, yi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(y0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #0000FF;">not</span> <span style="color: #006FE0;">hasattr</span>(uY0[i],<span style="color: #008000;">'units'</span>) <span style="color: #0000FF;">and</span> <span style="color: #006FE0;">hasattr</span>(yi, <span style="color: #008000;">'units'</span>):

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   uY0[<span style="color: #BA36A5;">i</span>] = uY0[i] * yi.units

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we have a scalar</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #0000FF;">not</span> <span style="color: #006FE0;">hasattr</span>(Y0, <span style="color: #008000;">'units'</span>) <span style="color: #0000FF;">and</span> <span style="color: #006FE0;">hasattr</span>(y0, <span style="color: #008000;">'units'</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   uY0 = Y0 * y0.units

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   val = func(uY0, t, *args)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">try</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> np.array([<span style="color: #006FE0;">float</span>(x) <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> val])
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">except</span> <span style="color: #6434A3;">TypeError</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #006FE0;">float</span>(val)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> full_output:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   y, infodict = _odeint(wrapped_func, y0, t, args,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> Dfun, col_deriv, full_output,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> ml, mu, rtol, atol,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> tcrit, h0, hmax, hmin,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> ixpr, mxstep, mxhnil, mxordn,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span> mxords, printmessg)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   y = _odeint(wrapped_func, y0, t, args,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   Dfun, col_deriv, full_output,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ml, mu, rtol, atol,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   tcrit, h0, hmax, hmin,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ixpr, mxstep, mxhnil, mxordn,
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   mxords, printmessg)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">now we need to put units onto the solution units should be the</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">same as y0. We cannot put mixed units in an array, so, we return a list</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   m,n = y.shape <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">y is an ndarray, so it has a shape</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> n &gt; 1: <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">more than one equation, we need a list</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   uY = [0 <span style="color: #0000FF;">for</span> yi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(n)]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> i, yi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(y0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #0000FF;">not</span> <span style="color: #006FE0;">hasattr</span>(uY[i],<span style="color: #008000;">'units'</span>) <span style="color: #0000FF;">and</span> <span style="color: #006FE0;">hasattr</span>(yi, <span style="color: #008000;">'units'</span>):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   uY[<span style="color: #BA36A5;">i</span>] = y[:,i] * yi.units
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   uY[<span style="color: #BA36A5;">i</span>] = y[:,i]

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   uY = y * y0.units

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   y = uY


<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> full_output:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y, infodict
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> y

<span style="color: #8D8D84; background-color: #E6ECFF;">##################################################################</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">test a single ODE</span>
k = 0.23 / u.s
Ca0 = 1 * u.mol / u.L

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dCadt</span>(Ca, t):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -k * Ca

tspan = np.linspace(0, 5) * u.s
sol = odeint(dCadt, Ca0, tspan)

<span style="color: #0000FF;">print</span>(sol[-1])

plt.plot(tspan, sol)
plt.xlabel(<span style="color: #008000;">'Time ({0})'</span>.<span style="color: #006FE0;">format</span>(tspan.dimensionality.latex))
plt.ylabel(<span style="color: #008000;">'$C_A$ ({0})'</span>.<span style="color: #006FE0;">format</span>(sol.dimensionality.latex))
plt.savefig(<span style="color: #008000;">'images/ode-units-ca.png'</span>)

<span style="color: #8D8D84; background-color: #E6ECFF;">##################################################################</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">test coupled ODEs</span>
lbmol = 453.59237*u.mol

kprime = 0.0266 * lbmol / u.hr / u.lb
Fa0 = 1.08 * lbmol / u.hr
alpha = 0.0166 / u.lb
epsilon = -0.15

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dFdW</span>(F, W, alpha0):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   X, y = F
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   dXdW = kprime / Fa0 * (1.0 - X)/(1.0 + epsilon * X) * y
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   dydW = - alpha0 * (1.0 + epsilon * X) / (2.0 * y)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> [dXdW, dydW]

X0 = 0.0 * u.dimensionless
y0 = 1.0

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">initial conditions</span>
F0 = [X0, y0] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">one without units, one with units, both are dimensionless</span>

wspan = np.linspace(0,60) * u.lb

sol = odeint(dFdW, F0, wspan, args=(alpha,))
X, y = sol

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Test 2'</span>)
<span style="color: #0000FF;">print</span>(X[-1])
<span style="color: #0000FF;">print</span>(y[-1])

plt.figure()
plt.plot(wspan, X, wspan, y)
plt.legend([<span style="color: #008000;">'X'</span>,<span style="color: #008000;">'$P/P_0$'</span>])
plt.xlabel(<span style="color: #008000;">'Catalyst weight ({0})'</span>.<span style="color: #006FE0;">format</span>(wspan.dimensionality.latex))
plt.savefig(<span style="color: #008000;">'images/ode-coupled-units-pdrpo.png'</span>)
</pre>
</div>


<div id="orgcceaba6" class="figure">
<p><img src="pycse-chapters/images/ode-units-ca.png" alt="ode-units-ca.png" />
</p>
</div>


<div id="org8e4ea84" class="figure">
<p><img src="pycse-chapters/images/ode-coupled-units-pdrpo.png" alt="ode-coupled-units-pdrpo.png" />
</p>
</div>

<p>
That is not too bad. This is another example of a function you would want to save in a module for reuse. There is one bad feature of the wrapped odeint function, and that is that it changes the solution for coupled ODEs from an ndarray to a list. That is necessary because you apparently cannot have mixed units in an ndarray. It is fine, however, to have a list of mixed units. This is not a huge problem, but it changes the syntax for plotting results for the wrapped odeint function compared to the unwrapped function without units.
</p>
</div>
</div>

<div id="outline-container-org886771b" class="outline-3">
<h3 id="org886771b"><span class="section-number-3">15.4.</span> Handling units with dimensionless equations</h3>
<div class="outline-text-3" id="text-15-4">
<p>
As we have seen, handling units with third party functions is fragile, and often requires additional code to wrap the function to handle the units. An alternative approach that avoids the wrapping is to rescale the equations so they are dimensionless. Then, we should be able to use all the standard external functions without modification. We obtain the final solutions by rescaling back to the answers we want.
</p>

<p>
Before doing the examples, let us consider how the quantities package handles dimensionless numbers.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u

<span style="color: #BA36A5;">a</span> = 5 * u.m
<span style="color: #BA36A5;">L</span> = 10 * u.m <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">characteristic length</span>

<span style="color: #0000FF;">print</span>(a/L)
<span style="color: #0000FF;">print</span>(<span style="color: #006FE0;">type</span>(a/L))
</pre>
</div>

<p>
As you can see, the dimensionless number is scaled properly, and is listed as dimensionless. The result is still an instance of a quantities object though. That is not likely to be a problem.
</p>

<p>
Now, we consider using fsolve with dimensionless equations. Our goal is to solve \(C_A = C_{A0} \exp(-k t)\) for the time required to reach a desired \(C_A\). We let \(X = Ca / Ca0\) and \(\tau = t * k\), which leads to \(X = \exp{-\tau}\) in dimensionless terms.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">CA0</span> = 1 * u.mol / u.L
<span style="color: #BA36A5;">CA</span> = 0.01 * u.mol / u.L  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">desired exit concentration</span>
<span style="color: #BA36A5;">k</span> = 1.0 / u.s

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">we need new dimensionless variables</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">let X = Ca / Ca0</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">so, Ca = Ca0 * X</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">let tau = t * k</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">so t = tau / k</span>

<span style="color: #BA36A5;">X</span> = CA / CA0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">desired exit dimensionless concentration</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(tau):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> X - np.exp(-tau)

<span style="color: #BA36A5;">tauguess</span> = 2

<span style="color: #0000FF;">print</span>(func(tauguess)) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">confirm we have a dimensionless function</span>

<span style="color: #BA36A5;">tau_sol</span>, = fsolve(func, tauguess)
<span style="color: #BA36A5;">t</span> = tau_sol / k
<span style="color: #0000FF;">print</span>(t)
</pre>
</div>

<p>
Now consider the ODE \(\frac{dCa}{dt} = -k Ca\). We let \(X = Ca/Ca0\), so \(Ca0 dX = dCa\). Let \(\tau = t * k\) which in this case is dimensionless. That means \(d\tau = k dt\). Substitution of these new variables leads to:
</p>

<p>
\(Ca0*k \frac{dX}{d\tau} = -k Ca0 X \)
</p>

<p>
or equivalently:
\(\frac{dX}{d\tau} = -X \)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> quantities <span style="color: #0000FF;">as</span> u

<span style="color: #BA36A5;">k</span> = 0.23 / u.s
<span style="color: #BA36A5;">Ca0</span> = 1 * u.mol / u.L

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Let X = Ca/Ca0  -&gt; Ca = Ca0 * X  dCa = dX/Ca0</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">let tau = t * k -&gt; dt = 1/k dtau</span>


<span style="color: #0000FF;">def</span> <span style="color: #006699;">dXdtau</span>(X, tau):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> -X

<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> odeint

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 5) * u.s
<span style="color: #BA36A5;">tauspan</span> = tspan * k

<span style="color: #BA36A5;">X0</span> = 1
<span style="color: #BA36A5;">X_sol</span> = odeint(dXdtau, X0, tauspan)

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Ca at t = {0} = {1}'</span>.<span style="color: #006FE0;">format</span>(tspan[-1], X_sol.flatten()[-1] * Ca0))
</pre>
</div>

<p>
That is pretty much it. Using dimensionless quantities simplifies the need to write wrapper code, although it does increase the effort to rederive your equations (with corresponding increased opportunities to make mistakes). Using units to confirm your dimensionless derivation reduces those opportunities.
</p>

<p>
#+include t: pycse-chapters/license.org :minlevel 1
</p>
</div>
</div>
</div>


<div id="outline-container-orge95662c" class="outline-2">
<h2 id="orge95662c"><span class="section-number-2">16.</span> Additional References</h2>
<div class="outline-text-2" id="text-16">
<ol class="org-ol">
<li>Tutorials on the scientific Python ecosystem: a quick introduction to central tools and techniques. The different chapters each correspond to a 1 to 2 hours course with increasing level of expertise, from beginner to expert. <a href="http://scipy-lectures.org/">http://scipy-lectures.org/</a></li>
</ol>


<p>

</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
See Fogler, 4th ed. page 1025 for the setup of this equation.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Fogler, 4th edition. page 193.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
Then again no package does yet!
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2021-09-22 Wed 16:41</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
